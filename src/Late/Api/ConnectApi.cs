/*
 * Late API
 *
 * API reference for Late. Authenticate with a Bearer API key. Base URL: https://getlate.dev/api 
 *
 * The version of the OpenAPI document: 1.0.1
 * Contact: support@getlate.dev
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */


using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Linq;
using System.Net;
using System.Net.Http;
using System.Net.Mime;
using Late.Client;
using Late.Model;

namespace Late.Api
{

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public interface IConnectApiSync : IApiAccessor
    {
        #region Synchronous Operations
        /// <summary>
        /// Check Telegram status
        /// </summary>
        /// <remarks>
        /// Poll this endpoint to check if a Telegram access code has been used to connect a channel/group. Recommended polling interval: 3 seconds. Status values: pending (waiting for user), connected (channel/group linked), expired (generate a new code). 
        /// </remarks>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="code">The access code to check status for</param>
        /// <returns>CompleteTelegramConnect200Response</returns>
        CompleteTelegramConnect200Response CompleteTelegramConnect(string code);

        /// <summary>
        /// Check Telegram status
        /// </summary>
        /// <remarks>
        /// Poll this endpoint to check if a Telegram access code has been used to connect a channel/group. Recommended polling interval: 3 seconds. Status values: pending (waiting for user), connected (channel/group linked), expired (generate a new code). 
        /// </remarks>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="code">The access code to check status for</param>
        /// <returns>ApiResponse of CompleteTelegramConnect200Response</returns>
        ApiResponse<CompleteTelegramConnect200Response> CompleteTelegramConnectWithHttpInfo(string code);
        /// <summary>
        /// Connect Bluesky account
        /// </summary>
        /// <remarks>
        /// Connect a Bluesky account using identifier (handle or email) and an app password. To get your userId for the state parameter, call GET /v1/users which includes a currentUserId field. 
        /// </remarks>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="connectBlueskyCredentialsRequest"></param>
        /// <returns>ConnectBlueskyCredentials200Response</returns>
        ConnectBlueskyCredentials200Response ConnectBlueskyCredentials(ConnectBlueskyCredentialsRequest connectBlueskyCredentialsRequest);

        /// <summary>
        /// Connect Bluesky account
        /// </summary>
        /// <remarks>
        /// Connect a Bluesky account using identifier (handle or email) and an app password. To get your userId for the state parameter, call GET /v1/users which includes a currentUserId field. 
        /// </remarks>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="connectBlueskyCredentialsRequest"></param>
        /// <returns>ApiResponse of ConnectBlueskyCredentials200Response</returns>
        ApiResponse<ConnectBlueskyCredentials200Response> ConnectBlueskyCredentialsWithHttpInfo(ConnectBlueskyCredentialsRequest connectBlueskyCredentialsRequest);
        /// <summary>
        /// Get OAuth connect URL
        /// </summary>
        /// <remarks>
        /// Initiate an OAuth connection flow for any supported platform. Standard flow: call this endpoint, redirect user to the returned authUrl, Late hosts the selection UI, then redirects to your redirect_url. Headless mode (Facebook, LinkedIn, Pinterest, Google Business, Snapchat): add headless&#x3D;true to this endpoint. After OAuth, the user is redirected to your redirect_url with OAuth data (profileId, tempToken, userProfile, connect_token, platform, step). Use the platform-specific selection endpoints to fetch options and save the selection. LinkedIn uses pendingDataToken instead of tempToken; call GET /v1/connect/pending-data?token&#x3D;TOKEN to retrieve OAuth data (one-time use, expires in 10 minutes). 
        /// </remarks>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="platform">Social media platform to connect</param>
        /// <param name="profileId">Your Late profile ID (get from /v1/profiles)</param>
        /// <param name="redirectUrl">Your custom redirect URL after connection completes. Standard mode: Late redirects here with ?connected&#x3D;{platform}&amp;profileId&#x3D;X&amp;username&#x3D;Y. Headless mode: pass headless&#x3D;true on this endpoint. User is redirected to your URL with OAuth data (profileId, tempToken, userProfile, connect_token, platform, step). See endpoint description for details.  (optional)</param>
        /// <returns>GetConnectUrl200Response</returns>
        GetConnectUrl200Response GetConnectUrl(string platform, string profileId, string? redirectUrl = default);

        /// <summary>
        /// Get OAuth connect URL
        /// </summary>
        /// <remarks>
        /// Initiate an OAuth connection flow for any supported platform. Standard flow: call this endpoint, redirect user to the returned authUrl, Late hosts the selection UI, then redirects to your redirect_url. Headless mode (Facebook, LinkedIn, Pinterest, Google Business, Snapchat): add headless&#x3D;true to this endpoint. After OAuth, the user is redirected to your redirect_url with OAuth data (profileId, tempToken, userProfile, connect_token, platform, step). Use the platform-specific selection endpoints to fetch options and save the selection. LinkedIn uses pendingDataToken instead of tempToken; call GET /v1/connect/pending-data?token&#x3D;TOKEN to retrieve OAuth data (one-time use, expires in 10 minutes). 
        /// </remarks>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="platform">Social media platform to connect</param>
        /// <param name="profileId">Your Late profile ID (get from /v1/profiles)</param>
        /// <param name="redirectUrl">Your custom redirect URL after connection completes. Standard mode: Late redirects here with ?connected&#x3D;{platform}&amp;profileId&#x3D;X&amp;username&#x3D;Y. Headless mode: pass headless&#x3D;true on this endpoint. User is redirected to your URL with OAuth data (profileId, tempToken, userProfile, connect_token, platform, step). See endpoint description for details.  (optional)</param>
        /// <returns>ApiResponse of GetConnectUrl200Response</returns>
        ApiResponse<GetConnectUrl200Response> GetConnectUrlWithHttpInfo(string platform, string profileId, string? redirectUrl = default);
        /// <summary>
        /// List Facebook pages
        /// </summary>
        /// <remarks>
        /// Returns all Facebook pages the connected account has access to, including the currently selected page.
        /// </remarks>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="accountId"></param>
        /// <returns>GetFacebookPages200Response</returns>
        GetFacebookPages200Response GetFacebookPages(string accountId);

        /// <summary>
        /// List Facebook pages
        /// </summary>
        /// <remarks>
        /// Returns all Facebook pages the connected account has access to, including the currently selected page.
        /// </remarks>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="accountId"></param>
        /// <returns>ApiResponse of GetFacebookPages200Response</returns>
        ApiResponse<GetFacebookPages200Response> GetFacebookPagesWithHttpInfo(string accountId);
        /// <summary>
        /// List GBP locations
        /// </summary>
        /// <remarks>
        /// Returns all Google Business Profile locations the connected account has access to, including the currently selected location.
        /// </remarks>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="accountId"></param>
        /// <returns>GetGmbLocations200Response</returns>
        GetGmbLocations200Response GetGmbLocations(string accountId);

        /// <summary>
        /// List GBP locations
        /// </summary>
        /// <remarks>
        /// Returns all Google Business Profile locations the connected account has access to, including the currently selected location.
        /// </remarks>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="accountId"></param>
        /// <returns>ApiResponse of GetGmbLocations200Response</returns>
        ApiResponse<GetGmbLocations200Response> GetGmbLocationsWithHttpInfo(string accountId);
        /// <summary>
        /// List LinkedIn orgs
        /// </summary>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="accountId"></param>
        /// <returns>GetLinkedInOrganizations200Response</returns>
        GetLinkedInOrganizations200Response GetLinkedInOrganizations(string accountId);

        /// <summary>
        /// List LinkedIn orgs
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="accountId"></param>
        /// <returns>ApiResponse of GetLinkedInOrganizations200Response</returns>
        ApiResponse<GetLinkedInOrganizations200Response> GetLinkedInOrganizationsWithHttpInfo(string accountId);
        /// <summary>
        /// Get pending OAuth data
        /// </summary>
        /// <remarks>
        /// Fetch pending OAuth data for headless mode. Platforms like LinkedIn store OAuth selection data (organizations, pages, etc.) server-side to prevent URI_TOO_LONG errors. After OAuth redirect, use the pendingDataToken from the URL to fetch the stored data. This endpoint is one-time use (data is deleted after fetch) and expires after 10 minutes. No authentication required, just the token. 
        /// </remarks>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="token">The pending data token from the OAuth redirect URL (pendingDataToken parameter)</param>
        /// <returns>GetPendingOAuthData200Response</returns>
        GetPendingOAuthData200Response GetPendingOAuthData(string token);

        /// <summary>
        /// Get pending OAuth data
        /// </summary>
        /// <remarks>
        /// Fetch pending OAuth data for headless mode. Platforms like LinkedIn store OAuth selection data (organizations, pages, etc.) server-side to prevent URI_TOO_LONG errors. After OAuth redirect, use the pendingDataToken from the URL to fetch the stored data. This endpoint is one-time use (data is deleted after fetch) and expires after 10 minutes. No authentication required, just the token. 
        /// </remarks>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="token">The pending data token from the OAuth redirect URL (pendingDataToken parameter)</param>
        /// <returns>ApiResponse of GetPendingOAuthData200Response</returns>
        ApiResponse<GetPendingOAuthData200Response> GetPendingOAuthDataWithHttpInfo(string token);
        /// <summary>
        /// List Pinterest boards
        /// </summary>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="accountId"></param>
        /// <returns>GetPinterestBoards200Response</returns>
        GetPinterestBoards200Response GetPinterestBoards(string accountId);

        /// <summary>
        /// List Pinterest boards
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="accountId"></param>
        /// <returns>ApiResponse of GetPinterestBoards200Response</returns>
        ApiResponse<GetPinterestBoards200Response> GetPinterestBoardsWithHttpInfo(string accountId);
        /// <summary>
        /// List subreddit flairs
        /// </summary>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="accountId"></param>
        /// <param name="subreddit">Subreddit name (without \&quot;r/\&quot; prefix) to fetch flairs for</param>
        /// <returns>GetRedditFlairs200Response</returns>
        GetRedditFlairs200Response GetRedditFlairs(string accountId, string subreddit);

        /// <summary>
        /// List subreddit flairs
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="accountId"></param>
        /// <param name="subreddit">Subreddit name (without \&quot;r/\&quot; prefix) to fetch flairs for</param>
        /// <returns>ApiResponse of GetRedditFlairs200Response</returns>
        ApiResponse<GetRedditFlairs200Response> GetRedditFlairsWithHttpInfo(string accountId, string subreddit);
        /// <summary>
        /// List Reddit subreddits
        /// </summary>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="accountId"></param>
        /// <returns>GetRedditSubreddits200Response</returns>
        GetRedditSubreddits200Response GetRedditSubreddits(string accountId);

        /// <summary>
        /// List Reddit subreddits
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="accountId"></param>
        /// <returns>ApiResponse of GetRedditSubreddits200Response</returns>
        ApiResponse<GetRedditSubreddits200Response> GetRedditSubredditsWithHttpInfo(string accountId);
        /// <summary>
        /// Generate Telegram code
        /// </summary>
        /// <remarks>
        /// Generate a unique access code for connecting a Telegram channel or group. Flow: get an access code (valid 15 minutes), add the bot as admin in your channel/group, open a private chat with the bot, send the code + @yourchannel (e.g. LATE-ABC123 @mychannel), then poll PATCH /v1/connect/telegram?code&#x3D;{CODE} to check connection status. For private channels without a public username, forward any message from the channel to the bot along with the access code. 
        /// </remarks>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="profileId">The profile ID to connect the Telegram account to</param>
        /// <returns>GetTelegramConnectStatus200Response</returns>
        GetTelegramConnectStatus200Response GetTelegramConnectStatus(string profileId);

        /// <summary>
        /// Generate Telegram code
        /// </summary>
        /// <remarks>
        /// Generate a unique access code for connecting a Telegram channel or group. Flow: get an access code (valid 15 minutes), add the bot as admin in your channel/group, open a private chat with the bot, send the code + @yourchannel (e.g. LATE-ABC123 @mychannel), then poll PATCH /v1/connect/telegram?code&#x3D;{CODE} to check connection status. For private channels without a public username, forward any message from the channel to the bot along with the access code. 
        /// </remarks>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="profileId">The profile ID to connect the Telegram account to</param>
        /// <returns>ApiResponse of GetTelegramConnectStatus200Response</returns>
        ApiResponse<GetTelegramConnectStatus200Response> GetTelegramConnectStatusWithHttpInfo(string profileId);
        /// <summary>
        /// Complete OAuth callback
        /// </summary>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="platform"></param>
        /// <param name="handleOAuthCallbackRequest"></param>
        /// <returns></returns>
        void HandleOAuthCallback(string platform, HandleOAuthCallbackRequest handleOAuthCallbackRequest);

        /// <summary>
        /// Complete OAuth callback
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="platform"></param>
        /// <param name="handleOAuthCallbackRequest"></param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> HandleOAuthCallbackWithHttpInfo(string platform, HandleOAuthCallbackRequest handleOAuthCallbackRequest);
        /// <summary>
        /// Connect Telegram directly
        /// </summary>
        /// <remarks>
        /// Connect a Telegram channel/group directly using the chat ID.  This is an alternative to the access code flow for power users who know their Telegram chat ID. The bot must already be added as an administrator in the channel/group. 
        /// </remarks>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="initiateTelegramConnectRequest"></param>
        /// <returns>InitiateTelegramConnect200Response</returns>
        InitiateTelegramConnect200Response InitiateTelegramConnect(InitiateTelegramConnectRequest initiateTelegramConnectRequest);

        /// <summary>
        /// Connect Telegram directly
        /// </summary>
        /// <remarks>
        /// Connect a Telegram channel/group directly using the chat ID.  This is an alternative to the access code flow for power users who know their Telegram chat ID. The bot must already be added as an administrator in the channel/group. 
        /// </remarks>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="initiateTelegramConnectRequest"></param>
        /// <returns>ApiResponse of InitiateTelegramConnect200Response</returns>
        ApiResponse<InitiateTelegramConnect200Response> InitiateTelegramConnectWithHttpInfo(InitiateTelegramConnectRequest initiateTelegramConnectRequest);
        /// <summary>
        /// List Facebook pages
        /// </summary>
        /// <remarks>
        /// Returns the list of Facebook Pages the user can manage after OAuth. Extract tempToken and userProfile from the OAuth redirect params and pass them here. Use the X-Connect-Token header if connecting via API key.
        /// </remarks>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="profileId">Profile ID from your connection flow</param>
        /// <param name="tempToken">Temporary Facebook access token from the OAuth callback redirect</param>
        /// <returns>ListFacebookPages200Response</returns>
        ListFacebookPages200Response ListFacebookPages(string profileId, string tempToken);

        /// <summary>
        /// List Facebook pages
        /// </summary>
        /// <remarks>
        /// Returns the list of Facebook Pages the user can manage after OAuth. Extract tempToken and userProfile from the OAuth redirect params and pass them here. Use the X-Connect-Token header if connecting via API key.
        /// </remarks>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="profileId">Profile ID from your connection flow</param>
        /// <param name="tempToken">Temporary Facebook access token from the OAuth callback redirect</param>
        /// <returns>ApiResponse of ListFacebookPages200Response</returns>
        ApiResponse<ListFacebookPages200Response> ListFacebookPagesWithHttpInfo(string profileId, string tempToken);
        /// <summary>
        /// List GBP locations
        /// </summary>
        /// <remarks>
        /// For headless/whitelabel flows. After Google Business OAuth with headless&#x3D;true, you&#39;ll be redirected to your redirect_url with tempToken and userProfile params. Call this endpoint to retrieve the list of locations the user can manage, then build your own UI to let them select one. Use the X-Connect-Token header if you initiated the connection via API key. 
        /// </remarks>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="profileId">Profile ID from your connection flow</param>
        /// <param name="tempToken">Temporary Google access token from the OAuth callback redirect</param>
        /// <returns>ListGoogleBusinessLocations200Response</returns>
        ListGoogleBusinessLocations200Response ListGoogleBusinessLocations(string profileId, string tempToken);

        /// <summary>
        /// List GBP locations
        /// </summary>
        /// <remarks>
        /// For headless/whitelabel flows. After Google Business OAuth with headless&#x3D;true, you&#39;ll be redirected to your redirect_url with tempToken and userProfile params. Call this endpoint to retrieve the list of locations the user can manage, then build your own UI to let them select one. Use the X-Connect-Token header if you initiated the connection via API key. 
        /// </remarks>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="profileId">Profile ID from your connection flow</param>
        /// <param name="tempToken">Temporary Google access token from the OAuth callback redirect</param>
        /// <returns>ApiResponse of ListGoogleBusinessLocations200Response</returns>
        ApiResponse<ListGoogleBusinessLocations200Response> ListGoogleBusinessLocationsWithHttpInfo(string profileId, string tempToken);
        /// <summary>
        /// List LinkedIn orgs
        /// </summary>
        /// <remarks>
        /// Fetch full organization details for custom UI. After LinkedIn OAuth in headless mode, the redirect URL only contains id, urn, and name fields. Use this endpoint to fetch full details including logos, vanity names, websites, and more. No authentication required, just the tempToken from the OAuth redirect. 
        /// </remarks>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="tempToken">The temporary LinkedIn access token from the OAuth redirect</param>
        /// <param name="orgIds">Comma-separated list of organization IDs to fetch details for (max 100)</param>
        /// <returns>ListLinkedInOrganizations200Response</returns>
        ListLinkedInOrganizations200Response ListLinkedInOrganizations(string tempToken, string orgIds);

        /// <summary>
        /// List LinkedIn orgs
        /// </summary>
        /// <remarks>
        /// Fetch full organization details for custom UI. After LinkedIn OAuth in headless mode, the redirect URL only contains id, urn, and name fields. Use this endpoint to fetch full details including logos, vanity names, websites, and more. No authentication required, just the tempToken from the OAuth redirect. 
        /// </remarks>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="tempToken">The temporary LinkedIn access token from the OAuth redirect</param>
        /// <param name="orgIds">Comma-separated list of organization IDs to fetch details for (max 100)</param>
        /// <returns>ApiResponse of ListLinkedInOrganizations200Response</returns>
        ApiResponse<ListLinkedInOrganizations200Response> ListLinkedInOrganizationsWithHttpInfo(string tempToken, string orgIds);
        /// <summary>
        /// List Pinterest boards
        /// </summary>
        /// <remarks>
        /// Retrieve Pinterest boards for headless selection UI. After Pinterest OAuth with headless&#x3D;true, you&#39;ll be redirected to your redirect_url with tempToken and userProfile params. Call this endpoint to retrieve the list of boards the user can post to, then build your UI and call POST /v1/connect/pinterest/select-board to save the selection. Use X-Connect-Token header with the connect_token from the redirect URL. 
        /// </remarks>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="xConnectToken">Short-lived connect token from the OAuth redirect</param>
        /// <param name="profileId">Your Late profile ID</param>
        /// <param name="tempToken">Temporary Pinterest access token from the OAuth callback redirect</param>
        /// <returns>ListPinterestBoardsForSelection200Response</returns>
        ListPinterestBoardsForSelection200Response ListPinterestBoardsForSelection(string xConnectToken, string profileId, string tempToken);

        /// <summary>
        /// List Pinterest boards
        /// </summary>
        /// <remarks>
        /// Retrieve Pinterest boards for headless selection UI. After Pinterest OAuth with headless&#x3D;true, you&#39;ll be redirected to your redirect_url with tempToken and userProfile params. Call this endpoint to retrieve the list of boards the user can post to, then build your UI and call POST /v1/connect/pinterest/select-board to save the selection. Use X-Connect-Token header with the connect_token from the redirect URL. 
        /// </remarks>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="xConnectToken">Short-lived connect token from the OAuth redirect</param>
        /// <param name="profileId">Your Late profile ID</param>
        /// <param name="tempToken">Temporary Pinterest access token from the OAuth callback redirect</param>
        /// <returns>ApiResponse of ListPinterestBoardsForSelection200Response</returns>
        ApiResponse<ListPinterestBoardsForSelection200Response> ListPinterestBoardsForSelectionWithHttpInfo(string xConnectToken, string profileId, string tempToken);
        /// <summary>
        /// List Snapchat profiles
        /// </summary>
        /// <remarks>
        /// For headless/whitelabel flows. After Snapchat OAuth with headless&#x3D;true, you&#39;ll be redirected to your redirect_url with tempToken, userProfile, and publicProfiles params. Call this endpoint to retrieve the list of Snapchat Public Profiles the user can post to, then build your UI and call POST /v1/connect/snapchat/select-profile to save the selection. Use X-Connect-Token header with the connect_token from the redirect URL. 
        /// </remarks>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="xConnectToken">Short-lived connect token from the OAuth redirect</param>
        /// <param name="profileId">Your Late profile ID</param>
        /// <param name="tempToken">Temporary Snapchat access token from the OAuth callback redirect</param>
        /// <returns>ListSnapchatProfiles200Response</returns>
        ListSnapchatProfiles200Response ListSnapchatProfiles(string xConnectToken, string profileId, string tempToken);

        /// <summary>
        /// List Snapchat profiles
        /// </summary>
        /// <remarks>
        /// For headless/whitelabel flows. After Snapchat OAuth with headless&#x3D;true, you&#39;ll be redirected to your redirect_url with tempToken, userProfile, and publicProfiles params. Call this endpoint to retrieve the list of Snapchat Public Profiles the user can post to, then build your UI and call POST /v1/connect/snapchat/select-profile to save the selection. Use X-Connect-Token header with the connect_token from the redirect URL. 
        /// </remarks>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="xConnectToken">Short-lived connect token from the OAuth redirect</param>
        /// <param name="profileId">Your Late profile ID</param>
        /// <param name="tempToken">Temporary Snapchat access token from the OAuth callback redirect</param>
        /// <returns>ApiResponse of ListSnapchatProfiles200Response</returns>
        ApiResponse<ListSnapchatProfiles200Response> ListSnapchatProfilesWithHttpInfo(string xConnectToken, string profileId, string tempToken);
        /// <summary>
        /// Select Facebook page
        /// </summary>
        /// <remarks>
        /// Complete the headless flow. After displaying your custom UI with the list of pages from the GET endpoint, call this endpoint to finalize the connection with the user&#39;s selected page. The userProfile should be the decoded JSON object from the userProfile query param in the OAuth callback redirect URL. Use the X-Connect-Token header if you initiated the connection via API key. 
        /// </remarks>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="selectFacebookPageRequest"></param>
        /// <returns>SelectFacebookPage200Response</returns>
        SelectFacebookPage200Response SelectFacebookPage(SelectFacebookPageRequest selectFacebookPageRequest);

        /// <summary>
        /// Select Facebook page
        /// </summary>
        /// <remarks>
        /// Complete the headless flow. After displaying your custom UI with the list of pages from the GET endpoint, call this endpoint to finalize the connection with the user&#39;s selected page. The userProfile should be the decoded JSON object from the userProfile query param in the OAuth callback redirect URL. Use the X-Connect-Token header if you initiated the connection via API key. 
        /// </remarks>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="selectFacebookPageRequest"></param>
        /// <returns>ApiResponse of SelectFacebookPage200Response</returns>
        ApiResponse<SelectFacebookPage200Response> SelectFacebookPageWithHttpInfo(SelectFacebookPageRequest selectFacebookPageRequest);
        /// <summary>
        /// Select GBP location
        /// </summary>
        /// <remarks>
        /// Complete the headless flow. After displaying your custom UI with the list of locations from the GET /v1/connect/googlebusiness/locations endpoint, call this endpoint to finalize the connection with the user&#39;s selected location. The userProfile should be the decoded JSON object from the userProfile query param in the OAuth callback redirect URL. It contains important token information including the refresh token. Use the X-Connect-Token header if you initiated the connection via API key. 
        /// </remarks>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="selectGoogleBusinessLocationRequest"></param>
        /// <returns>SelectGoogleBusinessLocation200Response</returns>
        SelectGoogleBusinessLocation200Response SelectGoogleBusinessLocation(SelectGoogleBusinessLocationRequest selectGoogleBusinessLocationRequest);

        /// <summary>
        /// Select GBP location
        /// </summary>
        /// <remarks>
        /// Complete the headless flow. After displaying your custom UI with the list of locations from the GET /v1/connect/googlebusiness/locations endpoint, call this endpoint to finalize the connection with the user&#39;s selected location. The userProfile should be the decoded JSON object from the userProfile query param in the OAuth callback redirect URL. It contains important token information including the refresh token. Use the X-Connect-Token header if you initiated the connection via API key. 
        /// </remarks>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="selectGoogleBusinessLocationRequest"></param>
        /// <returns>ApiResponse of SelectGoogleBusinessLocation200Response</returns>
        ApiResponse<SelectGoogleBusinessLocation200Response> SelectGoogleBusinessLocationWithHttpInfo(SelectGoogleBusinessLocationRequest selectGoogleBusinessLocationRequest);
        /// <summary>
        /// Select LinkedIn org
        /// </summary>
        /// <remarks>
        /// Complete the LinkedIn connection flow. After OAuth, the user is redirected with organizations in the URL params (if they have org admin access). Use this data to build your UI, then call this endpoint to save the selection. Set accountType to \&quot;personal\&quot; for a personal profile (omit selectedOrganization), or \&quot;organization\&quot; to connect as a company page. Use the X-Connect-Token header if you initiated the connection via API key. 
        /// </remarks>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="selectLinkedInOrganizationRequest"></param>
        /// <returns>SelectLinkedInOrganization200Response</returns>
        SelectLinkedInOrganization200Response SelectLinkedInOrganization(SelectLinkedInOrganizationRequest selectLinkedInOrganizationRequest);

        /// <summary>
        /// Select LinkedIn org
        /// </summary>
        /// <remarks>
        /// Complete the LinkedIn connection flow. After OAuth, the user is redirected with organizations in the URL params (if they have org admin access). Use this data to build your UI, then call this endpoint to save the selection. Set accountType to \&quot;personal\&quot; for a personal profile (omit selectedOrganization), or \&quot;organization\&quot; to connect as a company page. Use the X-Connect-Token header if you initiated the connection via API key. 
        /// </remarks>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="selectLinkedInOrganizationRequest"></param>
        /// <returns>ApiResponse of SelectLinkedInOrganization200Response</returns>
        ApiResponse<SelectLinkedInOrganization200Response> SelectLinkedInOrganizationWithHttpInfo(SelectLinkedInOrganizationRequest selectLinkedInOrganizationRequest);
        /// <summary>
        /// Select Pinterest board
        /// </summary>
        /// <remarks>
        /// Complete the Pinterest connection flow. After OAuth, use this endpoint to save the selected board and complete the account connection. Use the X-Connect-Token header if you initiated the connection via API key. 
        /// </remarks>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="selectPinterestBoardRequest"></param>
        /// <returns>SelectPinterestBoard200Response</returns>
        SelectPinterestBoard200Response SelectPinterestBoard(SelectPinterestBoardRequest selectPinterestBoardRequest);

        /// <summary>
        /// Select Pinterest board
        /// </summary>
        /// <remarks>
        /// Complete the Pinterest connection flow. After OAuth, use this endpoint to save the selected board and complete the account connection. Use the X-Connect-Token header if you initiated the connection via API key. 
        /// </remarks>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="selectPinterestBoardRequest"></param>
        /// <returns>ApiResponse of SelectPinterestBoard200Response</returns>
        ApiResponse<SelectPinterestBoard200Response> SelectPinterestBoardWithHttpInfo(SelectPinterestBoardRequest selectPinterestBoardRequest);
        /// <summary>
        /// Select Snapchat profile
        /// </summary>
        /// <remarks>
        /// Complete the Snapchat connection flow. Save the selected Public Profile and complete the account connection. Snapchat requires a Public Profile to publish Stories, Saved Stories, and Spotlight content. After Snapchat OAuth with headless&#x3D;true, you&#39;ll be redirected with tempToken, userProfile, publicProfiles, connect_token, platform&#x3D;snapchat, and step&#x3D;select_public_profile in the URL. Parse publicProfiles to build your custom selector UI, then call this endpoint with the selected profile. Use the X-Connect-Token header if you initiated the connection via API key. 
        /// </remarks>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="selectSnapchatProfileRequest"></param>
        /// <param name="xConnectToken">Short-lived connect token from the OAuth redirect (for API users) (optional)</param>
        /// <returns>SelectSnapchatProfile200Response</returns>
        SelectSnapchatProfile200Response SelectSnapchatProfile(SelectSnapchatProfileRequest selectSnapchatProfileRequest, string? xConnectToken = default);

        /// <summary>
        /// Select Snapchat profile
        /// </summary>
        /// <remarks>
        /// Complete the Snapchat connection flow. Save the selected Public Profile and complete the account connection. Snapchat requires a Public Profile to publish Stories, Saved Stories, and Spotlight content. After Snapchat OAuth with headless&#x3D;true, you&#39;ll be redirected with tempToken, userProfile, publicProfiles, connect_token, platform&#x3D;snapchat, and step&#x3D;select_public_profile in the URL. Parse publicProfiles to build your custom selector UI, then call this endpoint with the selected profile. Use the X-Connect-Token header if you initiated the connection via API key. 
        /// </remarks>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="selectSnapchatProfileRequest"></param>
        /// <param name="xConnectToken">Short-lived connect token from the OAuth redirect (for API users) (optional)</param>
        /// <returns>ApiResponse of SelectSnapchatProfile200Response</returns>
        ApiResponse<SelectSnapchatProfile200Response> SelectSnapchatProfileWithHttpInfo(SelectSnapchatProfileRequest selectSnapchatProfileRequest, string? xConnectToken = default);
        /// <summary>
        /// Update Facebook page
        /// </summary>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="accountId"></param>
        /// <param name="updateFacebookPageRequest"></param>
        /// <returns>UpdateFacebookPage200Response</returns>
        UpdateFacebookPage200Response UpdateFacebookPage(string accountId, UpdateFacebookPageRequest updateFacebookPageRequest);

        /// <summary>
        /// Update Facebook page
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="accountId"></param>
        /// <param name="updateFacebookPageRequest"></param>
        /// <returns>ApiResponse of UpdateFacebookPage200Response</returns>
        ApiResponse<UpdateFacebookPage200Response> UpdateFacebookPageWithHttpInfo(string accountId, UpdateFacebookPageRequest updateFacebookPageRequest);
        /// <summary>
        /// Update GBP location
        /// </summary>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="accountId"></param>
        /// <param name="updateGmbLocationRequest"></param>
        /// <returns>UpdateGmbLocation200Response</returns>
        UpdateGmbLocation200Response UpdateGmbLocation(string accountId, UpdateGmbLocationRequest updateGmbLocationRequest);

        /// <summary>
        /// Update GBP location
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="accountId"></param>
        /// <param name="updateGmbLocationRequest"></param>
        /// <returns>ApiResponse of UpdateGmbLocation200Response</returns>
        ApiResponse<UpdateGmbLocation200Response> UpdateGmbLocationWithHttpInfo(string accountId, UpdateGmbLocationRequest updateGmbLocationRequest);
        /// <summary>
        /// Switch LinkedIn account type
        /// </summary>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="accountId"></param>
        /// <param name="updateLinkedInOrganizationRequest"></param>
        /// <returns>ConnectBlueskyCredentials200Response</returns>
        ConnectBlueskyCredentials200Response UpdateLinkedInOrganization(string accountId, UpdateLinkedInOrganizationRequest updateLinkedInOrganizationRequest);

        /// <summary>
        /// Switch LinkedIn account type
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="accountId"></param>
        /// <param name="updateLinkedInOrganizationRequest"></param>
        /// <returns>ApiResponse of ConnectBlueskyCredentials200Response</returns>
        ApiResponse<ConnectBlueskyCredentials200Response> UpdateLinkedInOrganizationWithHttpInfo(string accountId, UpdateLinkedInOrganizationRequest updateLinkedInOrganizationRequest);
        /// <summary>
        /// Set default Pinterest board
        /// </summary>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="accountId"></param>
        /// <param name="updatePinterestBoardsRequest"></param>
        /// <returns>ConnectBlueskyCredentials200Response</returns>
        ConnectBlueskyCredentials200Response UpdatePinterestBoards(string accountId, UpdatePinterestBoardsRequest updatePinterestBoardsRequest);

        /// <summary>
        /// Set default Pinterest board
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="accountId"></param>
        /// <param name="updatePinterestBoardsRequest"></param>
        /// <returns>ApiResponse of ConnectBlueskyCredentials200Response</returns>
        ApiResponse<ConnectBlueskyCredentials200Response> UpdatePinterestBoardsWithHttpInfo(string accountId, UpdatePinterestBoardsRequest updatePinterestBoardsRequest);
        /// <summary>
        /// Set default subreddit
        /// </summary>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="accountId"></param>
        /// <param name="updateRedditSubredditsRequest"></param>
        /// <returns>UpdateRedditSubreddits200Response</returns>
        UpdateRedditSubreddits200Response UpdateRedditSubreddits(string accountId, UpdateRedditSubredditsRequest updateRedditSubredditsRequest);

        /// <summary>
        /// Set default subreddit
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="accountId"></param>
        /// <param name="updateRedditSubredditsRequest"></param>
        /// <returns>ApiResponse of UpdateRedditSubreddits200Response</returns>
        ApiResponse<UpdateRedditSubreddits200Response> UpdateRedditSubredditsWithHttpInfo(string accountId, UpdateRedditSubredditsRequest updateRedditSubredditsRequest);
        #endregion Synchronous Operations
    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public interface IConnectApiAsync : IApiAccessor
    {
        #region Asynchronous Operations
        /// <summary>
        /// Check Telegram status
        /// </summary>
        /// <remarks>
        /// Poll this endpoint to check if a Telegram access code has been used to connect a channel/group. Recommended polling interval: 3 seconds. Status values: pending (waiting for user), connected (channel/group linked), expired (generate a new code). 
        /// </remarks>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="code">The access code to check status for</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of CompleteTelegramConnect200Response</returns>
        System.Threading.Tasks.Task<CompleteTelegramConnect200Response> CompleteTelegramConnectAsync(string code, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Check Telegram status
        /// </summary>
        /// <remarks>
        /// Poll this endpoint to check if a Telegram access code has been used to connect a channel/group. Recommended polling interval: 3 seconds. Status values: pending (waiting for user), connected (channel/group linked), expired (generate a new code). 
        /// </remarks>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="code">The access code to check status for</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (CompleteTelegramConnect200Response)</returns>
        System.Threading.Tasks.Task<ApiResponse<CompleteTelegramConnect200Response>> CompleteTelegramConnectWithHttpInfoAsync(string code, System.Threading.CancellationToken cancellationToken = default);
        /// <summary>
        /// Connect Bluesky account
        /// </summary>
        /// <remarks>
        /// Connect a Bluesky account using identifier (handle or email) and an app password. To get your userId for the state parameter, call GET /v1/users which includes a currentUserId field. 
        /// </remarks>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="connectBlueskyCredentialsRequest"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ConnectBlueskyCredentials200Response</returns>
        System.Threading.Tasks.Task<ConnectBlueskyCredentials200Response> ConnectBlueskyCredentialsAsync(ConnectBlueskyCredentialsRequest connectBlueskyCredentialsRequest, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Connect Bluesky account
        /// </summary>
        /// <remarks>
        /// Connect a Bluesky account using identifier (handle or email) and an app password. To get your userId for the state parameter, call GET /v1/users which includes a currentUserId field. 
        /// </remarks>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="connectBlueskyCredentialsRequest"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (ConnectBlueskyCredentials200Response)</returns>
        System.Threading.Tasks.Task<ApiResponse<ConnectBlueskyCredentials200Response>> ConnectBlueskyCredentialsWithHttpInfoAsync(ConnectBlueskyCredentialsRequest connectBlueskyCredentialsRequest, System.Threading.CancellationToken cancellationToken = default);
        /// <summary>
        /// Get OAuth connect URL
        /// </summary>
        /// <remarks>
        /// Initiate an OAuth connection flow for any supported platform. Standard flow: call this endpoint, redirect user to the returned authUrl, Late hosts the selection UI, then redirects to your redirect_url. Headless mode (Facebook, LinkedIn, Pinterest, Google Business, Snapchat): add headless&#x3D;true to this endpoint. After OAuth, the user is redirected to your redirect_url with OAuth data (profileId, tempToken, userProfile, connect_token, platform, step). Use the platform-specific selection endpoints to fetch options and save the selection. LinkedIn uses pendingDataToken instead of tempToken; call GET /v1/connect/pending-data?token&#x3D;TOKEN to retrieve OAuth data (one-time use, expires in 10 minutes). 
        /// </remarks>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="platform">Social media platform to connect</param>
        /// <param name="profileId">Your Late profile ID (get from /v1/profiles)</param>
        /// <param name="redirectUrl">Your custom redirect URL after connection completes. Standard mode: Late redirects here with ?connected&#x3D;{platform}&amp;profileId&#x3D;X&amp;username&#x3D;Y. Headless mode: pass headless&#x3D;true on this endpoint. User is redirected to your URL with OAuth data (profileId, tempToken, userProfile, connect_token, platform, step). See endpoint description for details.  (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of GetConnectUrl200Response</returns>
        System.Threading.Tasks.Task<GetConnectUrl200Response> GetConnectUrlAsync(string platform, string profileId, string? redirectUrl = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Get OAuth connect URL
        /// </summary>
        /// <remarks>
        /// Initiate an OAuth connection flow for any supported platform. Standard flow: call this endpoint, redirect user to the returned authUrl, Late hosts the selection UI, then redirects to your redirect_url. Headless mode (Facebook, LinkedIn, Pinterest, Google Business, Snapchat): add headless&#x3D;true to this endpoint. After OAuth, the user is redirected to your redirect_url with OAuth data (profileId, tempToken, userProfile, connect_token, platform, step). Use the platform-specific selection endpoints to fetch options and save the selection. LinkedIn uses pendingDataToken instead of tempToken; call GET /v1/connect/pending-data?token&#x3D;TOKEN to retrieve OAuth data (one-time use, expires in 10 minutes). 
        /// </remarks>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="platform">Social media platform to connect</param>
        /// <param name="profileId">Your Late profile ID (get from /v1/profiles)</param>
        /// <param name="redirectUrl">Your custom redirect URL after connection completes. Standard mode: Late redirects here with ?connected&#x3D;{platform}&amp;profileId&#x3D;X&amp;username&#x3D;Y. Headless mode: pass headless&#x3D;true on this endpoint. User is redirected to your URL with OAuth data (profileId, tempToken, userProfile, connect_token, platform, step). See endpoint description for details.  (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (GetConnectUrl200Response)</returns>
        System.Threading.Tasks.Task<ApiResponse<GetConnectUrl200Response>> GetConnectUrlWithHttpInfoAsync(string platform, string profileId, string? redirectUrl = default, System.Threading.CancellationToken cancellationToken = default);
        /// <summary>
        /// List Facebook pages
        /// </summary>
        /// <remarks>
        /// Returns all Facebook pages the connected account has access to, including the currently selected page.
        /// </remarks>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="accountId"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of GetFacebookPages200Response</returns>
        System.Threading.Tasks.Task<GetFacebookPages200Response> GetFacebookPagesAsync(string accountId, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// List Facebook pages
        /// </summary>
        /// <remarks>
        /// Returns all Facebook pages the connected account has access to, including the currently selected page.
        /// </remarks>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="accountId"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (GetFacebookPages200Response)</returns>
        System.Threading.Tasks.Task<ApiResponse<GetFacebookPages200Response>> GetFacebookPagesWithHttpInfoAsync(string accountId, System.Threading.CancellationToken cancellationToken = default);
        /// <summary>
        /// List GBP locations
        /// </summary>
        /// <remarks>
        /// Returns all Google Business Profile locations the connected account has access to, including the currently selected location.
        /// </remarks>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="accountId"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of GetGmbLocations200Response</returns>
        System.Threading.Tasks.Task<GetGmbLocations200Response> GetGmbLocationsAsync(string accountId, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// List GBP locations
        /// </summary>
        /// <remarks>
        /// Returns all Google Business Profile locations the connected account has access to, including the currently selected location.
        /// </remarks>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="accountId"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (GetGmbLocations200Response)</returns>
        System.Threading.Tasks.Task<ApiResponse<GetGmbLocations200Response>> GetGmbLocationsWithHttpInfoAsync(string accountId, System.Threading.CancellationToken cancellationToken = default);
        /// <summary>
        /// List LinkedIn orgs
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="accountId"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of GetLinkedInOrganizations200Response</returns>
        System.Threading.Tasks.Task<GetLinkedInOrganizations200Response> GetLinkedInOrganizationsAsync(string accountId, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// List LinkedIn orgs
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="accountId"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (GetLinkedInOrganizations200Response)</returns>
        System.Threading.Tasks.Task<ApiResponse<GetLinkedInOrganizations200Response>> GetLinkedInOrganizationsWithHttpInfoAsync(string accountId, System.Threading.CancellationToken cancellationToken = default);
        /// <summary>
        /// Get pending OAuth data
        /// </summary>
        /// <remarks>
        /// Fetch pending OAuth data for headless mode. Platforms like LinkedIn store OAuth selection data (organizations, pages, etc.) server-side to prevent URI_TOO_LONG errors. After OAuth redirect, use the pendingDataToken from the URL to fetch the stored data. This endpoint is one-time use (data is deleted after fetch) and expires after 10 minutes. No authentication required, just the token. 
        /// </remarks>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="token">The pending data token from the OAuth redirect URL (pendingDataToken parameter)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of GetPendingOAuthData200Response</returns>
        System.Threading.Tasks.Task<GetPendingOAuthData200Response> GetPendingOAuthDataAsync(string token, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Get pending OAuth data
        /// </summary>
        /// <remarks>
        /// Fetch pending OAuth data for headless mode. Platforms like LinkedIn store OAuth selection data (organizations, pages, etc.) server-side to prevent URI_TOO_LONG errors. After OAuth redirect, use the pendingDataToken from the URL to fetch the stored data. This endpoint is one-time use (data is deleted after fetch) and expires after 10 minutes. No authentication required, just the token. 
        /// </remarks>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="token">The pending data token from the OAuth redirect URL (pendingDataToken parameter)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (GetPendingOAuthData200Response)</returns>
        System.Threading.Tasks.Task<ApiResponse<GetPendingOAuthData200Response>> GetPendingOAuthDataWithHttpInfoAsync(string token, System.Threading.CancellationToken cancellationToken = default);
        /// <summary>
        /// List Pinterest boards
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="accountId"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of GetPinterestBoards200Response</returns>
        System.Threading.Tasks.Task<GetPinterestBoards200Response> GetPinterestBoardsAsync(string accountId, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// List Pinterest boards
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="accountId"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (GetPinterestBoards200Response)</returns>
        System.Threading.Tasks.Task<ApiResponse<GetPinterestBoards200Response>> GetPinterestBoardsWithHttpInfoAsync(string accountId, System.Threading.CancellationToken cancellationToken = default);
        /// <summary>
        /// List subreddit flairs
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="accountId"></param>
        /// <param name="subreddit">Subreddit name (without \&quot;r/\&quot; prefix) to fetch flairs for</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of GetRedditFlairs200Response</returns>
        System.Threading.Tasks.Task<GetRedditFlairs200Response> GetRedditFlairsAsync(string accountId, string subreddit, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// List subreddit flairs
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="accountId"></param>
        /// <param name="subreddit">Subreddit name (without \&quot;r/\&quot; prefix) to fetch flairs for</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (GetRedditFlairs200Response)</returns>
        System.Threading.Tasks.Task<ApiResponse<GetRedditFlairs200Response>> GetRedditFlairsWithHttpInfoAsync(string accountId, string subreddit, System.Threading.CancellationToken cancellationToken = default);
        /// <summary>
        /// List Reddit subreddits
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="accountId"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of GetRedditSubreddits200Response</returns>
        System.Threading.Tasks.Task<GetRedditSubreddits200Response> GetRedditSubredditsAsync(string accountId, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// List Reddit subreddits
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="accountId"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (GetRedditSubreddits200Response)</returns>
        System.Threading.Tasks.Task<ApiResponse<GetRedditSubreddits200Response>> GetRedditSubredditsWithHttpInfoAsync(string accountId, System.Threading.CancellationToken cancellationToken = default);
        /// <summary>
        /// Generate Telegram code
        /// </summary>
        /// <remarks>
        /// Generate a unique access code for connecting a Telegram channel or group. Flow: get an access code (valid 15 minutes), add the bot as admin in your channel/group, open a private chat with the bot, send the code + @yourchannel (e.g. LATE-ABC123 @mychannel), then poll PATCH /v1/connect/telegram?code&#x3D;{CODE} to check connection status. For private channels without a public username, forward any message from the channel to the bot along with the access code. 
        /// </remarks>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="profileId">The profile ID to connect the Telegram account to</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of GetTelegramConnectStatus200Response</returns>
        System.Threading.Tasks.Task<GetTelegramConnectStatus200Response> GetTelegramConnectStatusAsync(string profileId, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Generate Telegram code
        /// </summary>
        /// <remarks>
        /// Generate a unique access code for connecting a Telegram channel or group. Flow: get an access code (valid 15 minutes), add the bot as admin in your channel/group, open a private chat with the bot, send the code + @yourchannel (e.g. LATE-ABC123 @mychannel), then poll PATCH /v1/connect/telegram?code&#x3D;{CODE} to check connection status. For private channels without a public username, forward any message from the channel to the bot along with the access code. 
        /// </remarks>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="profileId">The profile ID to connect the Telegram account to</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (GetTelegramConnectStatus200Response)</returns>
        System.Threading.Tasks.Task<ApiResponse<GetTelegramConnectStatus200Response>> GetTelegramConnectStatusWithHttpInfoAsync(string profileId, System.Threading.CancellationToken cancellationToken = default);
        /// <summary>
        /// Complete OAuth callback
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="platform"></param>
        /// <param name="handleOAuthCallbackRequest"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of void</returns>
        System.Threading.Tasks.Task HandleOAuthCallbackAsync(string platform, HandleOAuthCallbackRequest handleOAuthCallbackRequest, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Complete OAuth callback
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="platform"></param>
        /// <param name="handleOAuthCallbackRequest"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        System.Threading.Tasks.Task<ApiResponse<Object>> HandleOAuthCallbackWithHttpInfoAsync(string platform, HandleOAuthCallbackRequest handleOAuthCallbackRequest, System.Threading.CancellationToken cancellationToken = default);
        /// <summary>
        /// Connect Telegram directly
        /// </summary>
        /// <remarks>
        /// Connect a Telegram channel/group directly using the chat ID.  This is an alternative to the access code flow for power users who know their Telegram chat ID. The bot must already be added as an administrator in the channel/group. 
        /// </remarks>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="initiateTelegramConnectRequest"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of InitiateTelegramConnect200Response</returns>
        System.Threading.Tasks.Task<InitiateTelegramConnect200Response> InitiateTelegramConnectAsync(InitiateTelegramConnectRequest initiateTelegramConnectRequest, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Connect Telegram directly
        /// </summary>
        /// <remarks>
        /// Connect a Telegram channel/group directly using the chat ID.  This is an alternative to the access code flow for power users who know their Telegram chat ID. The bot must already be added as an administrator in the channel/group. 
        /// </remarks>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="initiateTelegramConnectRequest"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (InitiateTelegramConnect200Response)</returns>
        System.Threading.Tasks.Task<ApiResponse<InitiateTelegramConnect200Response>> InitiateTelegramConnectWithHttpInfoAsync(InitiateTelegramConnectRequest initiateTelegramConnectRequest, System.Threading.CancellationToken cancellationToken = default);
        /// <summary>
        /// List Facebook pages
        /// </summary>
        /// <remarks>
        /// Returns the list of Facebook Pages the user can manage after OAuth. Extract tempToken and userProfile from the OAuth redirect params and pass them here. Use the X-Connect-Token header if connecting via API key.
        /// </remarks>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="profileId">Profile ID from your connection flow</param>
        /// <param name="tempToken">Temporary Facebook access token from the OAuth callback redirect</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ListFacebookPages200Response</returns>
        System.Threading.Tasks.Task<ListFacebookPages200Response> ListFacebookPagesAsync(string profileId, string tempToken, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// List Facebook pages
        /// </summary>
        /// <remarks>
        /// Returns the list of Facebook Pages the user can manage after OAuth. Extract tempToken and userProfile from the OAuth redirect params and pass them here. Use the X-Connect-Token header if connecting via API key.
        /// </remarks>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="profileId">Profile ID from your connection flow</param>
        /// <param name="tempToken">Temporary Facebook access token from the OAuth callback redirect</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (ListFacebookPages200Response)</returns>
        System.Threading.Tasks.Task<ApiResponse<ListFacebookPages200Response>> ListFacebookPagesWithHttpInfoAsync(string profileId, string tempToken, System.Threading.CancellationToken cancellationToken = default);
        /// <summary>
        /// List GBP locations
        /// </summary>
        /// <remarks>
        /// For headless/whitelabel flows. After Google Business OAuth with headless&#x3D;true, you&#39;ll be redirected to your redirect_url with tempToken and userProfile params. Call this endpoint to retrieve the list of locations the user can manage, then build your own UI to let them select one. Use the X-Connect-Token header if you initiated the connection via API key. 
        /// </remarks>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="profileId">Profile ID from your connection flow</param>
        /// <param name="tempToken">Temporary Google access token from the OAuth callback redirect</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ListGoogleBusinessLocations200Response</returns>
        System.Threading.Tasks.Task<ListGoogleBusinessLocations200Response> ListGoogleBusinessLocationsAsync(string profileId, string tempToken, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// List GBP locations
        /// </summary>
        /// <remarks>
        /// For headless/whitelabel flows. After Google Business OAuth with headless&#x3D;true, you&#39;ll be redirected to your redirect_url with tempToken and userProfile params. Call this endpoint to retrieve the list of locations the user can manage, then build your own UI to let them select one. Use the X-Connect-Token header if you initiated the connection via API key. 
        /// </remarks>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="profileId">Profile ID from your connection flow</param>
        /// <param name="tempToken">Temporary Google access token from the OAuth callback redirect</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (ListGoogleBusinessLocations200Response)</returns>
        System.Threading.Tasks.Task<ApiResponse<ListGoogleBusinessLocations200Response>> ListGoogleBusinessLocationsWithHttpInfoAsync(string profileId, string tempToken, System.Threading.CancellationToken cancellationToken = default);
        /// <summary>
        /// List LinkedIn orgs
        /// </summary>
        /// <remarks>
        /// Fetch full organization details for custom UI. After LinkedIn OAuth in headless mode, the redirect URL only contains id, urn, and name fields. Use this endpoint to fetch full details including logos, vanity names, websites, and more. No authentication required, just the tempToken from the OAuth redirect. 
        /// </remarks>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="tempToken">The temporary LinkedIn access token from the OAuth redirect</param>
        /// <param name="orgIds">Comma-separated list of organization IDs to fetch details for (max 100)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ListLinkedInOrganizations200Response</returns>
        System.Threading.Tasks.Task<ListLinkedInOrganizations200Response> ListLinkedInOrganizationsAsync(string tempToken, string orgIds, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// List LinkedIn orgs
        /// </summary>
        /// <remarks>
        /// Fetch full organization details for custom UI. After LinkedIn OAuth in headless mode, the redirect URL only contains id, urn, and name fields. Use this endpoint to fetch full details including logos, vanity names, websites, and more. No authentication required, just the tempToken from the OAuth redirect. 
        /// </remarks>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="tempToken">The temporary LinkedIn access token from the OAuth redirect</param>
        /// <param name="orgIds">Comma-separated list of organization IDs to fetch details for (max 100)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (ListLinkedInOrganizations200Response)</returns>
        System.Threading.Tasks.Task<ApiResponse<ListLinkedInOrganizations200Response>> ListLinkedInOrganizationsWithHttpInfoAsync(string tempToken, string orgIds, System.Threading.CancellationToken cancellationToken = default);
        /// <summary>
        /// List Pinterest boards
        /// </summary>
        /// <remarks>
        /// Retrieve Pinterest boards for headless selection UI. After Pinterest OAuth with headless&#x3D;true, you&#39;ll be redirected to your redirect_url with tempToken and userProfile params. Call this endpoint to retrieve the list of boards the user can post to, then build your UI and call POST /v1/connect/pinterest/select-board to save the selection. Use X-Connect-Token header with the connect_token from the redirect URL. 
        /// </remarks>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="xConnectToken">Short-lived connect token from the OAuth redirect</param>
        /// <param name="profileId">Your Late profile ID</param>
        /// <param name="tempToken">Temporary Pinterest access token from the OAuth callback redirect</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ListPinterestBoardsForSelection200Response</returns>
        System.Threading.Tasks.Task<ListPinterestBoardsForSelection200Response> ListPinterestBoardsForSelectionAsync(string xConnectToken, string profileId, string tempToken, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// List Pinterest boards
        /// </summary>
        /// <remarks>
        /// Retrieve Pinterest boards for headless selection UI. After Pinterest OAuth with headless&#x3D;true, you&#39;ll be redirected to your redirect_url with tempToken and userProfile params. Call this endpoint to retrieve the list of boards the user can post to, then build your UI and call POST /v1/connect/pinterest/select-board to save the selection. Use X-Connect-Token header with the connect_token from the redirect URL. 
        /// </remarks>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="xConnectToken">Short-lived connect token from the OAuth redirect</param>
        /// <param name="profileId">Your Late profile ID</param>
        /// <param name="tempToken">Temporary Pinterest access token from the OAuth callback redirect</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (ListPinterestBoardsForSelection200Response)</returns>
        System.Threading.Tasks.Task<ApiResponse<ListPinterestBoardsForSelection200Response>> ListPinterestBoardsForSelectionWithHttpInfoAsync(string xConnectToken, string profileId, string tempToken, System.Threading.CancellationToken cancellationToken = default);
        /// <summary>
        /// List Snapchat profiles
        /// </summary>
        /// <remarks>
        /// For headless/whitelabel flows. After Snapchat OAuth with headless&#x3D;true, you&#39;ll be redirected to your redirect_url with tempToken, userProfile, and publicProfiles params. Call this endpoint to retrieve the list of Snapchat Public Profiles the user can post to, then build your UI and call POST /v1/connect/snapchat/select-profile to save the selection. Use X-Connect-Token header with the connect_token from the redirect URL. 
        /// </remarks>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="xConnectToken">Short-lived connect token from the OAuth redirect</param>
        /// <param name="profileId">Your Late profile ID</param>
        /// <param name="tempToken">Temporary Snapchat access token from the OAuth callback redirect</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ListSnapchatProfiles200Response</returns>
        System.Threading.Tasks.Task<ListSnapchatProfiles200Response> ListSnapchatProfilesAsync(string xConnectToken, string profileId, string tempToken, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// List Snapchat profiles
        /// </summary>
        /// <remarks>
        /// For headless/whitelabel flows. After Snapchat OAuth with headless&#x3D;true, you&#39;ll be redirected to your redirect_url with tempToken, userProfile, and publicProfiles params. Call this endpoint to retrieve the list of Snapchat Public Profiles the user can post to, then build your UI and call POST /v1/connect/snapchat/select-profile to save the selection. Use X-Connect-Token header with the connect_token from the redirect URL. 
        /// </remarks>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="xConnectToken">Short-lived connect token from the OAuth redirect</param>
        /// <param name="profileId">Your Late profile ID</param>
        /// <param name="tempToken">Temporary Snapchat access token from the OAuth callback redirect</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (ListSnapchatProfiles200Response)</returns>
        System.Threading.Tasks.Task<ApiResponse<ListSnapchatProfiles200Response>> ListSnapchatProfilesWithHttpInfoAsync(string xConnectToken, string profileId, string tempToken, System.Threading.CancellationToken cancellationToken = default);
        /// <summary>
        /// Select Facebook page
        /// </summary>
        /// <remarks>
        /// Complete the headless flow. After displaying your custom UI with the list of pages from the GET endpoint, call this endpoint to finalize the connection with the user&#39;s selected page. The userProfile should be the decoded JSON object from the userProfile query param in the OAuth callback redirect URL. Use the X-Connect-Token header if you initiated the connection via API key. 
        /// </remarks>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="selectFacebookPageRequest"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of SelectFacebookPage200Response</returns>
        System.Threading.Tasks.Task<SelectFacebookPage200Response> SelectFacebookPageAsync(SelectFacebookPageRequest selectFacebookPageRequest, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Select Facebook page
        /// </summary>
        /// <remarks>
        /// Complete the headless flow. After displaying your custom UI with the list of pages from the GET endpoint, call this endpoint to finalize the connection with the user&#39;s selected page. The userProfile should be the decoded JSON object from the userProfile query param in the OAuth callback redirect URL. Use the X-Connect-Token header if you initiated the connection via API key. 
        /// </remarks>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="selectFacebookPageRequest"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (SelectFacebookPage200Response)</returns>
        System.Threading.Tasks.Task<ApiResponse<SelectFacebookPage200Response>> SelectFacebookPageWithHttpInfoAsync(SelectFacebookPageRequest selectFacebookPageRequest, System.Threading.CancellationToken cancellationToken = default);
        /// <summary>
        /// Select GBP location
        /// </summary>
        /// <remarks>
        /// Complete the headless flow. After displaying your custom UI with the list of locations from the GET /v1/connect/googlebusiness/locations endpoint, call this endpoint to finalize the connection with the user&#39;s selected location. The userProfile should be the decoded JSON object from the userProfile query param in the OAuth callback redirect URL. It contains important token information including the refresh token. Use the X-Connect-Token header if you initiated the connection via API key. 
        /// </remarks>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="selectGoogleBusinessLocationRequest"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of SelectGoogleBusinessLocation200Response</returns>
        System.Threading.Tasks.Task<SelectGoogleBusinessLocation200Response> SelectGoogleBusinessLocationAsync(SelectGoogleBusinessLocationRequest selectGoogleBusinessLocationRequest, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Select GBP location
        /// </summary>
        /// <remarks>
        /// Complete the headless flow. After displaying your custom UI with the list of locations from the GET /v1/connect/googlebusiness/locations endpoint, call this endpoint to finalize the connection with the user&#39;s selected location. The userProfile should be the decoded JSON object from the userProfile query param in the OAuth callback redirect URL. It contains important token information including the refresh token. Use the X-Connect-Token header if you initiated the connection via API key. 
        /// </remarks>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="selectGoogleBusinessLocationRequest"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (SelectGoogleBusinessLocation200Response)</returns>
        System.Threading.Tasks.Task<ApiResponse<SelectGoogleBusinessLocation200Response>> SelectGoogleBusinessLocationWithHttpInfoAsync(SelectGoogleBusinessLocationRequest selectGoogleBusinessLocationRequest, System.Threading.CancellationToken cancellationToken = default);
        /// <summary>
        /// Select LinkedIn org
        /// </summary>
        /// <remarks>
        /// Complete the LinkedIn connection flow. After OAuth, the user is redirected with organizations in the URL params (if they have org admin access). Use this data to build your UI, then call this endpoint to save the selection. Set accountType to \&quot;personal\&quot; for a personal profile (omit selectedOrganization), or \&quot;organization\&quot; to connect as a company page. Use the X-Connect-Token header if you initiated the connection via API key. 
        /// </remarks>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="selectLinkedInOrganizationRequest"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of SelectLinkedInOrganization200Response</returns>
        System.Threading.Tasks.Task<SelectLinkedInOrganization200Response> SelectLinkedInOrganizationAsync(SelectLinkedInOrganizationRequest selectLinkedInOrganizationRequest, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Select LinkedIn org
        /// </summary>
        /// <remarks>
        /// Complete the LinkedIn connection flow. After OAuth, the user is redirected with organizations in the URL params (if they have org admin access). Use this data to build your UI, then call this endpoint to save the selection. Set accountType to \&quot;personal\&quot; for a personal profile (omit selectedOrganization), or \&quot;organization\&quot; to connect as a company page. Use the X-Connect-Token header if you initiated the connection via API key. 
        /// </remarks>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="selectLinkedInOrganizationRequest"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (SelectLinkedInOrganization200Response)</returns>
        System.Threading.Tasks.Task<ApiResponse<SelectLinkedInOrganization200Response>> SelectLinkedInOrganizationWithHttpInfoAsync(SelectLinkedInOrganizationRequest selectLinkedInOrganizationRequest, System.Threading.CancellationToken cancellationToken = default);
        /// <summary>
        /// Select Pinterest board
        /// </summary>
        /// <remarks>
        /// Complete the Pinterest connection flow. After OAuth, use this endpoint to save the selected board and complete the account connection. Use the X-Connect-Token header if you initiated the connection via API key. 
        /// </remarks>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="selectPinterestBoardRequest"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of SelectPinterestBoard200Response</returns>
        System.Threading.Tasks.Task<SelectPinterestBoard200Response> SelectPinterestBoardAsync(SelectPinterestBoardRequest selectPinterestBoardRequest, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Select Pinterest board
        /// </summary>
        /// <remarks>
        /// Complete the Pinterest connection flow. After OAuth, use this endpoint to save the selected board and complete the account connection. Use the X-Connect-Token header if you initiated the connection via API key. 
        /// </remarks>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="selectPinterestBoardRequest"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (SelectPinterestBoard200Response)</returns>
        System.Threading.Tasks.Task<ApiResponse<SelectPinterestBoard200Response>> SelectPinterestBoardWithHttpInfoAsync(SelectPinterestBoardRequest selectPinterestBoardRequest, System.Threading.CancellationToken cancellationToken = default);
        /// <summary>
        /// Select Snapchat profile
        /// </summary>
        /// <remarks>
        /// Complete the Snapchat connection flow. Save the selected Public Profile and complete the account connection. Snapchat requires a Public Profile to publish Stories, Saved Stories, and Spotlight content. After Snapchat OAuth with headless&#x3D;true, you&#39;ll be redirected with tempToken, userProfile, publicProfiles, connect_token, platform&#x3D;snapchat, and step&#x3D;select_public_profile in the URL. Parse publicProfiles to build your custom selector UI, then call this endpoint with the selected profile. Use the X-Connect-Token header if you initiated the connection via API key. 
        /// </remarks>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="selectSnapchatProfileRequest"></param>
        /// <param name="xConnectToken">Short-lived connect token from the OAuth redirect (for API users) (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of SelectSnapchatProfile200Response</returns>
        System.Threading.Tasks.Task<SelectSnapchatProfile200Response> SelectSnapchatProfileAsync(SelectSnapchatProfileRequest selectSnapchatProfileRequest, string? xConnectToken = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Select Snapchat profile
        /// </summary>
        /// <remarks>
        /// Complete the Snapchat connection flow. Save the selected Public Profile and complete the account connection. Snapchat requires a Public Profile to publish Stories, Saved Stories, and Spotlight content. After Snapchat OAuth with headless&#x3D;true, you&#39;ll be redirected with tempToken, userProfile, publicProfiles, connect_token, platform&#x3D;snapchat, and step&#x3D;select_public_profile in the URL. Parse publicProfiles to build your custom selector UI, then call this endpoint with the selected profile. Use the X-Connect-Token header if you initiated the connection via API key. 
        /// </remarks>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="selectSnapchatProfileRequest"></param>
        /// <param name="xConnectToken">Short-lived connect token from the OAuth redirect (for API users) (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (SelectSnapchatProfile200Response)</returns>
        System.Threading.Tasks.Task<ApiResponse<SelectSnapchatProfile200Response>> SelectSnapchatProfileWithHttpInfoAsync(SelectSnapchatProfileRequest selectSnapchatProfileRequest, string? xConnectToken = default, System.Threading.CancellationToken cancellationToken = default);
        /// <summary>
        /// Update Facebook page
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="accountId"></param>
        /// <param name="updateFacebookPageRequest"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of UpdateFacebookPage200Response</returns>
        System.Threading.Tasks.Task<UpdateFacebookPage200Response> UpdateFacebookPageAsync(string accountId, UpdateFacebookPageRequest updateFacebookPageRequest, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Update Facebook page
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="accountId"></param>
        /// <param name="updateFacebookPageRequest"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (UpdateFacebookPage200Response)</returns>
        System.Threading.Tasks.Task<ApiResponse<UpdateFacebookPage200Response>> UpdateFacebookPageWithHttpInfoAsync(string accountId, UpdateFacebookPageRequest updateFacebookPageRequest, System.Threading.CancellationToken cancellationToken = default);
        /// <summary>
        /// Update GBP location
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="accountId"></param>
        /// <param name="updateGmbLocationRequest"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of UpdateGmbLocation200Response</returns>
        System.Threading.Tasks.Task<UpdateGmbLocation200Response> UpdateGmbLocationAsync(string accountId, UpdateGmbLocationRequest updateGmbLocationRequest, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Update GBP location
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="accountId"></param>
        /// <param name="updateGmbLocationRequest"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (UpdateGmbLocation200Response)</returns>
        System.Threading.Tasks.Task<ApiResponse<UpdateGmbLocation200Response>> UpdateGmbLocationWithHttpInfoAsync(string accountId, UpdateGmbLocationRequest updateGmbLocationRequest, System.Threading.CancellationToken cancellationToken = default);
        /// <summary>
        /// Switch LinkedIn account type
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="accountId"></param>
        /// <param name="updateLinkedInOrganizationRequest"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ConnectBlueskyCredentials200Response</returns>
        System.Threading.Tasks.Task<ConnectBlueskyCredentials200Response> UpdateLinkedInOrganizationAsync(string accountId, UpdateLinkedInOrganizationRequest updateLinkedInOrganizationRequest, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Switch LinkedIn account type
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="accountId"></param>
        /// <param name="updateLinkedInOrganizationRequest"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (ConnectBlueskyCredentials200Response)</returns>
        System.Threading.Tasks.Task<ApiResponse<ConnectBlueskyCredentials200Response>> UpdateLinkedInOrganizationWithHttpInfoAsync(string accountId, UpdateLinkedInOrganizationRequest updateLinkedInOrganizationRequest, System.Threading.CancellationToken cancellationToken = default);
        /// <summary>
        /// Set default Pinterest board
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="accountId"></param>
        /// <param name="updatePinterestBoardsRequest"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ConnectBlueskyCredentials200Response</returns>
        System.Threading.Tasks.Task<ConnectBlueskyCredentials200Response> UpdatePinterestBoardsAsync(string accountId, UpdatePinterestBoardsRequest updatePinterestBoardsRequest, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Set default Pinterest board
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="accountId"></param>
        /// <param name="updatePinterestBoardsRequest"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (ConnectBlueskyCredentials200Response)</returns>
        System.Threading.Tasks.Task<ApiResponse<ConnectBlueskyCredentials200Response>> UpdatePinterestBoardsWithHttpInfoAsync(string accountId, UpdatePinterestBoardsRequest updatePinterestBoardsRequest, System.Threading.CancellationToken cancellationToken = default);
        /// <summary>
        /// Set default subreddit
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="accountId"></param>
        /// <param name="updateRedditSubredditsRequest"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of UpdateRedditSubreddits200Response</returns>
        System.Threading.Tasks.Task<UpdateRedditSubreddits200Response> UpdateRedditSubredditsAsync(string accountId, UpdateRedditSubredditsRequest updateRedditSubredditsRequest, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Set default subreddit
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="accountId"></param>
        /// <param name="updateRedditSubredditsRequest"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (UpdateRedditSubreddits200Response)</returns>
        System.Threading.Tasks.Task<ApiResponse<UpdateRedditSubreddits200Response>> UpdateRedditSubredditsWithHttpInfoAsync(string accountId, UpdateRedditSubredditsRequest updateRedditSubredditsRequest, System.Threading.CancellationToken cancellationToken = default);
        #endregion Asynchronous Operations
    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public interface IConnectApi : IConnectApiSync, IConnectApiAsync
    {

    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public partial class ConnectApi : IDisposable, IConnectApi
    {
        private Late.Client.ExceptionFactory _exceptionFactory = (name, response) => null;

        /// <summary>
        /// Initializes a new instance of the <see cref="ConnectApi"/> class.
        /// **IMPORTANT** This will also create an instance of HttpClient, which is less than ideal.
        /// It's better to reuse the <see href="https://docs.microsoft.com/en-us/dotnet/architecture/microservices/implement-resilient-applications/use-httpclientfactory-to-implement-resilient-http-requests#issues-with-the-original-httpclient-class-available-in-net">HttpClient and HttpClientHandler</see>.
        /// </summary>
        /// <returns></returns>
        public ConnectApi() : this((string)null)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="ConnectApi"/> class.
        /// **IMPORTANT** This will also create an instance of HttpClient, which is less than ideal.
        /// It's better to reuse the <see href="https://docs.microsoft.com/en-us/dotnet/architecture/microservices/implement-resilient-applications/use-httpclientfactory-to-implement-resilient-http-requests#issues-with-the-original-httpclient-class-available-in-net">HttpClient and HttpClientHandler</see>.
        /// </summary>
        /// <param name="basePath">The target service's base path in URL format.</param>
        /// <exception cref="ArgumentException"></exception>
        /// <returns></returns>
        public ConnectApi(string basePath)
        {
            this.Configuration = Late.Client.Configuration.MergeConfigurations(
                Late.Client.GlobalConfiguration.Instance,
                new Late.Client.Configuration { BasePath = basePath }
            );
            this.ApiClient = new Late.Client.ApiClient(this.Configuration.BasePath);
            this.Client =  this.ApiClient;
            this.AsynchronousClient = this.ApiClient;
            this.ExceptionFactory = Late.Client.Configuration.DefaultExceptionFactory;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="ConnectApi"/> class using Configuration object.
        /// **IMPORTANT** This will also create an instance of HttpClient, which is less than ideal.
        /// It's better to reuse the <see href="https://docs.microsoft.com/en-us/dotnet/architecture/microservices/implement-resilient-applications/use-httpclientfactory-to-implement-resilient-http-requests#issues-with-the-original-httpclient-class-available-in-net">HttpClient and HttpClientHandler</see>.
        /// </summary>
        /// <param name="configuration">An instance of Configuration.</param>
        /// <exception cref="ArgumentNullException"></exception>
        /// <returns></returns>
        public ConnectApi(Late.Client.Configuration configuration)
        {
            if (configuration == null) throw new ArgumentNullException("configuration");

            this.Configuration = Late.Client.Configuration.MergeConfigurations(
                Late.Client.GlobalConfiguration.Instance,
                configuration
            );
            this.ApiClient = new Late.Client.ApiClient(this.Configuration.BasePath);
            this.Client = this.ApiClient;
            this.AsynchronousClient = this.ApiClient;
            ExceptionFactory = Late.Client.Configuration.DefaultExceptionFactory;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="ConnectApi"/> class.
        /// </summary>
        /// <param name="client">An instance of HttpClient.</param>
        /// <param name="handler">An optional instance of HttpClientHandler that is used by HttpClient.</param>
        /// <exception cref="ArgumentNullException"></exception>
        /// <returns></returns>
        /// <remarks>
        /// Some configuration settings will not be applied without passing an HttpClientHandler.
        /// The features affected are: Setting and Retrieving Cookies, Client Certificates, Proxy settings.
        /// </remarks>
        public ConnectApi(HttpClient client, HttpClientHandler handler = null) : this(client, (string)null, handler)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="ConnectApi"/> class.
        /// </summary>
        /// <param name="client">An instance of HttpClient.</param>
        /// <param name="basePath">The target service's base path in URL format.</param>
        /// <param name="handler">An optional instance of HttpClientHandler that is used by HttpClient.</param>
        /// <exception cref="ArgumentNullException"></exception>
        /// <exception cref="ArgumentException"></exception>
        /// <returns></returns>
        /// <remarks>
        /// Some configuration settings will not be applied without passing an HttpClientHandler.
        /// The features affected are: Setting and Retrieving Cookies, Client Certificates, Proxy settings.
        /// </remarks>
        public ConnectApi(HttpClient client, string basePath, HttpClientHandler handler = null)
        {
            if (client == null) throw new ArgumentNullException("client");

            this.Configuration = Late.Client.Configuration.MergeConfigurations(
                Late.Client.GlobalConfiguration.Instance,
                new Late.Client.Configuration { BasePath = basePath }
            );
            this.ApiClient = new Late.Client.ApiClient(client, this.Configuration.BasePath, handler);
            this.Client =  this.ApiClient;
            this.AsynchronousClient = this.ApiClient;
            this.ExceptionFactory = Late.Client.Configuration.DefaultExceptionFactory;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="ConnectApi"/> class using Configuration object.
        /// </summary>
        /// <param name="client">An instance of HttpClient.</param>
        /// <param name="configuration">An instance of Configuration.</param>
        /// <param name="handler">An optional instance of HttpClientHandler that is used by HttpClient.</param>
        /// <exception cref="ArgumentNullException"></exception>
        /// <returns></returns>
        /// <remarks>
        /// Some configuration settings will not be applied without passing an HttpClientHandler.
        /// The features affected are: Setting and Retrieving Cookies, Client Certificates, Proxy settings.
        /// </remarks>
        public ConnectApi(HttpClient client, Late.Client.Configuration configuration, HttpClientHandler handler = null)
        {
            if (configuration == null) throw new ArgumentNullException("configuration");
            if (client == null) throw new ArgumentNullException("client");

            this.Configuration = Late.Client.Configuration.MergeConfigurations(
                Late.Client.GlobalConfiguration.Instance,
                configuration
            );
            this.ApiClient = new Late.Client.ApiClient(client, this.Configuration.BasePath, handler);
            this.Client = this.ApiClient;
            this.AsynchronousClient = this.ApiClient;
            ExceptionFactory = Late.Client.Configuration.DefaultExceptionFactory;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="ConnectApi"/> class
        /// using a Configuration object and client instance.
        /// </summary>
        /// <param name="client">The client interface for synchronous API access.</param>
        /// <param name="asyncClient">The client interface for asynchronous API access.</param>
        /// <param name="configuration">The configuration object.</param>
        /// <exception cref="ArgumentNullException"></exception>
        public ConnectApi(Late.Client.ISynchronousClient client, Late.Client.IAsynchronousClient asyncClient, Late.Client.IReadableConfiguration configuration)
        {
            if (client == null) throw new ArgumentNullException("client");
            if (asyncClient == null) throw new ArgumentNullException("asyncClient");
            if (configuration == null) throw new ArgumentNullException("configuration");

            this.Client = client;
            this.AsynchronousClient = asyncClient;
            this.Configuration = configuration;
            this.ExceptionFactory = Late.Client.Configuration.DefaultExceptionFactory;
        }

        /// <summary>
        /// Disposes resources if they were created by us
        /// </summary>
        public void Dispose()
        {
            this.ApiClient?.Dispose();
        }

        /// <summary>
        /// Holds the ApiClient if created
        /// </summary>
        public Late.Client.ApiClient ApiClient { get; set; } = null;

        /// <summary>
        /// The client for accessing this underlying API asynchronously.
        /// </summary>
        public Late.Client.IAsynchronousClient AsynchronousClient { get; set; }

        /// <summary>
        /// The client for accessing this underlying API synchronously.
        /// </summary>
        public Late.Client.ISynchronousClient Client { get; set; }

        /// <summary>
        /// Gets the base path of the API client.
        /// </summary>
        /// <value>The base path</value>
        public string GetBasePath()
        {
            return this.Configuration.BasePath;
        }

        /// <summary>
        /// Gets or sets the configuration object
        /// </summary>
        /// <value>An instance of the Configuration</value>
        public Late.Client.IReadableConfiguration Configuration { get; set; }

        /// <summary>
        /// Provides a factory method hook for the creation of exceptions.
        /// </summary>
        public Late.Client.ExceptionFactory ExceptionFactory
        {
            get
            {
                if (_exceptionFactory != null && _exceptionFactory.GetInvocationList().Length > 1)
                {
                    throw new InvalidOperationException("Multicast delegate for ExceptionFactory is unsupported.");
                }
                return _exceptionFactory;
            }
            set { _exceptionFactory = value; }
        }

        /// <summary>
        /// Check Telegram status Poll this endpoint to check if a Telegram access code has been used to connect a channel/group. Recommended polling interval: 3 seconds. Status values: pending (waiting for user), connected (channel/group linked), expired (generate a new code). 
        /// </summary>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="code">The access code to check status for</param>
        /// <returns>CompleteTelegramConnect200Response</returns>
        public CompleteTelegramConnect200Response CompleteTelegramConnect(string code)
        {
            Late.Client.ApiResponse<CompleteTelegramConnect200Response> localVarResponse = CompleteTelegramConnectWithHttpInfo(code);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Check Telegram status Poll this endpoint to check if a Telegram access code has been used to connect a channel/group. Recommended polling interval: 3 seconds. Status values: pending (waiting for user), connected (channel/group linked), expired (generate a new code). 
        /// </summary>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="code">The access code to check status for</param>
        /// <returns>ApiResponse of CompleteTelegramConnect200Response</returns>
        public Late.Client.ApiResponse<CompleteTelegramConnect200Response> CompleteTelegramConnectWithHttpInfo(string code)
        {
            // verify the required parameter 'code' is set
            if (code == null)
                throw new Late.Client.ApiException(400, "Missing required parameter 'code' when calling ConnectApi->CompleteTelegramConnect");

            Late.Client.RequestOptions localVarRequestOptions = new Late.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Late.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Late.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.QueryParameters.Add(Late.Client.ClientUtils.ParameterToMultiMap("", "code", code));

            // authentication (bearerAuth) required
            // bearer authentication required
            if (!string.IsNullOrEmpty(this.Configuration.AccessToken) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
            }

            // make the HTTP request
            var localVarResponse = this.Client.Patch<CompleteTelegramConnect200Response>("/v1/connect/telegram", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("CompleteTelegramConnect", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Check Telegram status Poll this endpoint to check if a Telegram access code has been used to connect a channel/group. Recommended polling interval: 3 seconds. Status values: pending (waiting for user), connected (channel/group linked), expired (generate a new code). 
        /// </summary>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="code">The access code to check status for</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of CompleteTelegramConnect200Response</returns>
        public async System.Threading.Tasks.Task<CompleteTelegramConnect200Response> CompleteTelegramConnectAsync(string code, System.Threading.CancellationToken cancellationToken = default)
        {
            Late.Client.ApiResponse<CompleteTelegramConnect200Response> localVarResponse = await CompleteTelegramConnectWithHttpInfoAsync(code, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Check Telegram status Poll this endpoint to check if a Telegram access code has been used to connect a channel/group. Recommended polling interval: 3 seconds. Status values: pending (waiting for user), connected (channel/group linked), expired (generate a new code). 
        /// </summary>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="code">The access code to check status for</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (CompleteTelegramConnect200Response)</returns>
        public async System.Threading.Tasks.Task<Late.Client.ApiResponse<CompleteTelegramConnect200Response>> CompleteTelegramConnectWithHttpInfoAsync(string code, System.Threading.CancellationToken cancellationToken = default)
        {
            // verify the required parameter 'code' is set
            if (code == null)
                throw new Late.Client.ApiException(400, "Missing required parameter 'code' when calling ConnectApi->CompleteTelegramConnect");


            Late.Client.RequestOptions localVarRequestOptions = new Late.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };


            var localVarContentType = Late.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Late.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.QueryParameters.Add(Late.Client.ClientUtils.ParameterToMultiMap("", "code", code));

            // authentication (bearerAuth) required
            // bearer authentication required
            if (!string.IsNullOrEmpty(this.Configuration.AccessToken) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
            }

            // make the HTTP request

            var localVarResponse = await this.AsynchronousClient.PatchAsync<CompleteTelegramConnect200Response>("/v1/connect/telegram", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("CompleteTelegramConnect", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Connect Bluesky account Connect a Bluesky account using identifier (handle or email) and an app password. To get your userId for the state parameter, call GET /v1/users which includes a currentUserId field. 
        /// </summary>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="connectBlueskyCredentialsRequest"></param>
        /// <returns>ConnectBlueskyCredentials200Response</returns>
        public ConnectBlueskyCredentials200Response ConnectBlueskyCredentials(ConnectBlueskyCredentialsRequest connectBlueskyCredentialsRequest)
        {
            Late.Client.ApiResponse<ConnectBlueskyCredentials200Response> localVarResponse = ConnectBlueskyCredentialsWithHttpInfo(connectBlueskyCredentialsRequest);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Connect Bluesky account Connect a Bluesky account using identifier (handle or email) and an app password. To get your userId for the state parameter, call GET /v1/users which includes a currentUserId field. 
        /// </summary>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="connectBlueskyCredentialsRequest"></param>
        /// <returns>ApiResponse of ConnectBlueskyCredentials200Response</returns>
        public Late.Client.ApiResponse<ConnectBlueskyCredentials200Response> ConnectBlueskyCredentialsWithHttpInfo(ConnectBlueskyCredentialsRequest connectBlueskyCredentialsRequest)
        {
            // verify the required parameter 'connectBlueskyCredentialsRequest' is set
            if (connectBlueskyCredentialsRequest == null)
                throw new Late.Client.ApiException(400, "Missing required parameter 'connectBlueskyCredentialsRequest' when calling ConnectApi->ConnectBlueskyCredentials");

            Late.Client.RequestOptions localVarRequestOptions = new Late.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Late.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Late.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.Data = connectBlueskyCredentialsRequest;

            // authentication (bearerAuth) required
            // bearer authentication required
            if (!string.IsNullOrEmpty(this.Configuration.AccessToken) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
            }

            // make the HTTP request
            var localVarResponse = this.Client.Post<ConnectBlueskyCredentials200Response>("/v1/connect/bluesky/credentials", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ConnectBlueskyCredentials", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Connect Bluesky account Connect a Bluesky account using identifier (handle or email) and an app password. To get your userId for the state parameter, call GET /v1/users which includes a currentUserId field. 
        /// </summary>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="connectBlueskyCredentialsRequest"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ConnectBlueskyCredentials200Response</returns>
        public async System.Threading.Tasks.Task<ConnectBlueskyCredentials200Response> ConnectBlueskyCredentialsAsync(ConnectBlueskyCredentialsRequest connectBlueskyCredentialsRequest, System.Threading.CancellationToken cancellationToken = default)
        {
            Late.Client.ApiResponse<ConnectBlueskyCredentials200Response> localVarResponse = await ConnectBlueskyCredentialsWithHttpInfoAsync(connectBlueskyCredentialsRequest, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Connect Bluesky account Connect a Bluesky account using identifier (handle or email) and an app password. To get your userId for the state parameter, call GET /v1/users which includes a currentUserId field. 
        /// </summary>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="connectBlueskyCredentialsRequest"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (ConnectBlueskyCredentials200Response)</returns>
        public async System.Threading.Tasks.Task<Late.Client.ApiResponse<ConnectBlueskyCredentials200Response>> ConnectBlueskyCredentialsWithHttpInfoAsync(ConnectBlueskyCredentialsRequest connectBlueskyCredentialsRequest, System.Threading.CancellationToken cancellationToken = default)
        {
            // verify the required parameter 'connectBlueskyCredentialsRequest' is set
            if (connectBlueskyCredentialsRequest == null)
                throw new Late.Client.ApiException(400, "Missing required parameter 'connectBlueskyCredentialsRequest' when calling ConnectApi->ConnectBlueskyCredentials");


            Late.Client.RequestOptions localVarRequestOptions = new Late.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };


            var localVarContentType = Late.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Late.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.Data = connectBlueskyCredentialsRequest;

            // authentication (bearerAuth) required
            // bearer authentication required
            if (!string.IsNullOrEmpty(this.Configuration.AccessToken) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
            }

            // make the HTTP request

            var localVarResponse = await this.AsynchronousClient.PostAsync<ConnectBlueskyCredentials200Response>("/v1/connect/bluesky/credentials", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ConnectBlueskyCredentials", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Get OAuth connect URL Initiate an OAuth connection flow for any supported platform. Standard flow: call this endpoint, redirect user to the returned authUrl, Late hosts the selection UI, then redirects to your redirect_url. Headless mode (Facebook, LinkedIn, Pinterest, Google Business, Snapchat): add headless&#x3D;true to this endpoint. After OAuth, the user is redirected to your redirect_url with OAuth data (profileId, tempToken, userProfile, connect_token, platform, step). Use the platform-specific selection endpoints to fetch options and save the selection. LinkedIn uses pendingDataToken instead of tempToken; call GET /v1/connect/pending-data?token&#x3D;TOKEN to retrieve OAuth data (one-time use, expires in 10 minutes). 
        /// </summary>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="platform">Social media platform to connect</param>
        /// <param name="profileId">Your Late profile ID (get from /v1/profiles)</param>
        /// <param name="redirectUrl">Your custom redirect URL after connection completes. Standard mode: Late redirects here with ?connected&#x3D;{platform}&amp;profileId&#x3D;X&amp;username&#x3D;Y. Headless mode: pass headless&#x3D;true on this endpoint. User is redirected to your URL with OAuth data (profileId, tempToken, userProfile, connect_token, platform, step). See endpoint description for details.  (optional)</param>
        /// <returns>GetConnectUrl200Response</returns>
        public GetConnectUrl200Response GetConnectUrl(string platform, string profileId, string? redirectUrl = default)
        {
            Late.Client.ApiResponse<GetConnectUrl200Response> localVarResponse = GetConnectUrlWithHttpInfo(platform, profileId, redirectUrl);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Get OAuth connect URL Initiate an OAuth connection flow for any supported platform. Standard flow: call this endpoint, redirect user to the returned authUrl, Late hosts the selection UI, then redirects to your redirect_url. Headless mode (Facebook, LinkedIn, Pinterest, Google Business, Snapchat): add headless&#x3D;true to this endpoint. After OAuth, the user is redirected to your redirect_url with OAuth data (profileId, tempToken, userProfile, connect_token, platform, step). Use the platform-specific selection endpoints to fetch options and save the selection. LinkedIn uses pendingDataToken instead of tempToken; call GET /v1/connect/pending-data?token&#x3D;TOKEN to retrieve OAuth data (one-time use, expires in 10 minutes). 
        /// </summary>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="platform">Social media platform to connect</param>
        /// <param name="profileId">Your Late profile ID (get from /v1/profiles)</param>
        /// <param name="redirectUrl">Your custom redirect URL after connection completes. Standard mode: Late redirects here with ?connected&#x3D;{platform}&amp;profileId&#x3D;X&amp;username&#x3D;Y. Headless mode: pass headless&#x3D;true on this endpoint. User is redirected to your URL with OAuth data (profileId, tempToken, userProfile, connect_token, platform, step). See endpoint description for details.  (optional)</param>
        /// <returns>ApiResponse of GetConnectUrl200Response</returns>
        public Late.Client.ApiResponse<GetConnectUrl200Response> GetConnectUrlWithHttpInfo(string platform, string profileId, string? redirectUrl = default)
        {
            // verify the required parameter 'platform' is set
            if (platform == null)
                throw new Late.Client.ApiException(400, "Missing required parameter 'platform' when calling ConnectApi->GetConnectUrl");

            // verify the required parameter 'profileId' is set
            if (profileId == null)
                throw new Late.Client.ApiException(400, "Missing required parameter 'profileId' when calling ConnectApi->GetConnectUrl");

            Late.Client.RequestOptions localVarRequestOptions = new Late.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Late.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Late.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("platform", Late.Client.ClientUtils.ParameterToString(platform)); // path parameter
            localVarRequestOptions.QueryParameters.Add(Late.Client.ClientUtils.ParameterToMultiMap("", "profileId", profileId));
            if (redirectUrl != null)
            {
                localVarRequestOptions.QueryParameters.Add(Late.Client.ClientUtils.ParameterToMultiMap("", "redirect_url", redirectUrl));
            }

            // authentication (bearerAuth) required
            // bearer authentication required
            if (!string.IsNullOrEmpty(this.Configuration.AccessToken) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
            }

            // make the HTTP request
            var localVarResponse = this.Client.Get<GetConnectUrl200Response>("/v1/connect/{platform}", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetConnectUrl", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Get OAuth connect URL Initiate an OAuth connection flow for any supported platform. Standard flow: call this endpoint, redirect user to the returned authUrl, Late hosts the selection UI, then redirects to your redirect_url. Headless mode (Facebook, LinkedIn, Pinterest, Google Business, Snapchat): add headless&#x3D;true to this endpoint. After OAuth, the user is redirected to your redirect_url with OAuth data (profileId, tempToken, userProfile, connect_token, platform, step). Use the platform-specific selection endpoints to fetch options and save the selection. LinkedIn uses pendingDataToken instead of tempToken; call GET /v1/connect/pending-data?token&#x3D;TOKEN to retrieve OAuth data (one-time use, expires in 10 minutes). 
        /// </summary>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="platform">Social media platform to connect</param>
        /// <param name="profileId">Your Late profile ID (get from /v1/profiles)</param>
        /// <param name="redirectUrl">Your custom redirect URL after connection completes. Standard mode: Late redirects here with ?connected&#x3D;{platform}&amp;profileId&#x3D;X&amp;username&#x3D;Y. Headless mode: pass headless&#x3D;true on this endpoint. User is redirected to your URL with OAuth data (profileId, tempToken, userProfile, connect_token, platform, step). See endpoint description for details.  (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of GetConnectUrl200Response</returns>
        public async System.Threading.Tasks.Task<GetConnectUrl200Response> GetConnectUrlAsync(string platform, string profileId, string? redirectUrl = default, System.Threading.CancellationToken cancellationToken = default)
        {
            Late.Client.ApiResponse<GetConnectUrl200Response> localVarResponse = await GetConnectUrlWithHttpInfoAsync(platform, profileId, redirectUrl, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Get OAuth connect URL Initiate an OAuth connection flow for any supported platform. Standard flow: call this endpoint, redirect user to the returned authUrl, Late hosts the selection UI, then redirects to your redirect_url. Headless mode (Facebook, LinkedIn, Pinterest, Google Business, Snapchat): add headless&#x3D;true to this endpoint. After OAuth, the user is redirected to your redirect_url with OAuth data (profileId, tempToken, userProfile, connect_token, platform, step). Use the platform-specific selection endpoints to fetch options and save the selection. LinkedIn uses pendingDataToken instead of tempToken; call GET /v1/connect/pending-data?token&#x3D;TOKEN to retrieve OAuth data (one-time use, expires in 10 minutes). 
        /// </summary>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="platform">Social media platform to connect</param>
        /// <param name="profileId">Your Late profile ID (get from /v1/profiles)</param>
        /// <param name="redirectUrl">Your custom redirect URL after connection completes. Standard mode: Late redirects here with ?connected&#x3D;{platform}&amp;profileId&#x3D;X&amp;username&#x3D;Y. Headless mode: pass headless&#x3D;true on this endpoint. User is redirected to your URL with OAuth data (profileId, tempToken, userProfile, connect_token, platform, step). See endpoint description for details.  (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (GetConnectUrl200Response)</returns>
        public async System.Threading.Tasks.Task<Late.Client.ApiResponse<GetConnectUrl200Response>> GetConnectUrlWithHttpInfoAsync(string platform, string profileId, string? redirectUrl = default, System.Threading.CancellationToken cancellationToken = default)
        {
            // verify the required parameter 'platform' is set
            if (platform == null)
                throw new Late.Client.ApiException(400, "Missing required parameter 'platform' when calling ConnectApi->GetConnectUrl");

            // verify the required parameter 'profileId' is set
            if (profileId == null)
                throw new Late.Client.ApiException(400, "Missing required parameter 'profileId' when calling ConnectApi->GetConnectUrl");


            Late.Client.RequestOptions localVarRequestOptions = new Late.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };


            var localVarContentType = Late.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Late.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("platform", Late.Client.ClientUtils.ParameterToString(platform)); // path parameter
            localVarRequestOptions.QueryParameters.Add(Late.Client.ClientUtils.ParameterToMultiMap("", "profileId", profileId));
            if (redirectUrl != null)
            {
                localVarRequestOptions.QueryParameters.Add(Late.Client.ClientUtils.ParameterToMultiMap("", "redirect_url", redirectUrl));
            }

            // authentication (bearerAuth) required
            // bearer authentication required
            if (!string.IsNullOrEmpty(this.Configuration.AccessToken) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
            }

            // make the HTTP request

            var localVarResponse = await this.AsynchronousClient.GetAsync<GetConnectUrl200Response>("/v1/connect/{platform}", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetConnectUrl", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// List Facebook pages Returns all Facebook pages the connected account has access to, including the currently selected page.
        /// </summary>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="accountId"></param>
        /// <returns>GetFacebookPages200Response</returns>
        public GetFacebookPages200Response GetFacebookPages(string accountId)
        {
            Late.Client.ApiResponse<GetFacebookPages200Response> localVarResponse = GetFacebookPagesWithHttpInfo(accountId);
            return localVarResponse.Data;
        }

        /// <summary>
        /// List Facebook pages Returns all Facebook pages the connected account has access to, including the currently selected page.
        /// </summary>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="accountId"></param>
        /// <returns>ApiResponse of GetFacebookPages200Response</returns>
        public Late.Client.ApiResponse<GetFacebookPages200Response> GetFacebookPagesWithHttpInfo(string accountId)
        {
            // verify the required parameter 'accountId' is set
            if (accountId == null)
                throw new Late.Client.ApiException(400, "Missing required parameter 'accountId' when calling ConnectApi->GetFacebookPages");

            Late.Client.RequestOptions localVarRequestOptions = new Late.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Late.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Late.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("accountId", Late.Client.ClientUtils.ParameterToString(accountId)); // path parameter

            // authentication (bearerAuth) required
            // bearer authentication required
            if (!string.IsNullOrEmpty(this.Configuration.AccessToken) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
            }

            // make the HTTP request
            var localVarResponse = this.Client.Get<GetFacebookPages200Response>("/v1/accounts/{accountId}/facebook-page", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetFacebookPages", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// List Facebook pages Returns all Facebook pages the connected account has access to, including the currently selected page.
        /// </summary>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="accountId"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of GetFacebookPages200Response</returns>
        public async System.Threading.Tasks.Task<GetFacebookPages200Response> GetFacebookPagesAsync(string accountId, System.Threading.CancellationToken cancellationToken = default)
        {
            Late.Client.ApiResponse<GetFacebookPages200Response> localVarResponse = await GetFacebookPagesWithHttpInfoAsync(accountId, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// List Facebook pages Returns all Facebook pages the connected account has access to, including the currently selected page.
        /// </summary>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="accountId"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (GetFacebookPages200Response)</returns>
        public async System.Threading.Tasks.Task<Late.Client.ApiResponse<GetFacebookPages200Response>> GetFacebookPagesWithHttpInfoAsync(string accountId, System.Threading.CancellationToken cancellationToken = default)
        {
            // verify the required parameter 'accountId' is set
            if (accountId == null)
                throw new Late.Client.ApiException(400, "Missing required parameter 'accountId' when calling ConnectApi->GetFacebookPages");


            Late.Client.RequestOptions localVarRequestOptions = new Late.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };


            var localVarContentType = Late.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Late.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("accountId", Late.Client.ClientUtils.ParameterToString(accountId)); // path parameter

            // authentication (bearerAuth) required
            // bearer authentication required
            if (!string.IsNullOrEmpty(this.Configuration.AccessToken) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
            }

            // make the HTTP request

            var localVarResponse = await this.AsynchronousClient.GetAsync<GetFacebookPages200Response>("/v1/accounts/{accountId}/facebook-page", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetFacebookPages", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// List GBP locations Returns all Google Business Profile locations the connected account has access to, including the currently selected location.
        /// </summary>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="accountId"></param>
        /// <returns>GetGmbLocations200Response</returns>
        public GetGmbLocations200Response GetGmbLocations(string accountId)
        {
            Late.Client.ApiResponse<GetGmbLocations200Response> localVarResponse = GetGmbLocationsWithHttpInfo(accountId);
            return localVarResponse.Data;
        }

        /// <summary>
        /// List GBP locations Returns all Google Business Profile locations the connected account has access to, including the currently selected location.
        /// </summary>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="accountId"></param>
        /// <returns>ApiResponse of GetGmbLocations200Response</returns>
        public Late.Client.ApiResponse<GetGmbLocations200Response> GetGmbLocationsWithHttpInfo(string accountId)
        {
            // verify the required parameter 'accountId' is set
            if (accountId == null)
                throw new Late.Client.ApiException(400, "Missing required parameter 'accountId' when calling ConnectApi->GetGmbLocations");

            Late.Client.RequestOptions localVarRequestOptions = new Late.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Late.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Late.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("accountId", Late.Client.ClientUtils.ParameterToString(accountId)); // path parameter

            // authentication (bearerAuth) required
            // bearer authentication required
            if (!string.IsNullOrEmpty(this.Configuration.AccessToken) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
            }

            // make the HTTP request
            var localVarResponse = this.Client.Get<GetGmbLocations200Response>("/v1/accounts/{accountId}/gmb-locations", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetGmbLocations", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// List GBP locations Returns all Google Business Profile locations the connected account has access to, including the currently selected location.
        /// </summary>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="accountId"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of GetGmbLocations200Response</returns>
        public async System.Threading.Tasks.Task<GetGmbLocations200Response> GetGmbLocationsAsync(string accountId, System.Threading.CancellationToken cancellationToken = default)
        {
            Late.Client.ApiResponse<GetGmbLocations200Response> localVarResponse = await GetGmbLocationsWithHttpInfoAsync(accountId, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// List GBP locations Returns all Google Business Profile locations the connected account has access to, including the currently selected location.
        /// </summary>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="accountId"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (GetGmbLocations200Response)</returns>
        public async System.Threading.Tasks.Task<Late.Client.ApiResponse<GetGmbLocations200Response>> GetGmbLocationsWithHttpInfoAsync(string accountId, System.Threading.CancellationToken cancellationToken = default)
        {
            // verify the required parameter 'accountId' is set
            if (accountId == null)
                throw new Late.Client.ApiException(400, "Missing required parameter 'accountId' when calling ConnectApi->GetGmbLocations");


            Late.Client.RequestOptions localVarRequestOptions = new Late.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };


            var localVarContentType = Late.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Late.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("accountId", Late.Client.ClientUtils.ParameterToString(accountId)); // path parameter

            // authentication (bearerAuth) required
            // bearer authentication required
            if (!string.IsNullOrEmpty(this.Configuration.AccessToken) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
            }

            // make the HTTP request

            var localVarResponse = await this.AsynchronousClient.GetAsync<GetGmbLocations200Response>("/v1/accounts/{accountId}/gmb-locations", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetGmbLocations", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// List LinkedIn orgs 
        /// </summary>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="accountId"></param>
        /// <returns>GetLinkedInOrganizations200Response</returns>
        public GetLinkedInOrganizations200Response GetLinkedInOrganizations(string accountId)
        {
            Late.Client.ApiResponse<GetLinkedInOrganizations200Response> localVarResponse = GetLinkedInOrganizationsWithHttpInfo(accountId);
            return localVarResponse.Data;
        }

        /// <summary>
        /// List LinkedIn orgs 
        /// </summary>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="accountId"></param>
        /// <returns>ApiResponse of GetLinkedInOrganizations200Response</returns>
        public Late.Client.ApiResponse<GetLinkedInOrganizations200Response> GetLinkedInOrganizationsWithHttpInfo(string accountId)
        {
            // verify the required parameter 'accountId' is set
            if (accountId == null)
                throw new Late.Client.ApiException(400, "Missing required parameter 'accountId' when calling ConnectApi->GetLinkedInOrganizations");

            Late.Client.RequestOptions localVarRequestOptions = new Late.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Late.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Late.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("accountId", Late.Client.ClientUtils.ParameterToString(accountId)); // path parameter

            // authentication (bearerAuth) required
            // bearer authentication required
            if (!string.IsNullOrEmpty(this.Configuration.AccessToken) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
            }

            // make the HTTP request
            var localVarResponse = this.Client.Get<GetLinkedInOrganizations200Response>("/v1/accounts/{accountId}/linkedin-organizations", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetLinkedInOrganizations", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// List LinkedIn orgs 
        /// </summary>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="accountId"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of GetLinkedInOrganizations200Response</returns>
        public async System.Threading.Tasks.Task<GetLinkedInOrganizations200Response> GetLinkedInOrganizationsAsync(string accountId, System.Threading.CancellationToken cancellationToken = default)
        {
            Late.Client.ApiResponse<GetLinkedInOrganizations200Response> localVarResponse = await GetLinkedInOrganizationsWithHttpInfoAsync(accountId, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// List LinkedIn orgs 
        /// </summary>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="accountId"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (GetLinkedInOrganizations200Response)</returns>
        public async System.Threading.Tasks.Task<Late.Client.ApiResponse<GetLinkedInOrganizations200Response>> GetLinkedInOrganizationsWithHttpInfoAsync(string accountId, System.Threading.CancellationToken cancellationToken = default)
        {
            // verify the required parameter 'accountId' is set
            if (accountId == null)
                throw new Late.Client.ApiException(400, "Missing required parameter 'accountId' when calling ConnectApi->GetLinkedInOrganizations");


            Late.Client.RequestOptions localVarRequestOptions = new Late.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };


            var localVarContentType = Late.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Late.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("accountId", Late.Client.ClientUtils.ParameterToString(accountId)); // path parameter

            // authentication (bearerAuth) required
            // bearer authentication required
            if (!string.IsNullOrEmpty(this.Configuration.AccessToken) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
            }

            // make the HTTP request

            var localVarResponse = await this.AsynchronousClient.GetAsync<GetLinkedInOrganizations200Response>("/v1/accounts/{accountId}/linkedin-organizations", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetLinkedInOrganizations", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Get pending OAuth data Fetch pending OAuth data for headless mode. Platforms like LinkedIn store OAuth selection data (organizations, pages, etc.) server-side to prevent URI_TOO_LONG errors. After OAuth redirect, use the pendingDataToken from the URL to fetch the stored data. This endpoint is one-time use (data is deleted after fetch) and expires after 10 minutes. No authentication required, just the token. 
        /// </summary>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="token">The pending data token from the OAuth redirect URL (pendingDataToken parameter)</param>
        /// <returns>GetPendingOAuthData200Response</returns>
        public GetPendingOAuthData200Response GetPendingOAuthData(string token)
        {
            Late.Client.ApiResponse<GetPendingOAuthData200Response> localVarResponse = GetPendingOAuthDataWithHttpInfo(token);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Get pending OAuth data Fetch pending OAuth data for headless mode. Platforms like LinkedIn store OAuth selection data (organizations, pages, etc.) server-side to prevent URI_TOO_LONG errors. After OAuth redirect, use the pendingDataToken from the URL to fetch the stored data. This endpoint is one-time use (data is deleted after fetch) and expires after 10 minutes. No authentication required, just the token. 
        /// </summary>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="token">The pending data token from the OAuth redirect URL (pendingDataToken parameter)</param>
        /// <returns>ApiResponse of GetPendingOAuthData200Response</returns>
        public Late.Client.ApiResponse<GetPendingOAuthData200Response> GetPendingOAuthDataWithHttpInfo(string token)
        {
            // verify the required parameter 'token' is set
            if (token == null)
                throw new Late.Client.ApiException(400, "Missing required parameter 'token' when calling ConnectApi->GetPendingOAuthData");

            Late.Client.RequestOptions localVarRequestOptions = new Late.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Late.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Late.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.QueryParameters.Add(Late.Client.ClientUtils.ParameterToMultiMap("", "token", token));

            // authentication (bearerAuth) required
            // bearer authentication required
            if (!string.IsNullOrEmpty(this.Configuration.AccessToken) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
            }

            // make the HTTP request
            var localVarResponse = this.Client.Get<GetPendingOAuthData200Response>("/v1/connect/pending-data", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetPendingOAuthData", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Get pending OAuth data Fetch pending OAuth data for headless mode. Platforms like LinkedIn store OAuth selection data (organizations, pages, etc.) server-side to prevent URI_TOO_LONG errors. After OAuth redirect, use the pendingDataToken from the URL to fetch the stored data. This endpoint is one-time use (data is deleted after fetch) and expires after 10 minutes. No authentication required, just the token. 
        /// </summary>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="token">The pending data token from the OAuth redirect URL (pendingDataToken parameter)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of GetPendingOAuthData200Response</returns>
        public async System.Threading.Tasks.Task<GetPendingOAuthData200Response> GetPendingOAuthDataAsync(string token, System.Threading.CancellationToken cancellationToken = default)
        {
            Late.Client.ApiResponse<GetPendingOAuthData200Response> localVarResponse = await GetPendingOAuthDataWithHttpInfoAsync(token, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Get pending OAuth data Fetch pending OAuth data for headless mode. Platforms like LinkedIn store OAuth selection data (organizations, pages, etc.) server-side to prevent URI_TOO_LONG errors. After OAuth redirect, use the pendingDataToken from the URL to fetch the stored data. This endpoint is one-time use (data is deleted after fetch) and expires after 10 minutes. No authentication required, just the token. 
        /// </summary>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="token">The pending data token from the OAuth redirect URL (pendingDataToken parameter)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (GetPendingOAuthData200Response)</returns>
        public async System.Threading.Tasks.Task<Late.Client.ApiResponse<GetPendingOAuthData200Response>> GetPendingOAuthDataWithHttpInfoAsync(string token, System.Threading.CancellationToken cancellationToken = default)
        {
            // verify the required parameter 'token' is set
            if (token == null)
                throw new Late.Client.ApiException(400, "Missing required parameter 'token' when calling ConnectApi->GetPendingOAuthData");


            Late.Client.RequestOptions localVarRequestOptions = new Late.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };


            var localVarContentType = Late.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Late.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.QueryParameters.Add(Late.Client.ClientUtils.ParameterToMultiMap("", "token", token));

            // authentication (bearerAuth) required
            // bearer authentication required
            if (!string.IsNullOrEmpty(this.Configuration.AccessToken) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
            }

            // make the HTTP request

            var localVarResponse = await this.AsynchronousClient.GetAsync<GetPendingOAuthData200Response>("/v1/connect/pending-data", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetPendingOAuthData", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// List Pinterest boards 
        /// </summary>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="accountId"></param>
        /// <returns>GetPinterestBoards200Response</returns>
        public GetPinterestBoards200Response GetPinterestBoards(string accountId)
        {
            Late.Client.ApiResponse<GetPinterestBoards200Response> localVarResponse = GetPinterestBoardsWithHttpInfo(accountId);
            return localVarResponse.Data;
        }

        /// <summary>
        /// List Pinterest boards 
        /// </summary>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="accountId"></param>
        /// <returns>ApiResponse of GetPinterestBoards200Response</returns>
        public Late.Client.ApiResponse<GetPinterestBoards200Response> GetPinterestBoardsWithHttpInfo(string accountId)
        {
            // verify the required parameter 'accountId' is set
            if (accountId == null)
                throw new Late.Client.ApiException(400, "Missing required parameter 'accountId' when calling ConnectApi->GetPinterestBoards");

            Late.Client.RequestOptions localVarRequestOptions = new Late.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Late.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Late.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("accountId", Late.Client.ClientUtils.ParameterToString(accountId)); // path parameter

            // authentication (bearerAuth) required
            // bearer authentication required
            if (!string.IsNullOrEmpty(this.Configuration.AccessToken) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
            }

            // make the HTTP request
            var localVarResponse = this.Client.Get<GetPinterestBoards200Response>("/v1/accounts/{accountId}/pinterest-boards", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetPinterestBoards", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// List Pinterest boards 
        /// </summary>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="accountId"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of GetPinterestBoards200Response</returns>
        public async System.Threading.Tasks.Task<GetPinterestBoards200Response> GetPinterestBoardsAsync(string accountId, System.Threading.CancellationToken cancellationToken = default)
        {
            Late.Client.ApiResponse<GetPinterestBoards200Response> localVarResponse = await GetPinterestBoardsWithHttpInfoAsync(accountId, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// List Pinterest boards 
        /// </summary>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="accountId"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (GetPinterestBoards200Response)</returns>
        public async System.Threading.Tasks.Task<Late.Client.ApiResponse<GetPinterestBoards200Response>> GetPinterestBoardsWithHttpInfoAsync(string accountId, System.Threading.CancellationToken cancellationToken = default)
        {
            // verify the required parameter 'accountId' is set
            if (accountId == null)
                throw new Late.Client.ApiException(400, "Missing required parameter 'accountId' when calling ConnectApi->GetPinterestBoards");


            Late.Client.RequestOptions localVarRequestOptions = new Late.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };


            var localVarContentType = Late.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Late.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("accountId", Late.Client.ClientUtils.ParameterToString(accountId)); // path parameter

            // authentication (bearerAuth) required
            // bearer authentication required
            if (!string.IsNullOrEmpty(this.Configuration.AccessToken) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
            }

            // make the HTTP request

            var localVarResponse = await this.AsynchronousClient.GetAsync<GetPinterestBoards200Response>("/v1/accounts/{accountId}/pinterest-boards", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetPinterestBoards", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// List subreddit flairs 
        /// </summary>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="accountId"></param>
        /// <param name="subreddit">Subreddit name (without \&quot;r/\&quot; prefix) to fetch flairs for</param>
        /// <returns>GetRedditFlairs200Response</returns>
        public GetRedditFlairs200Response GetRedditFlairs(string accountId, string subreddit)
        {
            Late.Client.ApiResponse<GetRedditFlairs200Response> localVarResponse = GetRedditFlairsWithHttpInfo(accountId, subreddit);
            return localVarResponse.Data;
        }

        /// <summary>
        /// List subreddit flairs 
        /// </summary>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="accountId"></param>
        /// <param name="subreddit">Subreddit name (without \&quot;r/\&quot; prefix) to fetch flairs for</param>
        /// <returns>ApiResponse of GetRedditFlairs200Response</returns>
        public Late.Client.ApiResponse<GetRedditFlairs200Response> GetRedditFlairsWithHttpInfo(string accountId, string subreddit)
        {
            // verify the required parameter 'accountId' is set
            if (accountId == null)
                throw new Late.Client.ApiException(400, "Missing required parameter 'accountId' when calling ConnectApi->GetRedditFlairs");

            // verify the required parameter 'subreddit' is set
            if (subreddit == null)
                throw new Late.Client.ApiException(400, "Missing required parameter 'subreddit' when calling ConnectApi->GetRedditFlairs");

            Late.Client.RequestOptions localVarRequestOptions = new Late.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Late.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Late.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("accountId", Late.Client.ClientUtils.ParameterToString(accountId)); // path parameter
            localVarRequestOptions.QueryParameters.Add(Late.Client.ClientUtils.ParameterToMultiMap("", "subreddit", subreddit));

            // authentication (bearerAuth) required
            // bearer authentication required
            if (!string.IsNullOrEmpty(this.Configuration.AccessToken) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
            }

            // make the HTTP request
            var localVarResponse = this.Client.Get<GetRedditFlairs200Response>("/v1/accounts/{accountId}/reddit-flairs", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetRedditFlairs", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// List subreddit flairs 
        /// </summary>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="accountId"></param>
        /// <param name="subreddit">Subreddit name (without \&quot;r/\&quot; prefix) to fetch flairs for</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of GetRedditFlairs200Response</returns>
        public async System.Threading.Tasks.Task<GetRedditFlairs200Response> GetRedditFlairsAsync(string accountId, string subreddit, System.Threading.CancellationToken cancellationToken = default)
        {
            Late.Client.ApiResponse<GetRedditFlairs200Response> localVarResponse = await GetRedditFlairsWithHttpInfoAsync(accountId, subreddit, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// List subreddit flairs 
        /// </summary>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="accountId"></param>
        /// <param name="subreddit">Subreddit name (without \&quot;r/\&quot; prefix) to fetch flairs for</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (GetRedditFlairs200Response)</returns>
        public async System.Threading.Tasks.Task<Late.Client.ApiResponse<GetRedditFlairs200Response>> GetRedditFlairsWithHttpInfoAsync(string accountId, string subreddit, System.Threading.CancellationToken cancellationToken = default)
        {
            // verify the required parameter 'accountId' is set
            if (accountId == null)
                throw new Late.Client.ApiException(400, "Missing required parameter 'accountId' when calling ConnectApi->GetRedditFlairs");

            // verify the required parameter 'subreddit' is set
            if (subreddit == null)
                throw new Late.Client.ApiException(400, "Missing required parameter 'subreddit' when calling ConnectApi->GetRedditFlairs");


            Late.Client.RequestOptions localVarRequestOptions = new Late.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };


            var localVarContentType = Late.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Late.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("accountId", Late.Client.ClientUtils.ParameterToString(accountId)); // path parameter
            localVarRequestOptions.QueryParameters.Add(Late.Client.ClientUtils.ParameterToMultiMap("", "subreddit", subreddit));

            // authentication (bearerAuth) required
            // bearer authentication required
            if (!string.IsNullOrEmpty(this.Configuration.AccessToken) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
            }

            // make the HTTP request

            var localVarResponse = await this.AsynchronousClient.GetAsync<GetRedditFlairs200Response>("/v1/accounts/{accountId}/reddit-flairs", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetRedditFlairs", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// List Reddit subreddits 
        /// </summary>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="accountId"></param>
        /// <returns>GetRedditSubreddits200Response</returns>
        public GetRedditSubreddits200Response GetRedditSubreddits(string accountId)
        {
            Late.Client.ApiResponse<GetRedditSubreddits200Response> localVarResponse = GetRedditSubredditsWithHttpInfo(accountId);
            return localVarResponse.Data;
        }

        /// <summary>
        /// List Reddit subreddits 
        /// </summary>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="accountId"></param>
        /// <returns>ApiResponse of GetRedditSubreddits200Response</returns>
        public Late.Client.ApiResponse<GetRedditSubreddits200Response> GetRedditSubredditsWithHttpInfo(string accountId)
        {
            // verify the required parameter 'accountId' is set
            if (accountId == null)
                throw new Late.Client.ApiException(400, "Missing required parameter 'accountId' when calling ConnectApi->GetRedditSubreddits");

            Late.Client.RequestOptions localVarRequestOptions = new Late.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Late.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Late.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("accountId", Late.Client.ClientUtils.ParameterToString(accountId)); // path parameter

            // authentication (bearerAuth) required
            // bearer authentication required
            if (!string.IsNullOrEmpty(this.Configuration.AccessToken) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
            }

            // make the HTTP request
            var localVarResponse = this.Client.Get<GetRedditSubreddits200Response>("/v1/accounts/{accountId}/reddit-subreddits", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetRedditSubreddits", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// List Reddit subreddits 
        /// </summary>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="accountId"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of GetRedditSubreddits200Response</returns>
        public async System.Threading.Tasks.Task<GetRedditSubreddits200Response> GetRedditSubredditsAsync(string accountId, System.Threading.CancellationToken cancellationToken = default)
        {
            Late.Client.ApiResponse<GetRedditSubreddits200Response> localVarResponse = await GetRedditSubredditsWithHttpInfoAsync(accountId, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// List Reddit subreddits 
        /// </summary>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="accountId"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (GetRedditSubreddits200Response)</returns>
        public async System.Threading.Tasks.Task<Late.Client.ApiResponse<GetRedditSubreddits200Response>> GetRedditSubredditsWithHttpInfoAsync(string accountId, System.Threading.CancellationToken cancellationToken = default)
        {
            // verify the required parameter 'accountId' is set
            if (accountId == null)
                throw new Late.Client.ApiException(400, "Missing required parameter 'accountId' when calling ConnectApi->GetRedditSubreddits");


            Late.Client.RequestOptions localVarRequestOptions = new Late.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };


            var localVarContentType = Late.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Late.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("accountId", Late.Client.ClientUtils.ParameterToString(accountId)); // path parameter

            // authentication (bearerAuth) required
            // bearer authentication required
            if (!string.IsNullOrEmpty(this.Configuration.AccessToken) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
            }

            // make the HTTP request

            var localVarResponse = await this.AsynchronousClient.GetAsync<GetRedditSubreddits200Response>("/v1/accounts/{accountId}/reddit-subreddits", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetRedditSubreddits", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Generate Telegram code Generate a unique access code for connecting a Telegram channel or group. Flow: get an access code (valid 15 minutes), add the bot as admin in your channel/group, open a private chat with the bot, send the code + @yourchannel (e.g. LATE-ABC123 @mychannel), then poll PATCH /v1/connect/telegram?code&#x3D;{CODE} to check connection status. For private channels without a public username, forward any message from the channel to the bot along with the access code. 
        /// </summary>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="profileId">The profile ID to connect the Telegram account to</param>
        /// <returns>GetTelegramConnectStatus200Response</returns>
        public GetTelegramConnectStatus200Response GetTelegramConnectStatus(string profileId)
        {
            Late.Client.ApiResponse<GetTelegramConnectStatus200Response> localVarResponse = GetTelegramConnectStatusWithHttpInfo(profileId);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Generate Telegram code Generate a unique access code for connecting a Telegram channel or group. Flow: get an access code (valid 15 minutes), add the bot as admin in your channel/group, open a private chat with the bot, send the code + @yourchannel (e.g. LATE-ABC123 @mychannel), then poll PATCH /v1/connect/telegram?code&#x3D;{CODE} to check connection status. For private channels without a public username, forward any message from the channel to the bot along with the access code. 
        /// </summary>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="profileId">The profile ID to connect the Telegram account to</param>
        /// <returns>ApiResponse of GetTelegramConnectStatus200Response</returns>
        public Late.Client.ApiResponse<GetTelegramConnectStatus200Response> GetTelegramConnectStatusWithHttpInfo(string profileId)
        {
            // verify the required parameter 'profileId' is set
            if (profileId == null)
                throw new Late.Client.ApiException(400, "Missing required parameter 'profileId' when calling ConnectApi->GetTelegramConnectStatus");

            Late.Client.RequestOptions localVarRequestOptions = new Late.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Late.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Late.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.QueryParameters.Add(Late.Client.ClientUtils.ParameterToMultiMap("", "profileId", profileId));

            // authentication (bearerAuth) required
            // bearer authentication required
            if (!string.IsNullOrEmpty(this.Configuration.AccessToken) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
            }

            // make the HTTP request
            var localVarResponse = this.Client.Get<GetTelegramConnectStatus200Response>("/v1/connect/telegram", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetTelegramConnectStatus", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Generate Telegram code Generate a unique access code for connecting a Telegram channel or group. Flow: get an access code (valid 15 minutes), add the bot as admin in your channel/group, open a private chat with the bot, send the code + @yourchannel (e.g. LATE-ABC123 @mychannel), then poll PATCH /v1/connect/telegram?code&#x3D;{CODE} to check connection status. For private channels without a public username, forward any message from the channel to the bot along with the access code. 
        /// </summary>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="profileId">The profile ID to connect the Telegram account to</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of GetTelegramConnectStatus200Response</returns>
        public async System.Threading.Tasks.Task<GetTelegramConnectStatus200Response> GetTelegramConnectStatusAsync(string profileId, System.Threading.CancellationToken cancellationToken = default)
        {
            Late.Client.ApiResponse<GetTelegramConnectStatus200Response> localVarResponse = await GetTelegramConnectStatusWithHttpInfoAsync(profileId, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Generate Telegram code Generate a unique access code for connecting a Telegram channel or group. Flow: get an access code (valid 15 minutes), add the bot as admin in your channel/group, open a private chat with the bot, send the code + @yourchannel (e.g. LATE-ABC123 @mychannel), then poll PATCH /v1/connect/telegram?code&#x3D;{CODE} to check connection status. For private channels without a public username, forward any message from the channel to the bot along with the access code. 
        /// </summary>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="profileId">The profile ID to connect the Telegram account to</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (GetTelegramConnectStatus200Response)</returns>
        public async System.Threading.Tasks.Task<Late.Client.ApiResponse<GetTelegramConnectStatus200Response>> GetTelegramConnectStatusWithHttpInfoAsync(string profileId, System.Threading.CancellationToken cancellationToken = default)
        {
            // verify the required parameter 'profileId' is set
            if (profileId == null)
                throw new Late.Client.ApiException(400, "Missing required parameter 'profileId' when calling ConnectApi->GetTelegramConnectStatus");


            Late.Client.RequestOptions localVarRequestOptions = new Late.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };


            var localVarContentType = Late.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Late.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.QueryParameters.Add(Late.Client.ClientUtils.ParameterToMultiMap("", "profileId", profileId));

            // authentication (bearerAuth) required
            // bearer authentication required
            if (!string.IsNullOrEmpty(this.Configuration.AccessToken) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
            }

            // make the HTTP request

            var localVarResponse = await this.AsynchronousClient.GetAsync<GetTelegramConnectStatus200Response>("/v1/connect/telegram", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetTelegramConnectStatus", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Complete OAuth callback 
        /// </summary>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="platform"></param>
        /// <param name="handleOAuthCallbackRequest"></param>
        /// <returns></returns>
        public void HandleOAuthCallback(string platform, HandleOAuthCallbackRequest handleOAuthCallbackRequest)
        {
            HandleOAuthCallbackWithHttpInfo(platform, handleOAuthCallbackRequest);
        }

        /// <summary>
        /// Complete OAuth callback 
        /// </summary>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="platform"></param>
        /// <param name="handleOAuthCallbackRequest"></param>
        /// <returns>ApiResponse of Object(void)</returns>
        public Late.Client.ApiResponse<Object> HandleOAuthCallbackWithHttpInfo(string platform, HandleOAuthCallbackRequest handleOAuthCallbackRequest)
        {
            // verify the required parameter 'platform' is set
            if (platform == null)
                throw new Late.Client.ApiException(400, "Missing required parameter 'platform' when calling ConnectApi->HandleOAuthCallback");

            // verify the required parameter 'handleOAuthCallbackRequest' is set
            if (handleOAuthCallbackRequest == null)
                throw new Late.Client.ApiException(400, "Missing required parameter 'handleOAuthCallbackRequest' when calling ConnectApi->HandleOAuthCallback");

            Late.Client.RequestOptions localVarRequestOptions = new Late.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Late.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Late.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("platform", Late.Client.ClientUtils.ParameterToString(platform)); // path parameter
            localVarRequestOptions.Data = handleOAuthCallbackRequest;

            // authentication (bearerAuth) required
            // bearer authentication required
            if (!string.IsNullOrEmpty(this.Configuration.AccessToken) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
            }

            // make the HTTP request
            var localVarResponse = this.Client.Post<Object>("/v1/connect/{platform}", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("HandleOAuthCallback", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Complete OAuth callback 
        /// </summary>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="platform"></param>
        /// <param name="handleOAuthCallbackRequest"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of void</returns>
        public async System.Threading.Tasks.Task HandleOAuthCallbackAsync(string platform, HandleOAuthCallbackRequest handleOAuthCallbackRequest, System.Threading.CancellationToken cancellationToken = default)
        {
            await HandleOAuthCallbackWithHttpInfoAsync(platform, handleOAuthCallbackRequest, cancellationToken).ConfigureAwait(false);
        }

        /// <summary>
        /// Complete OAuth callback 
        /// </summary>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="platform"></param>
        /// <param name="handleOAuthCallbackRequest"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async System.Threading.Tasks.Task<Late.Client.ApiResponse<Object>> HandleOAuthCallbackWithHttpInfoAsync(string platform, HandleOAuthCallbackRequest handleOAuthCallbackRequest, System.Threading.CancellationToken cancellationToken = default)
        {
            // verify the required parameter 'platform' is set
            if (platform == null)
                throw new Late.Client.ApiException(400, "Missing required parameter 'platform' when calling ConnectApi->HandleOAuthCallback");

            // verify the required parameter 'handleOAuthCallbackRequest' is set
            if (handleOAuthCallbackRequest == null)
                throw new Late.Client.ApiException(400, "Missing required parameter 'handleOAuthCallbackRequest' when calling ConnectApi->HandleOAuthCallback");


            Late.Client.RequestOptions localVarRequestOptions = new Late.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };


            var localVarContentType = Late.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Late.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("platform", Late.Client.ClientUtils.ParameterToString(platform)); // path parameter
            localVarRequestOptions.Data = handleOAuthCallbackRequest;

            // authentication (bearerAuth) required
            // bearer authentication required
            if (!string.IsNullOrEmpty(this.Configuration.AccessToken) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
            }

            // make the HTTP request

            var localVarResponse = await this.AsynchronousClient.PostAsync<Object>("/v1/connect/{platform}", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("HandleOAuthCallback", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Connect Telegram directly Connect a Telegram channel/group directly using the chat ID.  This is an alternative to the access code flow for power users who know their Telegram chat ID. The bot must already be added as an administrator in the channel/group. 
        /// </summary>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="initiateTelegramConnectRequest"></param>
        /// <returns>InitiateTelegramConnect200Response</returns>
        public InitiateTelegramConnect200Response InitiateTelegramConnect(InitiateTelegramConnectRequest initiateTelegramConnectRequest)
        {
            Late.Client.ApiResponse<InitiateTelegramConnect200Response> localVarResponse = InitiateTelegramConnectWithHttpInfo(initiateTelegramConnectRequest);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Connect Telegram directly Connect a Telegram channel/group directly using the chat ID.  This is an alternative to the access code flow for power users who know their Telegram chat ID. The bot must already be added as an administrator in the channel/group. 
        /// </summary>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="initiateTelegramConnectRequest"></param>
        /// <returns>ApiResponse of InitiateTelegramConnect200Response</returns>
        public Late.Client.ApiResponse<InitiateTelegramConnect200Response> InitiateTelegramConnectWithHttpInfo(InitiateTelegramConnectRequest initiateTelegramConnectRequest)
        {
            // verify the required parameter 'initiateTelegramConnectRequest' is set
            if (initiateTelegramConnectRequest == null)
                throw new Late.Client.ApiException(400, "Missing required parameter 'initiateTelegramConnectRequest' when calling ConnectApi->InitiateTelegramConnect");

            Late.Client.RequestOptions localVarRequestOptions = new Late.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Late.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Late.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.Data = initiateTelegramConnectRequest;

            // authentication (bearerAuth) required
            // bearer authentication required
            if (!string.IsNullOrEmpty(this.Configuration.AccessToken) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
            }

            // make the HTTP request
            var localVarResponse = this.Client.Post<InitiateTelegramConnect200Response>("/v1/connect/telegram", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("InitiateTelegramConnect", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Connect Telegram directly Connect a Telegram channel/group directly using the chat ID.  This is an alternative to the access code flow for power users who know their Telegram chat ID. The bot must already be added as an administrator in the channel/group. 
        /// </summary>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="initiateTelegramConnectRequest"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of InitiateTelegramConnect200Response</returns>
        public async System.Threading.Tasks.Task<InitiateTelegramConnect200Response> InitiateTelegramConnectAsync(InitiateTelegramConnectRequest initiateTelegramConnectRequest, System.Threading.CancellationToken cancellationToken = default)
        {
            Late.Client.ApiResponse<InitiateTelegramConnect200Response> localVarResponse = await InitiateTelegramConnectWithHttpInfoAsync(initiateTelegramConnectRequest, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Connect Telegram directly Connect a Telegram channel/group directly using the chat ID.  This is an alternative to the access code flow for power users who know their Telegram chat ID. The bot must already be added as an administrator in the channel/group. 
        /// </summary>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="initiateTelegramConnectRequest"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (InitiateTelegramConnect200Response)</returns>
        public async System.Threading.Tasks.Task<Late.Client.ApiResponse<InitiateTelegramConnect200Response>> InitiateTelegramConnectWithHttpInfoAsync(InitiateTelegramConnectRequest initiateTelegramConnectRequest, System.Threading.CancellationToken cancellationToken = default)
        {
            // verify the required parameter 'initiateTelegramConnectRequest' is set
            if (initiateTelegramConnectRequest == null)
                throw new Late.Client.ApiException(400, "Missing required parameter 'initiateTelegramConnectRequest' when calling ConnectApi->InitiateTelegramConnect");


            Late.Client.RequestOptions localVarRequestOptions = new Late.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };


            var localVarContentType = Late.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Late.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.Data = initiateTelegramConnectRequest;

            // authentication (bearerAuth) required
            // bearer authentication required
            if (!string.IsNullOrEmpty(this.Configuration.AccessToken) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
            }

            // make the HTTP request

            var localVarResponse = await this.AsynchronousClient.PostAsync<InitiateTelegramConnect200Response>("/v1/connect/telegram", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("InitiateTelegramConnect", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// List Facebook pages Returns the list of Facebook Pages the user can manage after OAuth. Extract tempToken and userProfile from the OAuth redirect params and pass them here. Use the X-Connect-Token header if connecting via API key.
        /// </summary>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="profileId">Profile ID from your connection flow</param>
        /// <param name="tempToken">Temporary Facebook access token from the OAuth callback redirect</param>
        /// <returns>ListFacebookPages200Response</returns>
        public ListFacebookPages200Response ListFacebookPages(string profileId, string tempToken)
        {
            Late.Client.ApiResponse<ListFacebookPages200Response> localVarResponse = ListFacebookPagesWithHttpInfo(profileId, tempToken);
            return localVarResponse.Data;
        }

        /// <summary>
        /// List Facebook pages Returns the list of Facebook Pages the user can manage after OAuth. Extract tempToken and userProfile from the OAuth redirect params and pass them here. Use the X-Connect-Token header if connecting via API key.
        /// </summary>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="profileId">Profile ID from your connection flow</param>
        /// <param name="tempToken">Temporary Facebook access token from the OAuth callback redirect</param>
        /// <returns>ApiResponse of ListFacebookPages200Response</returns>
        public Late.Client.ApiResponse<ListFacebookPages200Response> ListFacebookPagesWithHttpInfo(string profileId, string tempToken)
        {
            // verify the required parameter 'profileId' is set
            if (profileId == null)
                throw new Late.Client.ApiException(400, "Missing required parameter 'profileId' when calling ConnectApi->ListFacebookPages");

            // verify the required parameter 'tempToken' is set
            if (tempToken == null)
                throw new Late.Client.ApiException(400, "Missing required parameter 'tempToken' when calling ConnectApi->ListFacebookPages");

            Late.Client.RequestOptions localVarRequestOptions = new Late.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Late.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Late.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.QueryParameters.Add(Late.Client.ClientUtils.ParameterToMultiMap("", "profileId", profileId));
            localVarRequestOptions.QueryParameters.Add(Late.Client.ClientUtils.ParameterToMultiMap("", "tempToken", tempToken));

            // authentication (connectToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("X-Connect-Token")))
            {
                localVarRequestOptions.HeaderParameters.Add("X-Connect-Token", this.Configuration.GetApiKeyWithPrefix("X-Connect-Token"));
            }
            // authentication (bearerAuth) required
            // bearer authentication required
            if (!string.IsNullOrEmpty(this.Configuration.AccessToken) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
            }

            // make the HTTP request
            var localVarResponse = this.Client.Get<ListFacebookPages200Response>("/v1/connect/facebook/select-page", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ListFacebookPages", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// List Facebook pages Returns the list of Facebook Pages the user can manage after OAuth. Extract tempToken and userProfile from the OAuth redirect params and pass them here. Use the X-Connect-Token header if connecting via API key.
        /// </summary>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="profileId">Profile ID from your connection flow</param>
        /// <param name="tempToken">Temporary Facebook access token from the OAuth callback redirect</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ListFacebookPages200Response</returns>
        public async System.Threading.Tasks.Task<ListFacebookPages200Response> ListFacebookPagesAsync(string profileId, string tempToken, System.Threading.CancellationToken cancellationToken = default)
        {
            Late.Client.ApiResponse<ListFacebookPages200Response> localVarResponse = await ListFacebookPagesWithHttpInfoAsync(profileId, tempToken, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// List Facebook pages Returns the list of Facebook Pages the user can manage after OAuth. Extract tempToken and userProfile from the OAuth redirect params and pass them here. Use the X-Connect-Token header if connecting via API key.
        /// </summary>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="profileId">Profile ID from your connection flow</param>
        /// <param name="tempToken">Temporary Facebook access token from the OAuth callback redirect</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (ListFacebookPages200Response)</returns>
        public async System.Threading.Tasks.Task<Late.Client.ApiResponse<ListFacebookPages200Response>> ListFacebookPagesWithHttpInfoAsync(string profileId, string tempToken, System.Threading.CancellationToken cancellationToken = default)
        {
            // verify the required parameter 'profileId' is set
            if (profileId == null)
                throw new Late.Client.ApiException(400, "Missing required parameter 'profileId' when calling ConnectApi->ListFacebookPages");

            // verify the required parameter 'tempToken' is set
            if (tempToken == null)
                throw new Late.Client.ApiException(400, "Missing required parameter 'tempToken' when calling ConnectApi->ListFacebookPages");


            Late.Client.RequestOptions localVarRequestOptions = new Late.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };


            var localVarContentType = Late.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Late.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.QueryParameters.Add(Late.Client.ClientUtils.ParameterToMultiMap("", "profileId", profileId));
            localVarRequestOptions.QueryParameters.Add(Late.Client.ClientUtils.ParameterToMultiMap("", "tempToken", tempToken));

            // authentication (connectToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("X-Connect-Token")))
            {
                localVarRequestOptions.HeaderParameters.Add("X-Connect-Token", this.Configuration.GetApiKeyWithPrefix("X-Connect-Token"));
            }
            // authentication (bearerAuth) required
            // bearer authentication required
            if (!string.IsNullOrEmpty(this.Configuration.AccessToken) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
            }

            // make the HTTP request

            var localVarResponse = await this.AsynchronousClient.GetAsync<ListFacebookPages200Response>("/v1/connect/facebook/select-page", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ListFacebookPages", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// List GBP locations For headless/whitelabel flows. After Google Business OAuth with headless&#x3D;true, you&#39;ll be redirected to your redirect_url with tempToken and userProfile params. Call this endpoint to retrieve the list of locations the user can manage, then build your own UI to let them select one. Use the X-Connect-Token header if you initiated the connection via API key. 
        /// </summary>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="profileId">Profile ID from your connection flow</param>
        /// <param name="tempToken">Temporary Google access token from the OAuth callback redirect</param>
        /// <returns>ListGoogleBusinessLocations200Response</returns>
        public ListGoogleBusinessLocations200Response ListGoogleBusinessLocations(string profileId, string tempToken)
        {
            Late.Client.ApiResponse<ListGoogleBusinessLocations200Response> localVarResponse = ListGoogleBusinessLocationsWithHttpInfo(profileId, tempToken);
            return localVarResponse.Data;
        }

        /// <summary>
        /// List GBP locations For headless/whitelabel flows. After Google Business OAuth with headless&#x3D;true, you&#39;ll be redirected to your redirect_url with tempToken and userProfile params. Call this endpoint to retrieve the list of locations the user can manage, then build your own UI to let them select one. Use the X-Connect-Token header if you initiated the connection via API key. 
        /// </summary>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="profileId">Profile ID from your connection flow</param>
        /// <param name="tempToken">Temporary Google access token from the OAuth callback redirect</param>
        /// <returns>ApiResponse of ListGoogleBusinessLocations200Response</returns>
        public Late.Client.ApiResponse<ListGoogleBusinessLocations200Response> ListGoogleBusinessLocationsWithHttpInfo(string profileId, string tempToken)
        {
            // verify the required parameter 'profileId' is set
            if (profileId == null)
                throw new Late.Client.ApiException(400, "Missing required parameter 'profileId' when calling ConnectApi->ListGoogleBusinessLocations");

            // verify the required parameter 'tempToken' is set
            if (tempToken == null)
                throw new Late.Client.ApiException(400, "Missing required parameter 'tempToken' when calling ConnectApi->ListGoogleBusinessLocations");

            Late.Client.RequestOptions localVarRequestOptions = new Late.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Late.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Late.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.QueryParameters.Add(Late.Client.ClientUtils.ParameterToMultiMap("", "profileId", profileId));
            localVarRequestOptions.QueryParameters.Add(Late.Client.ClientUtils.ParameterToMultiMap("", "tempToken", tempToken));

            // authentication (connectToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("X-Connect-Token")))
            {
                localVarRequestOptions.HeaderParameters.Add("X-Connect-Token", this.Configuration.GetApiKeyWithPrefix("X-Connect-Token"));
            }
            // authentication (bearerAuth) required
            // bearer authentication required
            if (!string.IsNullOrEmpty(this.Configuration.AccessToken) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
            }

            // make the HTTP request
            var localVarResponse = this.Client.Get<ListGoogleBusinessLocations200Response>("/v1/connect/googlebusiness/locations", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ListGoogleBusinessLocations", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// List GBP locations For headless/whitelabel flows. After Google Business OAuth with headless&#x3D;true, you&#39;ll be redirected to your redirect_url with tempToken and userProfile params. Call this endpoint to retrieve the list of locations the user can manage, then build your own UI to let them select one. Use the X-Connect-Token header if you initiated the connection via API key. 
        /// </summary>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="profileId">Profile ID from your connection flow</param>
        /// <param name="tempToken">Temporary Google access token from the OAuth callback redirect</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ListGoogleBusinessLocations200Response</returns>
        public async System.Threading.Tasks.Task<ListGoogleBusinessLocations200Response> ListGoogleBusinessLocationsAsync(string profileId, string tempToken, System.Threading.CancellationToken cancellationToken = default)
        {
            Late.Client.ApiResponse<ListGoogleBusinessLocations200Response> localVarResponse = await ListGoogleBusinessLocationsWithHttpInfoAsync(profileId, tempToken, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// List GBP locations For headless/whitelabel flows. After Google Business OAuth with headless&#x3D;true, you&#39;ll be redirected to your redirect_url with tempToken and userProfile params. Call this endpoint to retrieve the list of locations the user can manage, then build your own UI to let them select one. Use the X-Connect-Token header if you initiated the connection via API key. 
        /// </summary>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="profileId">Profile ID from your connection flow</param>
        /// <param name="tempToken">Temporary Google access token from the OAuth callback redirect</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (ListGoogleBusinessLocations200Response)</returns>
        public async System.Threading.Tasks.Task<Late.Client.ApiResponse<ListGoogleBusinessLocations200Response>> ListGoogleBusinessLocationsWithHttpInfoAsync(string profileId, string tempToken, System.Threading.CancellationToken cancellationToken = default)
        {
            // verify the required parameter 'profileId' is set
            if (profileId == null)
                throw new Late.Client.ApiException(400, "Missing required parameter 'profileId' when calling ConnectApi->ListGoogleBusinessLocations");

            // verify the required parameter 'tempToken' is set
            if (tempToken == null)
                throw new Late.Client.ApiException(400, "Missing required parameter 'tempToken' when calling ConnectApi->ListGoogleBusinessLocations");


            Late.Client.RequestOptions localVarRequestOptions = new Late.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };


            var localVarContentType = Late.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Late.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.QueryParameters.Add(Late.Client.ClientUtils.ParameterToMultiMap("", "profileId", profileId));
            localVarRequestOptions.QueryParameters.Add(Late.Client.ClientUtils.ParameterToMultiMap("", "tempToken", tempToken));

            // authentication (connectToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("X-Connect-Token")))
            {
                localVarRequestOptions.HeaderParameters.Add("X-Connect-Token", this.Configuration.GetApiKeyWithPrefix("X-Connect-Token"));
            }
            // authentication (bearerAuth) required
            // bearer authentication required
            if (!string.IsNullOrEmpty(this.Configuration.AccessToken) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
            }

            // make the HTTP request

            var localVarResponse = await this.AsynchronousClient.GetAsync<ListGoogleBusinessLocations200Response>("/v1/connect/googlebusiness/locations", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ListGoogleBusinessLocations", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// List LinkedIn orgs Fetch full organization details for custom UI. After LinkedIn OAuth in headless mode, the redirect URL only contains id, urn, and name fields. Use this endpoint to fetch full details including logos, vanity names, websites, and more. No authentication required, just the tempToken from the OAuth redirect. 
        /// </summary>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="tempToken">The temporary LinkedIn access token from the OAuth redirect</param>
        /// <param name="orgIds">Comma-separated list of organization IDs to fetch details for (max 100)</param>
        /// <returns>ListLinkedInOrganizations200Response</returns>
        public ListLinkedInOrganizations200Response ListLinkedInOrganizations(string tempToken, string orgIds)
        {
            Late.Client.ApiResponse<ListLinkedInOrganizations200Response> localVarResponse = ListLinkedInOrganizationsWithHttpInfo(tempToken, orgIds);
            return localVarResponse.Data;
        }

        /// <summary>
        /// List LinkedIn orgs Fetch full organization details for custom UI. After LinkedIn OAuth in headless mode, the redirect URL only contains id, urn, and name fields. Use this endpoint to fetch full details including logos, vanity names, websites, and more. No authentication required, just the tempToken from the OAuth redirect. 
        /// </summary>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="tempToken">The temporary LinkedIn access token from the OAuth redirect</param>
        /// <param name="orgIds">Comma-separated list of organization IDs to fetch details for (max 100)</param>
        /// <returns>ApiResponse of ListLinkedInOrganizations200Response</returns>
        public Late.Client.ApiResponse<ListLinkedInOrganizations200Response> ListLinkedInOrganizationsWithHttpInfo(string tempToken, string orgIds)
        {
            // verify the required parameter 'tempToken' is set
            if (tempToken == null)
                throw new Late.Client.ApiException(400, "Missing required parameter 'tempToken' when calling ConnectApi->ListLinkedInOrganizations");

            // verify the required parameter 'orgIds' is set
            if (orgIds == null)
                throw new Late.Client.ApiException(400, "Missing required parameter 'orgIds' when calling ConnectApi->ListLinkedInOrganizations");

            Late.Client.RequestOptions localVarRequestOptions = new Late.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Late.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Late.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.QueryParameters.Add(Late.Client.ClientUtils.ParameterToMultiMap("", "tempToken", tempToken));
            localVarRequestOptions.QueryParameters.Add(Late.Client.ClientUtils.ParameterToMultiMap("", "orgIds", orgIds));

            // authentication (bearerAuth) required
            // bearer authentication required
            if (!string.IsNullOrEmpty(this.Configuration.AccessToken) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
            }

            // make the HTTP request
            var localVarResponse = this.Client.Get<ListLinkedInOrganizations200Response>("/v1/connect/linkedin/organizations", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ListLinkedInOrganizations", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// List LinkedIn orgs Fetch full organization details for custom UI. After LinkedIn OAuth in headless mode, the redirect URL only contains id, urn, and name fields. Use this endpoint to fetch full details including logos, vanity names, websites, and more. No authentication required, just the tempToken from the OAuth redirect. 
        /// </summary>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="tempToken">The temporary LinkedIn access token from the OAuth redirect</param>
        /// <param name="orgIds">Comma-separated list of organization IDs to fetch details for (max 100)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ListLinkedInOrganizations200Response</returns>
        public async System.Threading.Tasks.Task<ListLinkedInOrganizations200Response> ListLinkedInOrganizationsAsync(string tempToken, string orgIds, System.Threading.CancellationToken cancellationToken = default)
        {
            Late.Client.ApiResponse<ListLinkedInOrganizations200Response> localVarResponse = await ListLinkedInOrganizationsWithHttpInfoAsync(tempToken, orgIds, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// List LinkedIn orgs Fetch full organization details for custom UI. After LinkedIn OAuth in headless mode, the redirect URL only contains id, urn, and name fields. Use this endpoint to fetch full details including logos, vanity names, websites, and more. No authentication required, just the tempToken from the OAuth redirect. 
        /// </summary>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="tempToken">The temporary LinkedIn access token from the OAuth redirect</param>
        /// <param name="orgIds">Comma-separated list of organization IDs to fetch details for (max 100)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (ListLinkedInOrganizations200Response)</returns>
        public async System.Threading.Tasks.Task<Late.Client.ApiResponse<ListLinkedInOrganizations200Response>> ListLinkedInOrganizationsWithHttpInfoAsync(string tempToken, string orgIds, System.Threading.CancellationToken cancellationToken = default)
        {
            // verify the required parameter 'tempToken' is set
            if (tempToken == null)
                throw new Late.Client.ApiException(400, "Missing required parameter 'tempToken' when calling ConnectApi->ListLinkedInOrganizations");

            // verify the required parameter 'orgIds' is set
            if (orgIds == null)
                throw new Late.Client.ApiException(400, "Missing required parameter 'orgIds' when calling ConnectApi->ListLinkedInOrganizations");


            Late.Client.RequestOptions localVarRequestOptions = new Late.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };


            var localVarContentType = Late.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Late.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.QueryParameters.Add(Late.Client.ClientUtils.ParameterToMultiMap("", "tempToken", tempToken));
            localVarRequestOptions.QueryParameters.Add(Late.Client.ClientUtils.ParameterToMultiMap("", "orgIds", orgIds));

            // authentication (bearerAuth) required
            // bearer authentication required
            if (!string.IsNullOrEmpty(this.Configuration.AccessToken) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
            }

            // make the HTTP request

            var localVarResponse = await this.AsynchronousClient.GetAsync<ListLinkedInOrganizations200Response>("/v1/connect/linkedin/organizations", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ListLinkedInOrganizations", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// List Pinterest boards Retrieve Pinterest boards for headless selection UI. After Pinterest OAuth with headless&#x3D;true, you&#39;ll be redirected to your redirect_url with tempToken and userProfile params. Call this endpoint to retrieve the list of boards the user can post to, then build your UI and call POST /v1/connect/pinterest/select-board to save the selection. Use X-Connect-Token header with the connect_token from the redirect URL. 
        /// </summary>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="xConnectToken">Short-lived connect token from the OAuth redirect</param>
        /// <param name="profileId">Your Late profile ID</param>
        /// <param name="tempToken">Temporary Pinterest access token from the OAuth callback redirect</param>
        /// <returns>ListPinterestBoardsForSelection200Response</returns>
        public ListPinterestBoardsForSelection200Response ListPinterestBoardsForSelection(string xConnectToken, string profileId, string tempToken)
        {
            Late.Client.ApiResponse<ListPinterestBoardsForSelection200Response> localVarResponse = ListPinterestBoardsForSelectionWithHttpInfo(xConnectToken, profileId, tempToken);
            return localVarResponse.Data;
        }

        /// <summary>
        /// List Pinterest boards Retrieve Pinterest boards for headless selection UI. After Pinterest OAuth with headless&#x3D;true, you&#39;ll be redirected to your redirect_url with tempToken and userProfile params. Call this endpoint to retrieve the list of boards the user can post to, then build your UI and call POST /v1/connect/pinterest/select-board to save the selection. Use X-Connect-Token header with the connect_token from the redirect URL. 
        /// </summary>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="xConnectToken">Short-lived connect token from the OAuth redirect</param>
        /// <param name="profileId">Your Late profile ID</param>
        /// <param name="tempToken">Temporary Pinterest access token from the OAuth callback redirect</param>
        /// <returns>ApiResponse of ListPinterestBoardsForSelection200Response</returns>
        public Late.Client.ApiResponse<ListPinterestBoardsForSelection200Response> ListPinterestBoardsForSelectionWithHttpInfo(string xConnectToken, string profileId, string tempToken)
        {
            // verify the required parameter 'xConnectToken' is set
            if (xConnectToken == null)
                throw new Late.Client.ApiException(400, "Missing required parameter 'xConnectToken' when calling ConnectApi->ListPinterestBoardsForSelection");

            // verify the required parameter 'profileId' is set
            if (profileId == null)
                throw new Late.Client.ApiException(400, "Missing required parameter 'profileId' when calling ConnectApi->ListPinterestBoardsForSelection");

            // verify the required parameter 'tempToken' is set
            if (tempToken == null)
                throw new Late.Client.ApiException(400, "Missing required parameter 'tempToken' when calling ConnectApi->ListPinterestBoardsForSelection");

            Late.Client.RequestOptions localVarRequestOptions = new Late.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Late.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Late.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.QueryParameters.Add(Late.Client.ClientUtils.ParameterToMultiMap("", "profileId", profileId));
            localVarRequestOptions.QueryParameters.Add(Late.Client.ClientUtils.ParameterToMultiMap("", "tempToken", tempToken));
            localVarRequestOptions.HeaderParameters.Add("X-Connect-Token", Late.Client.ClientUtils.ParameterToString(xConnectToken)); // header parameter

            // authentication (bearerAuth) required
            // bearer authentication required
            if (!string.IsNullOrEmpty(this.Configuration.AccessToken) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
            }

            // make the HTTP request
            var localVarResponse = this.Client.Get<ListPinterestBoardsForSelection200Response>("/v1/connect/pinterest/select-board", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ListPinterestBoardsForSelection", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// List Pinterest boards Retrieve Pinterest boards for headless selection UI. After Pinterest OAuth with headless&#x3D;true, you&#39;ll be redirected to your redirect_url with tempToken and userProfile params. Call this endpoint to retrieve the list of boards the user can post to, then build your UI and call POST /v1/connect/pinterest/select-board to save the selection. Use X-Connect-Token header with the connect_token from the redirect URL. 
        /// </summary>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="xConnectToken">Short-lived connect token from the OAuth redirect</param>
        /// <param name="profileId">Your Late profile ID</param>
        /// <param name="tempToken">Temporary Pinterest access token from the OAuth callback redirect</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ListPinterestBoardsForSelection200Response</returns>
        public async System.Threading.Tasks.Task<ListPinterestBoardsForSelection200Response> ListPinterestBoardsForSelectionAsync(string xConnectToken, string profileId, string tempToken, System.Threading.CancellationToken cancellationToken = default)
        {
            Late.Client.ApiResponse<ListPinterestBoardsForSelection200Response> localVarResponse = await ListPinterestBoardsForSelectionWithHttpInfoAsync(xConnectToken, profileId, tempToken, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// List Pinterest boards Retrieve Pinterest boards for headless selection UI. After Pinterest OAuth with headless&#x3D;true, you&#39;ll be redirected to your redirect_url with tempToken and userProfile params. Call this endpoint to retrieve the list of boards the user can post to, then build your UI and call POST /v1/connect/pinterest/select-board to save the selection. Use X-Connect-Token header with the connect_token from the redirect URL. 
        /// </summary>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="xConnectToken">Short-lived connect token from the OAuth redirect</param>
        /// <param name="profileId">Your Late profile ID</param>
        /// <param name="tempToken">Temporary Pinterest access token from the OAuth callback redirect</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (ListPinterestBoardsForSelection200Response)</returns>
        public async System.Threading.Tasks.Task<Late.Client.ApiResponse<ListPinterestBoardsForSelection200Response>> ListPinterestBoardsForSelectionWithHttpInfoAsync(string xConnectToken, string profileId, string tempToken, System.Threading.CancellationToken cancellationToken = default)
        {
            // verify the required parameter 'xConnectToken' is set
            if (xConnectToken == null)
                throw new Late.Client.ApiException(400, "Missing required parameter 'xConnectToken' when calling ConnectApi->ListPinterestBoardsForSelection");

            // verify the required parameter 'profileId' is set
            if (profileId == null)
                throw new Late.Client.ApiException(400, "Missing required parameter 'profileId' when calling ConnectApi->ListPinterestBoardsForSelection");

            // verify the required parameter 'tempToken' is set
            if (tempToken == null)
                throw new Late.Client.ApiException(400, "Missing required parameter 'tempToken' when calling ConnectApi->ListPinterestBoardsForSelection");


            Late.Client.RequestOptions localVarRequestOptions = new Late.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };


            var localVarContentType = Late.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Late.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.QueryParameters.Add(Late.Client.ClientUtils.ParameterToMultiMap("", "profileId", profileId));
            localVarRequestOptions.QueryParameters.Add(Late.Client.ClientUtils.ParameterToMultiMap("", "tempToken", tempToken));
            localVarRequestOptions.HeaderParameters.Add("X-Connect-Token", Late.Client.ClientUtils.ParameterToString(xConnectToken)); // header parameter

            // authentication (bearerAuth) required
            // bearer authentication required
            if (!string.IsNullOrEmpty(this.Configuration.AccessToken) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
            }

            // make the HTTP request

            var localVarResponse = await this.AsynchronousClient.GetAsync<ListPinterestBoardsForSelection200Response>("/v1/connect/pinterest/select-board", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ListPinterestBoardsForSelection", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// List Snapchat profiles For headless/whitelabel flows. After Snapchat OAuth with headless&#x3D;true, you&#39;ll be redirected to your redirect_url with tempToken, userProfile, and publicProfiles params. Call this endpoint to retrieve the list of Snapchat Public Profiles the user can post to, then build your UI and call POST /v1/connect/snapchat/select-profile to save the selection. Use X-Connect-Token header with the connect_token from the redirect URL. 
        /// </summary>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="xConnectToken">Short-lived connect token from the OAuth redirect</param>
        /// <param name="profileId">Your Late profile ID</param>
        /// <param name="tempToken">Temporary Snapchat access token from the OAuth callback redirect</param>
        /// <returns>ListSnapchatProfiles200Response</returns>
        public ListSnapchatProfiles200Response ListSnapchatProfiles(string xConnectToken, string profileId, string tempToken)
        {
            Late.Client.ApiResponse<ListSnapchatProfiles200Response> localVarResponse = ListSnapchatProfilesWithHttpInfo(xConnectToken, profileId, tempToken);
            return localVarResponse.Data;
        }

        /// <summary>
        /// List Snapchat profiles For headless/whitelabel flows. After Snapchat OAuth with headless&#x3D;true, you&#39;ll be redirected to your redirect_url with tempToken, userProfile, and publicProfiles params. Call this endpoint to retrieve the list of Snapchat Public Profiles the user can post to, then build your UI and call POST /v1/connect/snapchat/select-profile to save the selection. Use X-Connect-Token header with the connect_token from the redirect URL. 
        /// </summary>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="xConnectToken">Short-lived connect token from the OAuth redirect</param>
        /// <param name="profileId">Your Late profile ID</param>
        /// <param name="tempToken">Temporary Snapchat access token from the OAuth callback redirect</param>
        /// <returns>ApiResponse of ListSnapchatProfiles200Response</returns>
        public Late.Client.ApiResponse<ListSnapchatProfiles200Response> ListSnapchatProfilesWithHttpInfo(string xConnectToken, string profileId, string tempToken)
        {
            // verify the required parameter 'xConnectToken' is set
            if (xConnectToken == null)
                throw new Late.Client.ApiException(400, "Missing required parameter 'xConnectToken' when calling ConnectApi->ListSnapchatProfiles");

            // verify the required parameter 'profileId' is set
            if (profileId == null)
                throw new Late.Client.ApiException(400, "Missing required parameter 'profileId' when calling ConnectApi->ListSnapchatProfiles");

            // verify the required parameter 'tempToken' is set
            if (tempToken == null)
                throw new Late.Client.ApiException(400, "Missing required parameter 'tempToken' when calling ConnectApi->ListSnapchatProfiles");

            Late.Client.RequestOptions localVarRequestOptions = new Late.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Late.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Late.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.QueryParameters.Add(Late.Client.ClientUtils.ParameterToMultiMap("", "profileId", profileId));
            localVarRequestOptions.QueryParameters.Add(Late.Client.ClientUtils.ParameterToMultiMap("", "tempToken", tempToken));
            localVarRequestOptions.HeaderParameters.Add("X-Connect-Token", Late.Client.ClientUtils.ParameterToString(xConnectToken)); // header parameter

            // authentication (bearerAuth) required
            // bearer authentication required
            if (!string.IsNullOrEmpty(this.Configuration.AccessToken) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
            }

            // make the HTTP request
            var localVarResponse = this.Client.Get<ListSnapchatProfiles200Response>("/v1/connect/snapchat/select-profile", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ListSnapchatProfiles", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// List Snapchat profiles For headless/whitelabel flows. After Snapchat OAuth with headless&#x3D;true, you&#39;ll be redirected to your redirect_url with tempToken, userProfile, and publicProfiles params. Call this endpoint to retrieve the list of Snapchat Public Profiles the user can post to, then build your UI and call POST /v1/connect/snapchat/select-profile to save the selection. Use X-Connect-Token header with the connect_token from the redirect URL. 
        /// </summary>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="xConnectToken">Short-lived connect token from the OAuth redirect</param>
        /// <param name="profileId">Your Late profile ID</param>
        /// <param name="tempToken">Temporary Snapchat access token from the OAuth callback redirect</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ListSnapchatProfiles200Response</returns>
        public async System.Threading.Tasks.Task<ListSnapchatProfiles200Response> ListSnapchatProfilesAsync(string xConnectToken, string profileId, string tempToken, System.Threading.CancellationToken cancellationToken = default)
        {
            Late.Client.ApiResponse<ListSnapchatProfiles200Response> localVarResponse = await ListSnapchatProfilesWithHttpInfoAsync(xConnectToken, profileId, tempToken, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// List Snapchat profiles For headless/whitelabel flows. After Snapchat OAuth with headless&#x3D;true, you&#39;ll be redirected to your redirect_url with tempToken, userProfile, and publicProfiles params. Call this endpoint to retrieve the list of Snapchat Public Profiles the user can post to, then build your UI and call POST /v1/connect/snapchat/select-profile to save the selection. Use X-Connect-Token header with the connect_token from the redirect URL. 
        /// </summary>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="xConnectToken">Short-lived connect token from the OAuth redirect</param>
        /// <param name="profileId">Your Late profile ID</param>
        /// <param name="tempToken">Temporary Snapchat access token from the OAuth callback redirect</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (ListSnapchatProfiles200Response)</returns>
        public async System.Threading.Tasks.Task<Late.Client.ApiResponse<ListSnapchatProfiles200Response>> ListSnapchatProfilesWithHttpInfoAsync(string xConnectToken, string profileId, string tempToken, System.Threading.CancellationToken cancellationToken = default)
        {
            // verify the required parameter 'xConnectToken' is set
            if (xConnectToken == null)
                throw new Late.Client.ApiException(400, "Missing required parameter 'xConnectToken' when calling ConnectApi->ListSnapchatProfiles");

            // verify the required parameter 'profileId' is set
            if (profileId == null)
                throw new Late.Client.ApiException(400, "Missing required parameter 'profileId' when calling ConnectApi->ListSnapchatProfiles");

            // verify the required parameter 'tempToken' is set
            if (tempToken == null)
                throw new Late.Client.ApiException(400, "Missing required parameter 'tempToken' when calling ConnectApi->ListSnapchatProfiles");


            Late.Client.RequestOptions localVarRequestOptions = new Late.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };


            var localVarContentType = Late.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Late.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.QueryParameters.Add(Late.Client.ClientUtils.ParameterToMultiMap("", "profileId", profileId));
            localVarRequestOptions.QueryParameters.Add(Late.Client.ClientUtils.ParameterToMultiMap("", "tempToken", tempToken));
            localVarRequestOptions.HeaderParameters.Add("X-Connect-Token", Late.Client.ClientUtils.ParameterToString(xConnectToken)); // header parameter

            // authentication (bearerAuth) required
            // bearer authentication required
            if (!string.IsNullOrEmpty(this.Configuration.AccessToken) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
            }

            // make the HTTP request

            var localVarResponse = await this.AsynchronousClient.GetAsync<ListSnapchatProfiles200Response>("/v1/connect/snapchat/select-profile", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ListSnapchatProfiles", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Select Facebook page Complete the headless flow. After displaying your custom UI with the list of pages from the GET endpoint, call this endpoint to finalize the connection with the user&#39;s selected page. The userProfile should be the decoded JSON object from the userProfile query param in the OAuth callback redirect URL. Use the X-Connect-Token header if you initiated the connection via API key. 
        /// </summary>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="selectFacebookPageRequest"></param>
        /// <returns>SelectFacebookPage200Response</returns>
        public SelectFacebookPage200Response SelectFacebookPage(SelectFacebookPageRequest selectFacebookPageRequest)
        {
            Late.Client.ApiResponse<SelectFacebookPage200Response> localVarResponse = SelectFacebookPageWithHttpInfo(selectFacebookPageRequest);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Select Facebook page Complete the headless flow. After displaying your custom UI with the list of pages from the GET endpoint, call this endpoint to finalize the connection with the user&#39;s selected page. The userProfile should be the decoded JSON object from the userProfile query param in the OAuth callback redirect URL. Use the X-Connect-Token header if you initiated the connection via API key. 
        /// </summary>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="selectFacebookPageRequest"></param>
        /// <returns>ApiResponse of SelectFacebookPage200Response</returns>
        public Late.Client.ApiResponse<SelectFacebookPage200Response> SelectFacebookPageWithHttpInfo(SelectFacebookPageRequest selectFacebookPageRequest)
        {
            // verify the required parameter 'selectFacebookPageRequest' is set
            if (selectFacebookPageRequest == null)
                throw new Late.Client.ApiException(400, "Missing required parameter 'selectFacebookPageRequest' when calling ConnectApi->SelectFacebookPage");

            Late.Client.RequestOptions localVarRequestOptions = new Late.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Late.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Late.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.Data = selectFacebookPageRequest;

            // authentication (connectToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("X-Connect-Token")))
            {
                localVarRequestOptions.HeaderParameters.Add("X-Connect-Token", this.Configuration.GetApiKeyWithPrefix("X-Connect-Token"));
            }
            // authentication (bearerAuth) required
            // bearer authentication required
            if (!string.IsNullOrEmpty(this.Configuration.AccessToken) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
            }

            // make the HTTP request
            var localVarResponse = this.Client.Post<SelectFacebookPage200Response>("/v1/connect/facebook/select-page", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("SelectFacebookPage", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Select Facebook page Complete the headless flow. After displaying your custom UI with the list of pages from the GET endpoint, call this endpoint to finalize the connection with the user&#39;s selected page. The userProfile should be the decoded JSON object from the userProfile query param in the OAuth callback redirect URL. Use the X-Connect-Token header if you initiated the connection via API key. 
        /// </summary>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="selectFacebookPageRequest"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of SelectFacebookPage200Response</returns>
        public async System.Threading.Tasks.Task<SelectFacebookPage200Response> SelectFacebookPageAsync(SelectFacebookPageRequest selectFacebookPageRequest, System.Threading.CancellationToken cancellationToken = default)
        {
            Late.Client.ApiResponse<SelectFacebookPage200Response> localVarResponse = await SelectFacebookPageWithHttpInfoAsync(selectFacebookPageRequest, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Select Facebook page Complete the headless flow. After displaying your custom UI with the list of pages from the GET endpoint, call this endpoint to finalize the connection with the user&#39;s selected page. The userProfile should be the decoded JSON object from the userProfile query param in the OAuth callback redirect URL. Use the X-Connect-Token header if you initiated the connection via API key. 
        /// </summary>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="selectFacebookPageRequest"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (SelectFacebookPage200Response)</returns>
        public async System.Threading.Tasks.Task<Late.Client.ApiResponse<SelectFacebookPage200Response>> SelectFacebookPageWithHttpInfoAsync(SelectFacebookPageRequest selectFacebookPageRequest, System.Threading.CancellationToken cancellationToken = default)
        {
            // verify the required parameter 'selectFacebookPageRequest' is set
            if (selectFacebookPageRequest == null)
                throw new Late.Client.ApiException(400, "Missing required parameter 'selectFacebookPageRequest' when calling ConnectApi->SelectFacebookPage");


            Late.Client.RequestOptions localVarRequestOptions = new Late.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };


            var localVarContentType = Late.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Late.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.Data = selectFacebookPageRequest;

            // authentication (connectToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("X-Connect-Token")))
            {
                localVarRequestOptions.HeaderParameters.Add("X-Connect-Token", this.Configuration.GetApiKeyWithPrefix("X-Connect-Token"));
            }
            // authentication (bearerAuth) required
            // bearer authentication required
            if (!string.IsNullOrEmpty(this.Configuration.AccessToken) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
            }

            // make the HTTP request

            var localVarResponse = await this.AsynchronousClient.PostAsync<SelectFacebookPage200Response>("/v1/connect/facebook/select-page", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("SelectFacebookPage", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Select GBP location Complete the headless flow. After displaying your custom UI with the list of locations from the GET /v1/connect/googlebusiness/locations endpoint, call this endpoint to finalize the connection with the user&#39;s selected location. The userProfile should be the decoded JSON object from the userProfile query param in the OAuth callback redirect URL. It contains important token information including the refresh token. Use the X-Connect-Token header if you initiated the connection via API key. 
        /// </summary>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="selectGoogleBusinessLocationRequest"></param>
        /// <returns>SelectGoogleBusinessLocation200Response</returns>
        public SelectGoogleBusinessLocation200Response SelectGoogleBusinessLocation(SelectGoogleBusinessLocationRequest selectGoogleBusinessLocationRequest)
        {
            Late.Client.ApiResponse<SelectGoogleBusinessLocation200Response> localVarResponse = SelectGoogleBusinessLocationWithHttpInfo(selectGoogleBusinessLocationRequest);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Select GBP location Complete the headless flow. After displaying your custom UI with the list of locations from the GET /v1/connect/googlebusiness/locations endpoint, call this endpoint to finalize the connection with the user&#39;s selected location. The userProfile should be the decoded JSON object from the userProfile query param in the OAuth callback redirect URL. It contains important token information including the refresh token. Use the X-Connect-Token header if you initiated the connection via API key. 
        /// </summary>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="selectGoogleBusinessLocationRequest"></param>
        /// <returns>ApiResponse of SelectGoogleBusinessLocation200Response</returns>
        public Late.Client.ApiResponse<SelectGoogleBusinessLocation200Response> SelectGoogleBusinessLocationWithHttpInfo(SelectGoogleBusinessLocationRequest selectGoogleBusinessLocationRequest)
        {
            // verify the required parameter 'selectGoogleBusinessLocationRequest' is set
            if (selectGoogleBusinessLocationRequest == null)
                throw new Late.Client.ApiException(400, "Missing required parameter 'selectGoogleBusinessLocationRequest' when calling ConnectApi->SelectGoogleBusinessLocation");

            Late.Client.RequestOptions localVarRequestOptions = new Late.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Late.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Late.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.Data = selectGoogleBusinessLocationRequest;

            // authentication (connectToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("X-Connect-Token")))
            {
                localVarRequestOptions.HeaderParameters.Add("X-Connect-Token", this.Configuration.GetApiKeyWithPrefix("X-Connect-Token"));
            }
            // authentication (bearerAuth) required
            // bearer authentication required
            if (!string.IsNullOrEmpty(this.Configuration.AccessToken) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
            }

            // make the HTTP request
            var localVarResponse = this.Client.Post<SelectGoogleBusinessLocation200Response>("/v1/connect/googlebusiness/select-location", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("SelectGoogleBusinessLocation", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Select GBP location Complete the headless flow. After displaying your custom UI with the list of locations from the GET /v1/connect/googlebusiness/locations endpoint, call this endpoint to finalize the connection with the user&#39;s selected location. The userProfile should be the decoded JSON object from the userProfile query param in the OAuth callback redirect URL. It contains important token information including the refresh token. Use the X-Connect-Token header if you initiated the connection via API key. 
        /// </summary>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="selectGoogleBusinessLocationRequest"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of SelectGoogleBusinessLocation200Response</returns>
        public async System.Threading.Tasks.Task<SelectGoogleBusinessLocation200Response> SelectGoogleBusinessLocationAsync(SelectGoogleBusinessLocationRequest selectGoogleBusinessLocationRequest, System.Threading.CancellationToken cancellationToken = default)
        {
            Late.Client.ApiResponse<SelectGoogleBusinessLocation200Response> localVarResponse = await SelectGoogleBusinessLocationWithHttpInfoAsync(selectGoogleBusinessLocationRequest, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Select GBP location Complete the headless flow. After displaying your custom UI with the list of locations from the GET /v1/connect/googlebusiness/locations endpoint, call this endpoint to finalize the connection with the user&#39;s selected location. The userProfile should be the decoded JSON object from the userProfile query param in the OAuth callback redirect URL. It contains important token information including the refresh token. Use the X-Connect-Token header if you initiated the connection via API key. 
        /// </summary>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="selectGoogleBusinessLocationRequest"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (SelectGoogleBusinessLocation200Response)</returns>
        public async System.Threading.Tasks.Task<Late.Client.ApiResponse<SelectGoogleBusinessLocation200Response>> SelectGoogleBusinessLocationWithHttpInfoAsync(SelectGoogleBusinessLocationRequest selectGoogleBusinessLocationRequest, System.Threading.CancellationToken cancellationToken = default)
        {
            // verify the required parameter 'selectGoogleBusinessLocationRequest' is set
            if (selectGoogleBusinessLocationRequest == null)
                throw new Late.Client.ApiException(400, "Missing required parameter 'selectGoogleBusinessLocationRequest' when calling ConnectApi->SelectGoogleBusinessLocation");


            Late.Client.RequestOptions localVarRequestOptions = new Late.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };


            var localVarContentType = Late.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Late.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.Data = selectGoogleBusinessLocationRequest;

            // authentication (connectToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("X-Connect-Token")))
            {
                localVarRequestOptions.HeaderParameters.Add("X-Connect-Token", this.Configuration.GetApiKeyWithPrefix("X-Connect-Token"));
            }
            // authentication (bearerAuth) required
            // bearer authentication required
            if (!string.IsNullOrEmpty(this.Configuration.AccessToken) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
            }

            // make the HTTP request

            var localVarResponse = await this.AsynchronousClient.PostAsync<SelectGoogleBusinessLocation200Response>("/v1/connect/googlebusiness/select-location", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("SelectGoogleBusinessLocation", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Select LinkedIn org Complete the LinkedIn connection flow. After OAuth, the user is redirected with organizations in the URL params (if they have org admin access). Use this data to build your UI, then call this endpoint to save the selection. Set accountType to \&quot;personal\&quot; for a personal profile (omit selectedOrganization), or \&quot;organization\&quot; to connect as a company page. Use the X-Connect-Token header if you initiated the connection via API key. 
        /// </summary>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="selectLinkedInOrganizationRequest"></param>
        /// <returns>SelectLinkedInOrganization200Response</returns>
        public SelectLinkedInOrganization200Response SelectLinkedInOrganization(SelectLinkedInOrganizationRequest selectLinkedInOrganizationRequest)
        {
            Late.Client.ApiResponse<SelectLinkedInOrganization200Response> localVarResponse = SelectLinkedInOrganizationWithHttpInfo(selectLinkedInOrganizationRequest);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Select LinkedIn org Complete the LinkedIn connection flow. After OAuth, the user is redirected with organizations in the URL params (if they have org admin access). Use this data to build your UI, then call this endpoint to save the selection. Set accountType to \&quot;personal\&quot; for a personal profile (omit selectedOrganization), or \&quot;organization\&quot; to connect as a company page. Use the X-Connect-Token header if you initiated the connection via API key. 
        /// </summary>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="selectLinkedInOrganizationRequest"></param>
        /// <returns>ApiResponse of SelectLinkedInOrganization200Response</returns>
        public Late.Client.ApiResponse<SelectLinkedInOrganization200Response> SelectLinkedInOrganizationWithHttpInfo(SelectLinkedInOrganizationRequest selectLinkedInOrganizationRequest)
        {
            // verify the required parameter 'selectLinkedInOrganizationRequest' is set
            if (selectLinkedInOrganizationRequest == null)
                throw new Late.Client.ApiException(400, "Missing required parameter 'selectLinkedInOrganizationRequest' when calling ConnectApi->SelectLinkedInOrganization");

            Late.Client.RequestOptions localVarRequestOptions = new Late.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Late.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Late.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.Data = selectLinkedInOrganizationRequest;

            // authentication (bearerAuth) required
            // bearer authentication required
            if (!string.IsNullOrEmpty(this.Configuration.AccessToken) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
            }

            // make the HTTP request
            var localVarResponse = this.Client.Post<SelectLinkedInOrganization200Response>("/v1/connect/linkedin/select-organization", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("SelectLinkedInOrganization", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Select LinkedIn org Complete the LinkedIn connection flow. After OAuth, the user is redirected with organizations in the URL params (if they have org admin access). Use this data to build your UI, then call this endpoint to save the selection. Set accountType to \&quot;personal\&quot; for a personal profile (omit selectedOrganization), or \&quot;organization\&quot; to connect as a company page. Use the X-Connect-Token header if you initiated the connection via API key. 
        /// </summary>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="selectLinkedInOrganizationRequest"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of SelectLinkedInOrganization200Response</returns>
        public async System.Threading.Tasks.Task<SelectLinkedInOrganization200Response> SelectLinkedInOrganizationAsync(SelectLinkedInOrganizationRequest selectLinkedInOrganizationRequest, System.Threading.CancellationToken cancellationToken = default)
        {
            Late.Client.ApiResponse<SelectLinkedInOrganization200Response> localVarResponse = await SelectLinkedInOrganizationWithHttpInfoAsync(selectLinkedInOrganizationRequest, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Select LinkedIn org Complete the LinkedIn connection flow. After OAuth, the user is redirected with organizations in the URL params (if they have org admin access). Use this data to build your UI, then call this endpoint to save the selection. Set accountType to \&quot;personal\&quot; for a personal profile (omit selectedOrganization), or \&quot;organization\&quot; to connect as a company page. Use the X-Connect-Token header if you initiated the connection via API key. 
        /// </summary>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="selectLinkedInOrganizationRequest"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (SelectLinkedInOrganization200Response)</returns>
        public async System.Threading.Tasks.Task<Late.Client.ApiResponse<SelectLinkedInOrganization200Response>> SelectLinkedInOrganizationWithHttpInfoAsync(SelectLinkedInOrganizationRequest selectLinkedInOrganizationRequest, System.Threading.CancellationToken cancellationToken = default)
        {
            // verify the required parameter 'selectLinkedInOrganizationRequest' is set
            if (selectLinkedInOrganizationRequest == null)
                throw new Late.Client.ApiException(400, "Missing required parameter 'selectLinkedInOrganizationRequest' when calling ConnectApi->SelectLinkedInOrganization");


            Late.Client.RequestOptions localVarRequestOptions = new Late.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };


            var localVarContentType = Late.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Late.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.Data = selectLinkedInOrganizationRequest;

            // authentication (bearerAuth) required
            // bearer authentication required
            if (!string.IsNullOrEmpty(this.Configuration.AccessToken) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
            }

            // make the HTTP request

            var localVarResponse = await this.AsynchronousClient.PostAsync<SelectLinkedInOrganization200Response>("/v1/connect/linkedin/select-organization", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("SelectLinkedInOrganization", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Select Pinterest board Complete the Pinterest connection flow. After OAuth, use this endpoint to save the selected board and complete the account connection. Use the X-Connect-Token header if you initiated the connection via API key. 
        /// </summary>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="selectPinterestBoardRequest"></param>
        /// <returns>SelectPinterestBoard200Response</returns>
        public SelectPinterestBoard200Response SelectPinterestBoard(SelectPinterestBoardRequest selectPinterestBoardRequest)
        {
            Late.Client.ApiResponse<SelectPinterestBoard200Response> localVarResponse = SelectPinterestBoardWithHttpInfo(selectPinterestBoardRequest);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Select Pinterest board Complete the Pinterest connection flow. After OAuth, use this endpoint to save the selected board and complete the account connection. Use the X-Connect-Token header if you initiated the connection via API key. 
        /// </summary>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="selectPinterestBoardRequest"></param>
        /// <returns>ApiResponse of SelectPinterestBoard200Response</returns>
        public Late.Client.ApiResponse<SelectPinterestBoard200Response> SelectPinterestBoardWithHttpInfo(SelectPinterestBoardRequest selectPinterestBoardRequest)
        {
            // verify the required parameter 'selectPinterestBoardRequest' is set
            if (selectPinterestBoardRequest == null)
                throw new Late.Client.ApiException(400, "Missing required parameter 'selectPinterestBoardRequest' when calling ConnectApi->SelectPinterestBoard");

            Late.Client.RequestOptions localVarRequestOptions = new Late.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Late.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Late.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.Data = selectPinterestBoardRequest;

            // authentication (bearerAuth) required
            // bearer authentication required
            if (!string.IsNullOrEmpty(this.Configuration.AccessToken) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
            }

            // make the HTTP request
            var localVarResponse = this.Client.Post<SelectPinterestBoard200Response>("/v1/connect/pinterest/select-board", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("SelectPinterestBoard", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Select Pinterest board Complete the Pinterest connection flow. After OAuth, use this endpoint to save the selected board and complete the account connection. Use the X-Connect-Token header if you initiated the connection via API key. 
        /// </summary>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="selectPinterestBoardRequest"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of SelectPinterestBoard200Response</returns>
        public async System.Threading.Tasks.Task<SelectPinterestBoard200Response> SelectPinterestBoardAsync(SelectPinterestBoardRequest selectPinterestBoardRequest, System.Threading.CancellationToken cancellationToken = default)
        {
            Late.Client.ApiResponse<SelectPinterestBoard200Response> localVarResponse = await SelectPinterestBoardWithHttpInfoAsync(selectPinterestBoardRequest, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Select Pinterest board Complete the Pinterest connection flow. After OAuth, use this endpoint to save the selected board and complete the account connection. Use the X-Connect-Token header if you initiated the connection via API key. 
        /// </summary>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="selectPinterestBoardRequest"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (SelectPinterestBoard200Response)</returns>
        public async System.Threading.Tasks.Task<Late.Client.ApiResponse<SelectPinterestBoard200Response>> SelectPinterestBoardWithHttpInfoAsync(SelectPinterestBoardRequest selectPinterestBoardRequest, System.Threading.CancellationToken cancellationToken = default)
        {
            // verify the required parameter 'selectPinterestBoardRequest' is set
            if (selectPinterestBoardRequest == null)
                throw new Late.Client.ApiException(400, "Missing required parameter 'selectPinterestBoardRequest' when calling ConnectApi->SelectPinterestBoard");


            Late.Client.RequestOptions localVarRequestOptions = new Late.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };


            var localVarContentType = Late.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Late.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.Data = selectPinterestBoardRequest;

            // authentication (bearerAuth) required
            // bearer authentication required
            if (!string.IsNullOrEmpty(this.Configuration.AccessToken) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
            }

            // make the HTTP request

            var localVarResponse = await this.AsynchronousClient.PostAsync<SelectPinterestBoard200Response>("/v1/connect/pinterest/select-board", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("SelectPinterestBoard", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Select Snapchat profile Complete the Snapchat connection flow. Save the selected Public Profile and complete the account connection. Snapchat requires a Public Profile to publish Stories, Saved Stories, and Spotlight content. After Snapchat OAuth with headless&#x3D;true, you&#39;ll be redirected with tempToken, userProfile, publicProfiles, connect_token, platform&#x3D;snapchat, and step&#x3D;select_public_profile in the URL. Parse publicProfiles to build your custom selector UI, then call this endpoint with the selected profile. Use the X-Connect-Token header if you initiated the connection via API key. 
        /// </summary>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="selectSnapchatProfileRequest"></param>
        /// <param name="xConnectToken">Short-lived connect token from the OAuth redirect (for API users) (optional)</param>
        /// <returns>SelectSnapchatProfile200Response</returns>
        public SelectSnapchatProfile200Response SelectSnapchatProfile(SelectSnapchatProfileRequest selectSnapchatProfileRequest, string? xConnectToken = default)
        {
            Late.Client.ApiResponse<SelectSnapchatProfile200Response> localVarResponse = SelectSnapchatProfileWithHttpInfo(selectSnapchatProfileRequest, xConnectToken);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Select Snapchat profile Complete the Snapchat connection flow. Save the selected Public Profile and complete the account connection. Snapchat requires a Public Profile to publish Stories, Saved Stories, and Spotlight content. After Snapchat OAuth with headless&#x3D;true, you&#39;ll be redirected with tempToken, userProfile, publicProfiles, connect_token, platform&#x3D;snapchat, and step&#x3D;select_public_profile in the URL. Parse publicProfiles to build your custom selector UI, then call this endpoint with the selected profile. Use the X-Connect-Token header if you initiated the connection via API key. 
        /// </summary>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="selectSnapchatProfileRequest"></param>
        /// <param name="xConnectToken">Short-lived connect token from the OAuth redirect (for API users) (optional)</param>
        /// <returns>ApiResponse of SelectSnapchatProfile200Response</returns>
        public Late.Client.ApiResponse<SelectSnapchatProfile200Response> SelectSnapchatProfileWithHttpInfo(SelectSnapchatProfileRequest selectSnapchatProfileRequest, string? xConnectToken = default)
        {
            // verify the required parameter 'selectSnapchatProfileRequest' is set
            if (selectSnapchatProfileRequest == null)
                throw new Late.Client.ApiException(400, "Missing required parameter 'selectSnapchatProfileRequest' when calling ConnectApi->SelectSnapchatProfile");

            Late.Client.RequestOptions localVarRequestOptions = new Late.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Late.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Late.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            if (xConnectToken != null)
            {
                localVarRequestOptions.HeaderParameters.Add("X-Connect-Token", Late.Client.ClientUtils.ParameterToString(xConnectToken)); // header parameter
            }
            localVarRequestOptions.Data = selectSnapchatProfileRequest;

            // authentication (bearerAuth) required
            // bearer authentication required
            if (!string.IsNullOrEmpty(this.Configuration.AccessToken) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
            }

            // make the HTTP request
            var localVarResponse = this.Client.Post<SelectSnapchatProfile200Response>("/v1/connect/snapchat/select-profile", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("SelectSnapchatProfile", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Select Snapchat profile Complete the Snapchat connection flow. Save the selected Public Profile and complete the account connection. Snapchat requires a Public Profile to publish Stories, Saved Stories, and Spotlight content. After Snapchat OAuth with headless&#x3D;true, you&#39;ll be redirected with tempToken, userProfile, publicProfiles, connect_token, platform&#x3D;snapchat, and step&#x3D;select_public_profile in the URL. Parse publicProfiles to build your custom selector UI, then call this endpoint with the selected profile. Use the X-Connect-Token header if you initiated the connection via API key. 
        /// </summary>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="selectSnapchatProfileRequest"></param>
        /// <param name="xConnectToken">Short-lived connect token from the OAuth redirect (for API users) (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of SelectSnapchatProfile200Response</returns>
        public async System.Threading.Tasks.Task<SelectSnapchatProfile200Response> SelectSnapchatProfileAsync(SelectSnapchatProfileRequest selectSnapchatProfileRequest, string? xConnectToken = default, System.Threading.CancellationToken cancellationToken = default)
        {
            Late.Client.ApiResponse<SelectSnapchatProfile200Response> localVarResponse = await SelectSnapchatProfileWithHttpInfoAsync(selectSnapchatProfileRequest, xConnectToken, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Select Snapchat profile Complete the Snapchat connection flow. Save the selected Public Profile and complete the account connection. Snapchat requires a Public Profile to publish Stories, Saved Stories, and Spotlight content. After Snapchat OAuth with headless&#x3D;true, you&#39;ll be redirected with tempToken, userProfile, publicProfiles, connect_token, platform&#x3D;snapchat, and step&#x3D;select_public_profile in the URL. Parse publicProfiles to build your custom selector UI, then call this endpoint with the selected profile. Use the X-Connect-Token header if you initiated the connection via API key. 
        /// </summary>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="selectSnapchatProfileRequest"></param>
        /// <param name="xConnectToken">Short-lived connect token from the OAuth redirect (for API users) (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (SelectSnapchatProfile200Response)</returns>
        public async System.Threading.Tasks.Task<Late.Client.ApiResponse<SelectSnapchatProfile200Response>> SelectSnapchatProfileWithHttpInfoAsync(SelectSnapchatProfileRequest selectSnapchatProfileRequest, string? xConnectToken = default, System.Threading.CancellationToken cancellationToken = default)
        {
            // verify the required parameter 'selectSnapchatProfileRequest' is set
            if (selectSnapchatProfileRequest == null)
                throw new Late.Client.ApiException(400, "Missing required parameter 'selectSnapchatProfileRequest' when calling ConnectApi->SelectSnapchatProfile");


            Late.Client.RequestOptions localVarRequestOptions = new Late.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };


            var localVarContentType = Late.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Late.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            if (xConnectToken != null)
            {
                localVarRequestOptions.HeaderParameters.Add("X-Connect-Token", Late.Client.ClientUtils.ParameterToString(xConnectToken)); // header parameter
            }
            localVarRequestOptions.Data = selectSnapchatProfileRequest;

            // authentication (bearerAuth) required
            // bearer authentication required
            if (!string.IsNullOrEmpty(this.Configuration.AccessToken) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
            }

            // make the HTTP request

            var localVarResponse = await this.AsynchronousClient.PostAsync<SelectSnapchatProfile200Response>("/v1/connect/snapchat/select-profile", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("SelectSnapchatProfile", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Update Facebook page 
        /// </summary>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="accountId"></param>
        /// <param name="updateFacebookPageRequest"></param>
        /// <returns>UpdateFacebookPage200Response</returns>
        public UpdateFacebookPage200Response UpdateFacebookPage(string accountId, UpdateFacebookPageRequest updateFacebookPageRequest)
        {
            Late.Client.ApiResponse<UpdateFacebookPage200Response> localVarResponse = UpdateFacebookPageWithHttpInfo(accountId, updateFacebookPageRequest);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Update Facebook page 
        /// </summary>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="accountId"></param>
        /// <param name="updateFacebookPageRequest"></param>
        /// <returns>ApiResponse of UpdateFacebookPage200Response</returns>
        public Late.Client.ApiResponse<UpdateFacebookPage200Response> UpdateFacebookPageWithHttpInfo(string accountId, UpdateFacebookPageRequest updateFacebookPageRequest)
        {
            // verify the required parameter 'accountId' is set
            if (accountId == null)
                throw new Late.Client.ApiException(400, "Missing required parameter 'accountId' when calling ConnectApi->UpdateFacebookPage");

            // verify the required parameter 'updateFacebookPageRequest' is set
            if (updateFacebookPageRequest == null)
                throw new Late.Client.ApiException(400, "Missing required parameter 'updateFacebookPageRequest' when calling ConnectApi->UpdateFacebookPage");

            Late.Client.RequestOptions localVarRequestOptions = new Late.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Late.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Late.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("accountId", Late.Client.ClientUtils.ParameterToString(accountId)); // path parameter
            localVarRequestOptions.Data = updateFacebookPageRequest;

            // authentication (bearerAuth) required
            // bearer authentication required
            if (!string.IsNullOrEmpty(this.Configuration.AccessToken) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
            }

            // make the HTTP request
            var localVarResponse = this.Client.Put<UpdateFacebookPage200Response>("/v1/accounts/{accountId}/facebook-page", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateFacebookPage", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Update Facebook page 
        /// </summary>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="accountId"></param>
        /// <param name="updateFacebookPageRequest"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of UpdateFacebookPage200Response</returns>
        public async System.Threading.Tasks.Task<UpdateFacebookPage200Response> UpdateFacebookPageAsync(string accountId, UpdateFacebookPageRequest updateFacebookPageRequest, System.Threading.CancellationToken cancellationToken = default)
        {
            Late.Client.ApiResponse<UpdateFacebookPage200Response> localVarResponse = await UpdateFacebookPageWithHttpInfoAsync(accountId, updateFacebookPageRequest, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Update Facebook page 
        /// </summary>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="accountId"></param>
        /// <param name="updateFacebookPageRequest"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (UpdateFacebookPage200Response)</returns>
        public async System.Threading.Tasks.Task<Late.Client.ApiResponse<UpdateFacebookPage200Response>> UpdateFacebookPageWithHttpInfoAsync(string accountId, UpdateFacebookPageRequest updateFacebookPageRequest, System.Threading.CancellationToken cancellationToken = default)
        {
            // verify the required parameter 'accountId' is set
            if (accountId == null)
                throw new Late.Client.ApiException(400, "Missing required parameter 'accountId' when calling ConnectApi->UpdateFacebookPage");

            // verify the required parameter 'updateFacebookPageRequest' is set
            if (updateFacebookPageRequest == null)
                throw new Late.Client.ApiException(400, "Missing required parameter 'updateFacebookPageRequest' when calling ConnectApi->UpdateFacebookPage");


            Late.Client.RequestOptions localVarRequestOptions = new Late.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };


            var localVarContentType = Late.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Late.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("accountId", Late.Client.ClientUtils.ParameterToString(accountId)); // path parameter
            localVarRequestOptions.Data = updateFacebookPageRequest;

            // authentication (bearerAuth) required
            // bearer authentication required
            if (!string.IsNullOrEmpty(this.Configuration.AccessToken) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
            }

            // make the HTTP request

            var localVarResponse = await this.AsynchronousClient.PutAsync<UpdateFacebookPage200Response>("/v1/accounts/{accountId}/facebook-page", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateFacebookPage", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Update GBP location 
        /// </summary>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="accountId"></param>
        /// <param name="updateGmbLocationRequest"></param>
        /// <returns>UpdateGmbLocation200Response</returns>
        public UpdateGmbLocation200Response UpdateGmbLocation(string accountId, UpdateGmbLocationRequest updateGmbLocationRequest)
        {
            Late.Client.ApiResponse<UpdateGmbLocation200Response> localVarResponse = UpdateGmbLocationWithHttpInfo(accountId, updateGmbLocationRequest);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Update GBP location 
        /// </summary>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="accountId"></param>
        /// <param name="updateGmbLocationRequest"></param>
        /// <returns>ApiResponse of UpdateGmbLocation200Response</returns>
        public Late.Client.ApiResponse<UpdateGmbLocation200Response> UpdateGmbLocationWithHttpInfo(string accountId, UpdateGmbLocationRequest updateGmbLocationRequest)
        {
            // verify the required parameter 'accountId' is set
            if (accountId == null)
                throw new Late.Client.ApiException(400, "Missing required parameter 'accountId' when calling ConnectApi->UpdateGmbLocation");

            // verify the required parameter 'updateGmbLocationRequest' is set
            if (updateGmbLocationRequest == null)
                throw new Late.Client.ApiException(400, "Missing required parameter 'updateGmbLocationRequest' when calling ConnectApi->UpdateGmbLocation");

            Late.Client.RequestOptions localVarRequestOptions = new Late.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Late.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Late.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("accountId", Late.Client.ClientUtils.ParameterToString(accountId)); // path parameter
            localVarRequestOptions.Data = updateGmbLocationRequest;

            // authentication (bearerAuth) required
            // bearer authentication required
            if (!string.IsNullOrEmpty(this.Configuration.AccessToken) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
            }

            // make the HTTP request
            var localVarResponse = this.Client.Put<UpdateGmbLocation200Response>("/v1/accounts/{accountId}/gmb-locations", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateGmbLocation", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Update GBP location 
        /// </summary>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="accountId"></param>
        /// <param name="updateGmbLocationRequest"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of UpdateGmbLocation200Response</returns>
        public async System.Threading.Tasks.Task<UpdateGmbLocation200Response> UpdateGmbLocationAsync(string accountId, UpdateGmbLocationRequest updateGmbLocationRequest, System.Threading.CancellationToken cancellationToken = default)
        {
            Late.Client.ApiResponse<UpdateGmbLocation200Response> localVarResponse = await UpdateGmbLocationWithHttpInfoAsync(accountId, updateGmbLocationRequest, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Update GBP location 
        /// </summary>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="accountId"></param>
        /// <param name="updateGmbLocationRequest"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (UpdateGmbLocation200Response)</returns>
        public async System.Threading.Tasks.Task<Late.Client.ApiResponse<UpdateGmbLocation200Response>> UpdateGmbLocationWithHttpInfoAsync(string accountId, UpdateGmbLocationRequest updateGmbLocationRequest, System.Threading.CancellationToken cancellationToken = default)
        {
            // verify the required parameter 'accountId' is set
            if (accountId == null)
                throw new Late.Client.ApiException(400, "Missing required parameter 'accountId' when calling ConnectApi->UpdateGmbLocation");

            // verify the required parameter 'updateGmbLocationRequest' is set
            if (updateGmbLocationRequest == null)
                throw new Late.Client.ApiException(400, "Missing required parameter 'updateGmbLocationRequest' when calling ConnectApi->UpdateGmbLocation");


            Late.Client.RequestOptions localVarRequestOptions = new Late.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };


            var localVarContentType = Late.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Late.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("accountId", Late.Client.ClientUtils.ParameterToString(accountId)); // path parameter
            localVarRequestOptions.Data = updateGmbLocationRequest;

            // authentication (bearerAuth) required
            // bearer authentication required
            if (!string.IsNullOrEmpty(this.Configuration.AccessToken) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
            }

            // make the HTTP request

            var localVarResponse = await this.AsynchronousClient.PutAsync<UpdateGmbLocation200Response>("/v1/accounts/{accountId}/gmb-locations", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateGmbLocation", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Switch LinkedIn account type 
        /// </summary>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="accountId"></param>
        /// <param name="updateLinkedInOrganizationRequest"></param>
        /// <returns>ConnectBlueskyCredentials200Response</returns>
        public ConnectBlueskyCredentials200Response UpdateLinkedInOrganization(string accountId, UpdateLinkedInOrganizationRequest updateLinkedInOrganizationRequest)
        {
            Late.Client.ApiResponse<ConnectBlueskyCredentials200Response> localVarResponse = UpdateLinkedInOrganizationWithHttpInfo(accountId, updateLinkedInOrganizationRequest);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Switch LinkedIn account type 
        /// </summary>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="accountId"></param>
        /// <param name="updateLinkedInOrganizationRequest"></param>
        /// <returns>ApiResponse of ConnectBlueskyCredentials200Response</returns>
        public Late.Client.ApiResponse<ConnectBlueskyCredentials200Response> UpdateLinkedInOrganizationWithHttpInfo(string accountId, UpdateLinkedInOrganizationRequest updateLinkedInOrganizationRequest)
        {
            // verify the required parameter 'accountId' is set
            if (accountId == null)
                throw new Late.Client.ApiException(400, "Missing required parameter 'accountId' when calling ConnectApi->UpdateLinkedInOrganization");

            // verify the required parameter 'updateLinkedInOrganizationRequest' is set
            if (updateLinkedInOrganizationRequest == null)
                throw new Late.Client.ApiException(400, "Missing required parameter 'updateLinkedInOrganizationRequest' when calling ConnectApi->UpdateLinkedInOrganization");

            Late.Client.RequestOptions localVarRequestOptions = new Late.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Late.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Late.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("accountId", Late.Client.ClientUtils.ParameterToString(accountId)); // path parameter
            localVarRequestOptions.Data = updateLinkedInOrganizationRequest;

            // authentication (bearerAuth) required
            // bearer authentication required
            if (!string.IsNullOrEmpty(this.Configuration.AccessToken) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
            }

            // make the HTTP request
            var localVarResponse = this.Client.Put<ConnectBlueskyCredentials200Response>("/v1/accounts/{accountId}/linkedin-organization", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateLinkedInOrganization", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Switch LinkedIn account type 
        /// </summary>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="accountId"></param>
        /// <param name="updateLinkedInOrganizationRequest"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ConnectBlueskyCredentials200Response</returns>
        public async System.Threading.Tasks.Task<ConnectBlueskyCredentials200Response> UpdateLinkedInOrganizationAsync(string accountId, UpdateLinkedInOrganizationRequest updateLinkedInOrganizationRequest, System.Threading.CancellationToken cancellationToken = default)
        {
            Late.Client.ApiResponse<ConnectBlueskyCredentials200Response> localVarResponse = await UpdateLinkedInOrganizationWithHttpInfoAsync(accountId, updateLinkedInOrganizationRequest, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Switch LinkedIn account type 
        /// </summary>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="accountId"></param>
        /// <param name="updateLinkedInOrganizationRequest"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (ConnectBlueskyCredentials200Response)</returns>
        public async System.Threading.Tasks.Task<Late.Client.ApiResponse<ConnectBlueskyCredentials200Response>> UpdateLinkedInOrganizationWithHttpInfoAsync(string accountId, UpdateLinkedInOrganizationRequest updateLinkedInOrganizationRequest, System.Threading.CancellationToken cancellationToken = default)
        {
            // verify the required parameter 'accountId' is set
            if (accountId == null)
                throw new Late.Client.ApiException(400, "Missing required parameter 'accountId' when calling ConnectApi->UpdateLinkedInOrganization");

            // verify the required parameter 'updateLinkedInOrganizationRequest' is set
            if (updateLinkedInOrganizationRequest == null)
                throw new Late.Client.ApiException(400, "Missing required parameter 'updateLinkedInOrganizationRequest' when calling ConnectApi->UpdateLinkedInOrganization");


            Late.Client.RequestOptions localVarRequestOptions = new Late.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };


            var localVarContentType = Late.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Late.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("accountId", Late.Client.ClientUtils.ParameterToString(accountId)); // path parameter
            localVarRequestOptions.Data = updateLinkedInOrganizationRequest;

            // authentication (bearerAuth) required
            // bearer authentication required
            if (!string.IsNullOrEmpty(this.Configuration.AccessToken) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
            }

            // make the HTTP request

            var localVarResponse = await this.AsynchronousClient.PutAsync<ConnectBlueskyCredentials200Response>("/v1/accounts/{accountId}/linkedin-organization", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateLinkedInOrganization", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Set default Pinterest board 
        /// </summary>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="accountId"></param>
        /// <param name="updatePinterestBoardsRequest"></param>
        /// <returns>ConnectBlueskyCredentials200Response</returns>
        public ConnectBlueskyCredentials200Response UpdatePinterestBoards(string accountId, UpdatePinterestBoardsRequest updatePinterestBoardsRequest)
        {
            Late.Client.ApiResponse<ConnectBlueskyCredentials200Response> localVarResponse = UpdatePinterestBoardsWithHttpInfo(accountId, updatePinterestBoardsRequest);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Set default Pinterest board 
        /// </summary>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="accountId"></param>
        /// <param name="updatePinterestBoardsRequest"></param>
        /// <returns>ApiResponse of ConnectBlueskyCredentials200Response</returns>
        public Late.Client.ApiResponse<ConnectBlueskyCredentials200Response> UpdatePinterestBoardsWithHttpInfo(string accountId, UpdatePinterestBoardsRequest updatePinterestBoardsRequest)
        {
            // verify the required parameter 'accountId' is set
            if (accountId == null)
                throw new Late.Client.ApiException(400, "Missing required parameter 'accountId' when calling ConnectApi->UpdatePinterestBoards");

            // verify the required parameter 'updatePinterestBoardsRequest' is set
            if (updatePinterestBoardsRequest == null)
                throw new Late.Client.ApiException(400, "Missing required parameter 'updatePinterestBoardsRequest' when calling ConnectApi->UpdatePinterestBoards");

            Late.Client.RequestOptions localVarRequestOptions = new Late.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Late.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Late.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("accountId", Late.Client.ClientUtils.ParameterToString(accountId)); // path parameter
            localVarRequestOptions.Data = updatePinterestBoardsRequest;

            // authentication (bearerAuth) required
            // bearer authentication required
            if (!string.IsNullOrEmpty(this.Configuration.AccessToken) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
            }

            // make the HTTP request
            var localVarResponse = this.Client.Put<ConnectBlueskyCredentials200Response>("/v1/accounts/{accountId}/pinterest-boards", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdatePinterestBoards", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Set default Pinterest board 
        /// </summary>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="accountId"></param>
        /// <param name="updatePinterestBoardsRequest"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ConnectBlueskyCredentials200Response</returns>
        public async System.Threading.Tasks.Task<ConnectBlueskyCredentials200Response> UpdatePinterestBoardsAsync(string accountId, UpdatePinterestBoardsRequest updatePinterestBoardsRequest, System.Threading.CancellationToken cancellationToken = default)
        {
            Late.Client.ApiResponse<ConnectBlueskyCredentials200Response> localVarResponse = await UpdatePinterestBoardsWithHttpInfoAsync(accountId, updatePinterestBoardsRequest, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Set default Pinterest board 
        /// </summary>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="accountId"></param>
        /// <param name="updatePinterestBoardsRequest"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (ConnectBlueskyCredentials200Response)</returns>
        public async System.Threading.Tasks.Task<Late.Client.ApiResponse<ConnectBlueskyCredentials200Response>> UpdatePinterestBoardsWithHttpInfoAsync(string accountId, UpdatePinterestBoardsRequest updatePinterestBoardsRequest, System.Threading.CancellationToken cancellationToken = default)
        {
            // verify the required parameter 'accountId' is set
            if (accountId == null)
                throw new Late.Client.ApiException(400, "Missing required parameter 'accountId' when calling ConnectApi->UpdatePinterestBoards");

            // verify the required parameter 'updatePinterestBoardsRequest' is set
            if (updatePinterestBoardsRequest == null)
                throw new Late.Client.ApiException(400, "Missing required parameter 'updatePinterestBoardsRequest' when calling ConnectApi->UpdatePinterestBoards");


            Late.Client.RequestOptions localVarRequestOptions = new Late.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };


            var localVarContentType = Late.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Late.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("accountId", Late.Client.ClientUtils.ParameterToString(accountId)); // path parameter
            localVarRequestOptions.Data = updatePinterestBoardsRequest;

            // authentication (bearerAuth) required
            // bearer authentication required
            if (!string.IsNullOrEmpty(this.Configuration.AccessToken) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
            }

            // make the HTTP request

            var localVarResponse = await this.AsynchronousClient.PutAsync<ConnectBlueskyCredentials200Response>("/v1/accounts/{accountId}/pinterest-boards", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdatePinterestBoards", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Set default subreddit 
        /// </summary>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="accountId"></param>
        /// <param name="updateRedditSubredditsRequest"></param>
        /// <returns>UpdateRedditSubreddits200Response</returns>
        public UpdateRedditSubreddits200Response UpdateRedditSubreddits(string accountId, UpdateRedditSubredditsRequest updateRedditSubredditsRequest)
        {
            Late.Client.ApiResponse<UpdateRedditSubreddits200Response> localVarResponse = UpdateRedditSubredditsWithHttpInfo(accountId, updateRedditSubredditsRequest);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Set default subreddit 
        /// </summary>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="accountId"></param>
        /// <param name="updateRedditSubredditsRequest"></param>
        /// <returns>ApiResponse of UpdateRedditSubreddits200Response</returns>
        public Late.Client.ApiResponse<UpdateRedditSubreddits200Response> UpdateRedditSubredditsWithHttpInfo(string accountId, UpdateRedditSubredditsRequest updateRedditSubredditsRequest)
        {
            // verify the required parameter 'accountId' is set
            if (accountId == null)
                throw new Late.Client.ApiException(400, "Missing required parameter 'accountId' when calling ConnectApi->UpdateRedditSubreddits");

            // verify the required parameter 'updateRedditSubredditsRequest' is set
            if (updateRedditSubredditsRequest == null)
                throw new Late.Client.ApiException(400, "Missing required parameter 'updateRedditSubredditsRequest' when calling ConnectApi->UpdateRedditSubreddits");

            Late.Client.RequestOptions localVarRequestOptions = new Late.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Late.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Late.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("accountId", Late.Client.ClientUtils.ParameterToString(accountId)); // path parameter
            localVarRequestOptions.Data = updateRedditSubredditsRequest;

            // authentication (bearerAuth) required
            // bearer authentication required
            if (!string.IsNullOrEmpty(this.Configuration.AccessToken) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
            }

            // make the HTTP request
            var localVarResponse = this.Client.Put<UpdateRedditSubreddits200Response>("/v1/accounts/{accountId}/reddit-subreddits", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateRedditSubreddits", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Set default subreddit 
        /// </summary>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="accountId"></param>
        /// <param name="updateRedditSubredditsRequest"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of UpdateRedditSubreddits200Response</returns>
        public async System.Threading.Tasks.Task<UpdateRedditSubreddits200Response> UpdateRedditSubredditsAsync(string accountId, UpdateRedditSubredditsRequest updateRedditSubredditsRequest, System.Threading.CancellationToken cancellationToken = default)
        {
            Late.Client.ApiResponse<UpdateRedditSubreddits200Response> localVarResponse = await UpdateRedditSubredditsWithHttpInfoAsync(accountId, updateRedditSubredditsRequest, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Set default subreddit 
        /// </summary>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="accountId"></param>
        /// <param name="updateRedditSubredditsRequest"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (UpdateRedditSubreddits200Response)</returns>
        public async System.Threading.Tasks.Task<Late.Client.ApiResponse<UpdateRedditSubreddits200Response>> UpdateRedditSubredditsWithHttpInfoAsync(string accountId, UpdateRedditSubredditsRequest updateRedditSubredditsRequest, System.Threading.CancellationToken cancellationToken = default)
        {
            // verify the required parameter 'accountId' is set
            if (accountId == null)
                throw new Late.Client.ApiException(400, "Missing required parameter 'accountId' when calling ConnectApi->UpdateRedditSubreddits");

            // verify the required parameter 'updateRedditSubredditsRequest' is set
            if (updateRedditSubredditsRequest == null)
                throw new Late.Client.ApiException(400, "Missing required parameter 'updateRedditSubredditsRequest' when calling ConnectApi->UpdateRedditSubreddits");


            Late.Client.RequestOptions localVarRequestOptions = new Late.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };


            var localVarContentType = Late.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Late.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("accountId", Late.Client.ClientUtils.ParameterToString(accountId)); // path parameter
            localVarRequestOptions.Data = updateRedditSubredditsRequest;

            // authentication (bearerAuth) required
            // bearer authentication required
            if (!string.IsNullOrEmpty(this.Configuration.AccessToken) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
            }

            // make the HTTP request

            var localVarResponse = await this.AsynchronousClient.PutAsync<UpdateRedditSubreddits200Response>("/v1/accounts/{accountId}/reddit-subreddits", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateRedditSubreddits", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

    }
}
