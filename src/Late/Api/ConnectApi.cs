/*
 * Late API
 *
 * API reference for Late. Authenticate with a Bearer API key. Base URL: https://getlate.dev/api 
 *
 * The version of the OpenAPI document: 1.0.0
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */


using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Linq;
using System.Net;
using System.Net.Http;
using System.Net.Mime;
using Late.Client;
using Late.Model;

namespace Late.Api
{

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public interface IConnectApiSync : IApiAccessor
    {
        #region Synchronous Operations
        /// <summary>
        /// Check Telegram connection status
        /// </summary>
        /// <remarks>
        /// Poll this endpoint to check if a Telegram access code has been used to connect a channel/group.  **Recommended polling interval:** 3 seconds  **Status values:** - &#x60;pending&#x60;: Code is valid, waiting for user to complete connection - &#x60;connected&#x60;: Connection successful - channel/group is now linked - &#x60;expired&#x60;: Code has expired, generate a new one 
        /// </remarks>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="code">The access code to check status for</param>
        /// <returns>CompleteTelegramConnect200Response</returns>
        CompleteTelegramConnect200Response CompleteTelegramConnect(string code);

        /// <summary>
        /// Check Telegram connection status
        /// </summary>
        /// <remarks>
        /// Poll this endpoint to check if a Telegram access code has been used to connect a channel/group.  **Recommended polling interval:** 3 seconds  **Status values:** - &#x60;pending&#x60;: Code is valid, waiting for user to complete connection - &#x60;connected&#x60;: Connection successful - channel/group is now linked - &#x60;expired&#x60;: Code has expired, generate a new one 
        /// </remarks>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="code">The access code to check status for</param>
        /// <returns>ApiResponse of CompleteTelegramConnect200Response</returns>
        ApiResponse<CompleteTelegramConnect200Response> CompleteTelegramConnectWithHttpInfo(string code);
        /// <summary>
        /// Connect Bluesky using app password
        /// </summary>
        /// <remarks>
        /// Connect a Bluesky account using identifier (handle or email) and an app password.  To get your userId for the state parameter, call &#x60;GET /v1/users&#x60; - the response includes a &#x60;currentUserId&#x60; field. 
        /// </remarks>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="connectBlueskyCredentialsRequest"></param>
        /// <returns>ConnectBlueskyCredentials200Response</returns>
        ConnectBlueskyCredentials200Response ConnectBlueskyCredentials(ConnectBlueskyCredentialsRequest connectBlueskyCredentialsRequest);

        /// <summary>
        /// Connect Bluesky using app password
        /// </summary>
        /// <remarks>
        /// Connect a Bluesky account using identifier (handle or email) and an app password.  To get your userId for the state parameter, call &#x60;GET /v1/users&#x60; - the response includes a &#x60;currentUserId&#x60; field. 
        /// </remarks>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="connectBlueskyCredentialsRequest"></param>
        /// <returns>ApiResponse of ConnectBlueskyCredentials200Response</returns>
        ApiResponse<ConnectBlueskyCredentials200Response> ConnectBlueskyCredentialsWithHttpInfo(ConnectBlueskyCredentialsRequest connectBlueskyCredentialsRequest);
        /// <summary>
        /// Start OAuth connection for a platform
        /// </summary>
        /// <remarks>
        /// Initiate an OAuth connection flow for any supported social media platform.  **Standard Flow (Hosted UI):** For Facebook connections, Late hosts the page selection UI:  1. Call this endpoint with your API key and &#x60;redirect_url&#x60; (optional) 2. Redirect your user to the returned &#x60;authUrl&#x60; 3. After OAuth, the user is redirected to Late’s hosted page selector at      &#x60;/connect/facebook/select-page?profileId&#x3D;X&amp;tempToken&#x3D;Y&amp;userProfile&#x3D;Z&amp;redirect_url&#x3D;YOUR_URL&amp;connect_token&#x3D;CT&#x60; 4. After they pick a page, Late saves the connection and finally redirects to your &#x60;redirect_url&#x60; (if provided)  **Headless/Whitelabel Mode (Facebook, LinkedIn, Pinterest &amp; Google Business Profile):** Build your own fully branded selection UI while Late handles OAuth:  **Facebook:** 1. Call this endpoint with your API key and add &#x60;&amp;headless&#x3D;true&#x60;, e.g.      &#x60;GET /v1/connect/facebook?profileId&#x3D;PROFILE_ID&amp;redirect_url&#x3D;https://yourapp.com/callback&amp;headless&#x3D;true&#x60; 2. Redirect your user to the returned &#x60;authUrl&#x60; 3. After OAuth, the user is redirected directly to **your** &#x60;redirect_url&#x60; with:    - &#x60;profileId&#x60; – your Late profile ID      - &#x60;tempToken&#x60; – temporary Facebook access token      - &#x60;userProfile&#x60; – URL‑encoded JSON user profile      - &#x60;connect_token&#x60; – short‑lived connect token (for API auth)      - &#x60;platform&#x3D;facebook&#x60;      - &#x60;step&#x3D;select_page&#x60; 4. Use &#x60;tempToken&#x60;, &#x60;userProfile&#x60;, and the &#x60;X-Connect-Token&#x60; header with:    - &#x60;GET /v1/connect/facebook/select-page&#x60; to fetch pages    - &#x60;POST /v1/connect/facebook/select-page&#x60; to save the selected page 5. In this mode, users never see Late&#39;s hosted page selector – only your UI.  **LinkedIn:** 1. Call this endpoint with &#x60;&amp;headless&#x3D;true&#x60;, e.g.    &#x60;GET /v1/connect/linkedin?profileId&#x3D;PROFILE_ID&amp;redirect_url&#x3D;https://yourapp.com/callback&amp;headless&#x3D;true&#x60; 2. Redirect your user to the returned &#x60;authUrl&#x60; 3. After OAuth, the user is redirected directly to **your** &#x60;redirect_url&#x60; with:    - &#x60;profileId&#x60; – your Late profile ID    - &#x60;pendingDataToken&#x60; – token to fetch OAuth data via API (see step 4)    - &#x60;connect_token&#x60; – short-lived connect token (for API auth)    - &#x60;platform&#x3D;linkedin&#x60;    - &#x60;step&#x3D;select_organization&#x60; 4. Call &#x60;GET /v1/connect/pending-data?token&#x3D;PENDING_DATA_TOKEN&#x60; to fetch the OAuth data:    - &#x60;tempToken&#x60; – temporary LinkedIn access token    - &#x60;userProfile&#x60; – JSON object with &#x60;id&#x60;, &#x60;username&#x60;, &#x60;displayName&#x60;, &#x60;profilePicture&#x60;    - &#x60;organizations&#x60; – JSON array with &#x60;id&#x60;, &#x60;urn&#x60;, &#x60;name&#x60;, &#x60;vanityName&#x60; for each org    - &#x60;refreshToken&#x60; / &#x60;expiresIn&#x60; – token metadata    This endpoint is one-time use and data expires after 10 minutes. 5. **Optional:** To fetch full organization details (logos, website, industry, description), call &#x60;GET /v1/connect/linkedin/organizations?tempToken&#x3D;X&amp;orgIds&#x3D;id1,id2,...&#x60; 6. Call &#x60;POST /v1/connect/linkedin/select-organization&#x60; with the &#x60;X-Connect-Token&#x60; header to save the selection. 7. In this mode, users never see Late&#39;s hosted organization selector – only your UI. 8. Note: If the user has no organization admin access, &#x60;step&#x3D;select_organization&#x60; will NOT be present,    and the account will be connected directly as a personal account.  **Pinterest:** 1. Call this endpoint with &#x60;&amp;headless&#x3D;true&#x60;, e.g.    &#x60;GET /v1/connect/pinterest?profileId&#x3D;PROFILE_ID&amp;redirect_url&#x3D;https://yourapp.com/callback&amp;headless&#x3D;true&#x60; 2. Redirect your user to the returned &#x60;authUrl&#x60; 3. After OAuth, the user is redirected directly to **your** &#x60;redirect_url&#x60; with:    - &#x60;profileId&#x60; – your Late profile ID    - &#x60;tempToken&#x60; – temporary Pinterest access token    - &#x60;userProfile&#x60; – URL‑encoded JSON user profile    - &#x60;connect_token&#x60; – short‑lived connect token (for API auth)    - &#x60;platform&#x3D;pinterest&#x60;    - &#x60;step&#x3D;select_board&#x60; 4. Use &#x60;tempToken&#x60;, &#x60;userProfile&#x60;, and the &#x60;X-Connect-Token&#x60; header with:    - &#x60;GET /v1/connect/pinterest/select-board&#x60; to fetch boards    - &#x60;POST /v1/connect/pinterest/select-board&#x60; to save the selected board 5. In this mode, users never see Late&#39;s hosted board selector – only your UI.  **Google Business Profile:** 1. Call this endpoint with &#x60;&amp;headless&#x3D;true&#x60;, e.g.    &#x60;GET /v1/connect/googlebusiness?profileId&#x3D;PROFILE_ID&amp;redirect_url&#x3D;https://yourapp.com/callback&amp;headless&#x3D;true&#x60; 2. Redirect your user to the returned &#x60;authUrl&#x60; 3. After OAuth, the user is redirected directly to **your** &#x60;redirect_url&#x60; with:    - &#x60;profileId&#x60; – your Late profile ID    - &#x60;tempToken&#x60; – temporary Google access token    - &#x60;userProfile&#x60; – URL‑encoded JSON user profile (includes refresh token info)    - &#x60;connect_token&#x60; – short‑lived connect token (for API auth)    - &#x60;platform&#x3D;googlebusiness&#x60;    - &#x60;step&#x3D;select_location&#x60; 4. Use &#x60;tempToken&#x60;, &#x60;userProfile&#x60;, and the &#x60;X-Connect-Token&#x60; header with:    - &#x60;GET /v1/connect/googlebusiness/locations&#x60; to fetch business locations    - &#x60;POST /v1/connect/googlebusiness/select-location&#x60; to save the selected location 5. In this mode, users never see Late&#39;s hosted location selector – only your UI. 
        /// </remarks>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="platform">Social media platform to connect</param>
        /// <param name="profileId">Your Late profile ID (get from /v1/profiles)</param>
        /// <param name="redirectUrl">Optional: Your custom redirect URL after connection completes.  **Standard Mode:** Omit &#x60;headless&#x3D;true&#x60; to use our hosted page selection UI.   After the user selects a Facebook Page, Late redirects here with:   &#x60;?connected&#x3D;facebook&amp;profileId&#x3D;X&amp;username&#x3D;Y&#x60;  **Headless Mode (Facebook, LinkedIn, Pinterest, Google Business Profile &amp; Snapchat):** Pass &#x60;headless&#x3D;true&#x60; as a query parameter on this endpoint (not inside &#x60;redirect_url&#x60;), e.g.: &#x60;GET /v1/connect/facebook?profileId&#x3D;PROFILE_ID&amp;redirect_url&#x3D;https://yourapp.com/callback&amp;headless&#x3D;true&#x60; &#x60;GET /v1/connect/linkedin?profileId&#x3D;PROFILE_ID&amp;redirect_url&#x3D;https://yourapp.com/callback&amp;headless&#x3D;true&#x60; &#x60;GET /v1/connect/pinterest?profileId&#x3D;PROFILE_ID&amp;redirect_url&#x3D;https://yourapp.com/callback&amp;headless&#x3D;true&#x60; &#x60;GET /v1/connect/googlebusiness?profileId&#x3D;PROFILE_ID&amp;redirect_url&#x3D;https://yourapp.com/callback&amp;headless&#x3D;true&#x60; &#x60;GET /v1/connect/snapchat?profileId&#x3D;PROFILE_ID&amp;redirect_url&#x3D;https://yourapp.com/callback&amp;headless&#x3D;true&#x60;  After OAuth, the user is redirected directly to your &#x60;redirect_url&#x60; with OAuth data: - **Facebook:** &#x60;?profileId&#x3D;X&amp;tempToken&#x3D;Y&amp;userProfile&#x3D;Z&amp;connect_token&#x3D;CT&amp;platform&#x3D;facebook&amp;step&#x3D;select_page&#x60; - **LinkedIn:** &#x60;?profileId&#x3D;X&amp;pendingDataToken&#x3D;TOKEN&amp;connect_token&#x3D;CT&amp;platform&#x3D;linkedin&amp;step&#x3D;select_organization&#x60;   Use &#x60;GET /v1/connect/pending-data?token&#x3D;TOKEN&#x60; to fetch tempToken, userProfile, organizations, refreshToken. - **Pinterest:** &#x60;?profileId&#x3D;X&amp;tempToken&#x3D;Y&amp;userProfile&#x3D;Z&amp;connect_token&#x3D;CT&amp;platform&#x3D;pinterest&amp;step&#x3D;select_board&#x60; - **Google Business:** &#x60;?profileId&#x3D;X&amp;tempToken&#x3D;Y&amp;userProfile&#x3D;Z&amp;connect_token&#x3D;CT&amp;platform&#x3D;googlebusiness&amp;step&#x3D;select_location&#x60; - **Snapchat:** &#x60;?profileId&#x3D;X&amp;tempToken&#x3D;Y&amp;userProfile&#x3D;Z&amp;publicProfiles&#x3D;PROFILES&amp;connect_token&#x3D;CT&amp;platform&#x3D;snapchat&amp;step&#x3D;select_public_profile&#x60;   (publicProfiles contains &#x60;id&#x60;, &#x60;display_name&#x60;, &#x60;username&#x60;, &#x60;profile_image_url&#x60;, &#x60;subscriber_count&#x60;)  Then use the respective endpoints to build your custom UI: - Facebook: &#x60;/v1/connect/facebook/select-page&#x60; (GET to fetch, POST to save) - LinkedIn: &#x60;/v1/connect/linkedin/organizations&#x60; (GET to fetch logos), &#x60;/v1/connect/linkedin/select-organization&#x60; (POST to save) - Pinterest: &#x60;/v1/connect/pinterest/select-board&#x60; (GET to fetch, POST to save) - Google Business: &#x60;/v1/connect/googlebusiness/locations&#x60; (GET) and &#x60;/v1/connect/googlebusiness/select-location&#x60; (POST) - Snapchat: &#x60;/v1/connect/snapchat/select-profile&#x60; (POST to save selected public profile)  Example: &#x60;https://yourdomain.com/integrations/callback&#x60;  (optional)</param>
        /// <returns>GetConnectUrl200Response</returns>
        GetConnectUrl200Response GetConnectUrl(string platform, string profileId, string? redirectUrl = default);

        /// <summary>
        /// Start OAuth connection for a platform
        /// </summary>
        /// <remarks>
        /// Initiate an OAuth connection flow for any supported social media platform.  **Standard Flow (Hosted UI):** For Facebook connections, Late hosts the page selection UI:  1. Call this endpoint with your API key and &#x60;redirect_url&#x60; (optional) 2. Redirect your user to the returned &#x60;authUrl&#x60; 3. After OAuth, the user is redirected to Late’s hosted page selector at      &#x60;/connect/facebook/select-page?profileId&#x3D;X&amp;tempToken&#x3D;Y&amp;userProfile&#x3D;Z&amp;redirect_url&#x3D;YOUR_URL&amp;connect_token&#x3D;CT&#x60; 4. After they pick a page, Late saves the connection and finally redirects to your &#x60;redirect_url&#x60; (if provided)  **Headless/Whitelabel Mode (Facebook, LinkedIn, Pinterest &amp; Google Business Profile):** Build your own fully branded selection UI while Late handles OAuth:  **Facebook:** 1. Call this endpoint with your API key and add &#x60;&amp;headless&#x3D;true&#x60;, e.g.      &#x60;GET /v1/connect/facebook?profileId&#x3D;PROFILE_ID&amp;redirect_url&#x3D;https://yourapp.com/callback&amp;headless&#x3D;true&#x60; 2. Redirect your user to the returned &#x60;authUrl&#x60; 3. After OAuth, the user is redirected directly to **your** &#x60;redirect_url&#x60; with:    - &#x60;profileId&#x60; – your Late profile ID      - &#x60;tempToken&#x60; – temporary Facebook access token      - &#x60;userProfile&#x60; – URL‑encoded JSON user profile      - &#x60;connect_token&#x60; – short‑lived connect token (for API auth)      - &#x60;platform&#x3D;facebook&#x60;      - &#x60;step&#x3D;select_page&#x60; 4. Use &#x60;tempToken&#x60;, &#x60;userProfile&#x60;, and the &#x60;X-Connect-Token&#x60; header with:    - &#x60;GET /v1/connect/facebook/select-page&#x60; to fetch pages    - &#x60;POST /v1/connect/facebook/select-page&#x60; to save the selected page 5. In this mode, users never see Late&#39;s hosted page selector – only your UI.  **LinkedIn:** 1. Call this endpoint with &#x60;&amp;headless&#x3D;true&#x60;, e.g.    &#x60;GET /v1/connect/linkedin?profileId&#x3D;PROFILE_ID&amp;redirect_url&#x3D;https://yourapp.com/callback&amp;headless&#x3D;true&#x60; 2. Redirect your user to the returned &#x60;authUrl&#x60; 3. After OAuth, the user is redirected directly to **your** &#x60;redirect_url&#x60; with:    - &#x60;profileId&#x60; – your Late profile ID    - &#x60;pendingDataToken&#x60; – token to fetch OAuth data via API (see step 4)    - &#x60;connect_token&#x60; – short-lived connect token (for API auth)    - &#x60;platform&#x3D;linkedin&#x60;    - &#x60;step&#x3D;select_organization&#x60; 4. Call &#x60;GET /v1/connect/pending-data?token&#x3D;PENDING_DATA_TOKEN&#x60; to fetch the OAuth data:    - &#x60;tempToken&#x60; – temporary LinkedIn access token    - &#x60;userProfile&#x60; – JSON object with &#x60;id&#x60;, &#x60;username&#x60;, &#x60;displayName&#x60;, &#x60;profilePicture&#x60;    - &#x60;organizations&#x60; – JSON array with &#x60;id&#x60;, &#x60;urn&#x60;, &#x60;name&#x60;, &#x60;vanityName&#x60; for each org    - &#x60;refreshToken&#x60; / &#x60;expiresIn&#x60; – token metadata    This endpoint is one-time use and data expires after 10 minutes. 5. **Optional:** To fetch full organization details (logos, website, industry, description), call &#x60;GET /v1/connect/linkedin/organizations?tempToken&#x3D;X&amp;orgIds&#x3D;id1,id2,...&#x60; 6. Call &#x60;POST /v1/connect/linkedin/select-organization&#x60; with the &#x60;X-Connect-Token&#x60; header to save the selection. 7. In this mode, users never see Late&#39;s hosted organization selector – only your UI. 8. Note: If the user has no organization admin access, &#x60;step&#x3D;select_organization&#x60; will NOT be present,    and the account will be connected directly as a personal account.  **Pinterest:** 1. Call this endpoint with &#x60;&amp;headless&#x3D;true&#x60;, e.g.    &#x60;GET /v1/connect/pinterest?profileId&#x3D;PROFILE_ID&amp;redirect_url&#x3D;https://yourapp.com/callback&amp;headless&#x3D;true&#x60; 2. Redirect your user to the returned &#x60;authUrl&#x60; 3. After OAuth, the user is redirected directly to **your** &#x60;redirect_url&#x60; with:    - &#x60;profileId&#x60; – your Late profile ID    - &#x60;tempToken&#x60; – temporary Pinterest access token    - &#x60;userProfile&#x60; – URL‑encoded JSON user profile    - &#x60;connect_token&#x60; – short‑lived connect token (for API auth)    - &#x60;platform&#x3D;pinterest&#x60;    - &#x60;step&#x3D;select_board&#x60; 4. Use &#x60;tempToken&#x60;, &#x60;userProfile&#x60;, and the &#x60;X-Connect-Token&#x60; header with:    - &#x60;GET /v1/connect/pinterest/select-board&#x60; to fetch boards    - &#x60;POST /v1/connect/pinterest/select-board&#x60; to save the selected board 5. In this mode, users never see Late&#39;s hosted board selector – only your UI.  **Google Business Profile:** 1. Call this endpoint with &#x60;&amp;headless&#x3D;true&#x60;, e.g.    &#x60;GET /v1/connect/googlebusiness?profileId&#x3D;PROFILE_ID&amp;redirect_url&#x3D;https://yourapp.com/callback&amp;headless&#x3D;true&#x60; 2. Redirect your user to the returned &#x60;authUrl&#x60; 3. After OAuth, the user is redirected directly to **your** &#x60;redirect_url&#x60; with:    - &#x60;profileId&#x60; – your Late profile ID    - &#x60;tempToken&#x60; – temporary Google access token    - &#x60;userProfile&#x60; – URL‑encoded JSON user profile (includes refresh token info)    - &#x60;connect_token&#x60; – short‑lived connect token (for API auth)    - &#x60;platform&#x3D;googlebusiness&#x60;    - &#x60;step&#x3D;select_location&#x60; 4. Use &#x60;tempToken&#x60;, &#x60;userProfile&#x60;, and the &#x60;X-Connect-Token&#x60; header with:    - &#x60;GET /v1/connect/googlebusiness/locations&#x60; to fetch business locations    - &#x60;POST /v1/connect/googlebusiness/select-location&#x60; to save the selected location 5. In this mode, users never see Late&#39;s hosted location selector – only your UI. 
        /// </remarks>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="platform">Social media platform to connect</param>
        /// <param name="profileId">Your Late profile ID (get from /v1/profiles)</param>
        /// <param name="redirectUrl">Optional: Your custom redirect URL after connection completes.  **Standard Mode:** Omit &#x60;headless&#x3D;true&#x60; to use our hosted page selection UI.   After the user selects a Facebook Page, Late redirects here with:   &#x60;?connected&#x3D;facebook&amp;profileId&#x3D;X&amp;username&#x3D;Y&#x60;  **Headless Mode (Facebook, LinkedIn, Pinterest, Google Business Profile &amp; Snapchat):** Pass &#x60;headless&#x3D;true&#x60; as a query parameter on this endpoint (not inside &#x60;redirect_url&#x60;), e.g.: &#x60;GET /v1/connect/facebook?profileId&#x3D;PROFILE_ID&amp;redirect_url&#x3D;https://yourapp.com/callback&amp;headless&#x3D;true&#x60; &#x60;GET /v1/connect/linkedin?profileId&#x3D;PROFILE_ID&amp;redirect_url&#x3D;https://yourapp.com/callback&amp;headless&#x3D;true&#x60; &#x60;GET /v1/connect/pinterest?profileId&#x3D;PROFILE_ID&amp;redirect_url&#x3D;https://yourapp.com/callback&amp;headless&#x3D;true&#x60; &#x60;GET /v1/connect/googlebusiness?profileId&#x3D;PROFILE_ID&amp;redirect_url&#x3D;https://yourapp.com/callback&amp;headless&#x3D;true&#x60; &#x60;GET /v1/connect/snapchat?profileId&#x3D;PROFILE_ID&amp;redirect_url&#x3D;https://yourapp.com/callback&amp;headless&#x3D;true&#x60;  After OAuth, the user is redirected directly to your &#x60;redirect_url&#x60; with OAuth data: - **Facebook:** &#x60;?profileId&#x3D;X&amp;tempToken&#x3D;Y&amp;userProfile&#x3D;Z&amp;connect_token&#x3D;CT&amp;platform&#x3D;facebook&amp;step&#x3D;select_page&#x60; - **LinkedIn:** &#x60;?profileId&#x3D;X&amp;pendingDataToken&#x3D;TOKEN&amp;connect_token&#x3D;CT&amp;platform&#x3D;linkedin&amp;step&#x3D;select_organization&#x60;   Use &#x60;GET /v1/connect/pending-data?token&#x3D;TOKEN&#x60; to fetch tempToken, userProfile, organizations, refreshToken. - **Pinterest:** &#x60;?profileId&#x3D;X&amp;tempToken&#x3D;Y&amp;userProfile&#x3D;Z&amp;connect_token&#x3D;CT&amp;platform&#x3D;pinterest&amp;step&#x3D;select_board&#x60; - **Google Business:** &#x60;?profileId&#x3D;X&amp;tempToken&#x3D;Y&amp;userProfile&#x3D;Z&amp;connect_token&#x3D;CT&amp;platform&#x3D;googlebusiness&amp;step&#x3D;select_location&#x60; - **Snapchat:** &#x60;?profileId&#x3D;X&amp;tempToken&#x3D;Y&amp;userProfile&#x3D;Z&amp;publicProfiles&#x3D;PROFILES&amp;connect_token&#x3D;CT&amp;platform&#x3D;snapchat&amp;step&#x3D;select_public_profile&#x60;   (publicProfiles contains &#x60;id&#x60;, &#x60;display_name&#x60;, &#x60;username&#x60;, &#x60;profile_image_url&#x60;, &#x60;subscriber_count&#x60;)  Then use the respective endpoints to build your custom UI: - Facebook: &#x60;/v1/connect/facebook/select-page&#x60; (GET to fetch, POST to save) - LinkedIn: &#x60;/v1/connect/linkedin/organizations&#x60; (GET to fetch logos), &#x60;/v1/connect/linkedin/select-organization&#x60; (POST to save) - Pinterest: &#x60;/v1/connect/pinterest/select-board&#x60; (GET to fetch, POST to save) - Google Business: &#x60;/v1/connect/googlebusiness/locations&#x60; (GET) and &#x60;/v1/connect/googlebusiness/select-location&#x60; (POST) - Snapchat: &#x60;/v1/connect/snapchat/select-profile&#x60; (POST to save selected public profile)  Example: &#x60;https://yourdomain.com/integrations/callback&#x60;  (optional)</param>
        /// <returns>ApiResponse of GetConnectUrl200Response</returns>
        ApiResponse<GetConnectUrl200Response> GetConnectUrlWithHttpInfo(string platform, string profileId, string? redirectUrl = default);
        /// <summary>
        /// List available Facebook pages for a connected account
        /// </summary>
        /// <remarks>
        /// Returns all Facebook pages the connected account has access to, including the currently selected page.
        /// </remarks>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="accountId"></param>
        /// <returns>GetFacebookPages200Response</returns>
        GetFacebookPages200Response GetFacebookPages(string accountId);

        /// <summary>
        /// List available Facebook pages for a connected account
        /// </summary>
        /// <remarks>
        /// Returns all Facebook pages the connected account has access to, including the currently selected page.
        /// </remarks>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="accountId"></param>
        /// <returns>ApiResponse of GetFacebookPages200Response</returns>
        ApiResponse<GetFacebookPages200Response> GetFacebookPagesWithHttpInfo(string accountId);
        /// <summary>
        /// List available Google Business Profile locations for a connected account
        /// </summary>
        /// <remarks>
        /// Returns all Google Business Profile locations the connected account has access to, including the currently selected location.
        /// </remarks>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="accountId"></param>
        /// <returns>GetGmbLocations200Response</returns>
        GetGmbLocations200Response GetGmbLocations(string accountId);

        /// <summary>
        /// List available Google Business Profile locations for a connected account
        /// </summary>
        /// <remarks>
        /// Returns all Google Business Profile locations the connected account has access to, including the currently selected location.
        /// </remarks>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="accountId"></param>
        /// <returns>ApiResponse of GetGmbLocations200Response</returns>
        ApiResponse<GetGmbLocations200Response> GetGmbLocationsWithHttpInfo(string accountId);
        /// <summary>
        /// Get available LinkedIn organizations for a connected account
        /// </summary>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="accountId"></param>
        /// <returns>GetLinkedInOrganizations200Response</returns>
        GetLinkedInOrganizations200Response GetLinkedInOrganizations(string accountId);

        /// <summary>
        /// Get available LinkedIn organizations for a connected account
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="accountId"></param>
        /// <returns>ApiResponse of GetLinkedInOrganizations200Response</returns>
        ApiResponse<GetLinkedInOrganizations200Response> GetLinkedInOrganizationsWithHttpInfo(string accountId);
        /// <summary>
        /// Fetch pending OAuth selection data (Headless Mode)
        /// </summary>
        /// <remarks>
        /// **Fetch Pending OAuth Data for Headless Mode**  In headless mode, platforms like LinkedIn store OAuth selection data (organizations, pages, etc.) in the database instead of passing it via URL parameters. This prevents URI_TOO_LONG errors when users have many organizations/pages to select from.  After OAuth redirect, use the &#x60;pendingDataToken&#x60; from the URL to fetch the stored data.  **Important:** - This endpoint is one-time use: data is deleted after being fetched - Data expires automatically after 10 minutes if not fetched - No authentication required, just the token from the redirect URL 
        /// </remarks>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="token">The pending data token from the OAuth redirect URL (&#x60;pendingDataToken&#x60; parameter)</param>
        /// <returns>GetPendingOAuthData200Response</returns>
        GetPendingOAuthData200Response GetPendingOAuthData(string token);

        /// <summary>
        /// Fetch pending OAuth selection data (Headless Mode)
        /// </summary>
        /// <remarks>
        /// **Fetch Pending OAuth Data for Headless Mode**  In headless mode, platforms like LinkedIn store OAuth selection data (organizations, pages, etc.) in the database instead of passing it via URL parameters. This prevents URI_TOO_LONG errors when users have many organizations/pages to select from.  After OAuth redirect, use the &#x60;pendingDataToken&#x60; from the URL to fetch the stored data.  **Important:** - This endpoint is one-time use: data is deleted after being fetched - Data expires automatically after 10 minutes if not fetched - No authentication required, just the token from the redirect URL 
        /// </remarks>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="token">The pending data token from the OAuth redirect URL (&#x60;pendingDataToken&#x60; parameter)</param>
        /// <returns>ApiResponse of GetPendingOAuthData200Response</returns>
        ApiResponse<GetPendingOAuthData200Response> GetPendingOAuthDataWithHttpInfo(string token);
        /// <summary>
        /// List Pinterest boards for a connected account
        /// </summary>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="accountId"></param>
        /// <returns>GetPinterestBoards200Response</returns>
        GetPinterestBoards200Response GetPinterestBoards(string accountId);

        /// <summary>
        /// List Pinterest boards for a connected account
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="accountId"></param>
        /// <returns>ApiResponse of GetPinterestBoards200Response</returns>
        ApiResponse<GetPinterestBoards200Response> GetPinterestBoardsWithHttpInfo(string accountId);
        /// <summary>
        /// List Reddit subreddits for a connected account
        /// </summary>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="accountId"></param>
        /// <returns>GetRedditSubreddits200Response</returns>
        GetRedditSubreddits200Response GetRedditSubreddits(string accountId);

        /// <summary>
        /// List Reddit subreddits for a connected account
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="accountId"></param>
        /// <returns>ApiResponse of GetRedditSubreddits200Response</returns>
        ApiResponse<GetRedditSubreddits200Response> GetRedditSubredditsWithHttpInfo(string accountId);
        /// <summary>
        /// Generate Telegram access code
        /// </summary>
        /// <remarks>
        /// Generate a unique access code for connecting a Telegram channel or group.  **Connection Flow:** 1. Call this endpoint to get an access code (valid for 15 minutes) 2. Add the bot (@LateScheduleBot or your configured bot) as an administrator in your Telegram channel/group 3. Open a private chat with the bot 4. Send: &#x60;{CODE} @yourchannel&#x60; (e.g., &#x60;LATE-ABC123 @mychannel&#x60;) 5. Poll &#x60;PATCH /v1/connect/telegram?code&#x3D;{CODE}&#x60; to check connection status  **Alternative for private channels:** If your channel has no public username, forward any message from the channel to the bot along with the access code. 
        /// </remarks>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="profileId">The profile ID to connect the Telegram account to</param>
        /// <returns>GetTelegramConnectStatus200Response</returns>
        GetTelegramConnectStatus200Response GetTelegramConnectStatus(string profileId);

        /// <summary>
        /// Generate Telegram access code
        /// </summary>
        /// <remarks>
        /// Generate a unique access code for connecting a Telegram channel or group.  **Connection Flow:** 1. Call this endpoint to get an access code (valid for 15 minutes) 2. Add the bot (@LateScheduleBot or your configured bot) as an administrator in your Telegram channel/group 3. Open a private chat with the bot 4. Send: &#x60;{CODE} @yourchannel&#x60; (e.g., &#x60;LATE-ABC123 @mychannel&#x60;) 5. Poll &#x60;PATCH /v1/connect/telegram?code&#x3D;{CODE}&#x60; to check connection status  **Alternative for private channels:** If your channel has no public username, forward any message from the channel to the bot along with the access code. 
        /// </remarks>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="profileId">The profile ID to connect the Telegram account to</param>
        /// <returns>ApiResponse of GetTelegramConnectStatus200Response</returns>
        ApiResponse<GetTelegramConnectStatus200Response> GetTelegramConnectStatusWithHttpInfo(string profileId);
        /// <summary>
        /// Complete OAuth token exchange manually (for server-side flows)
        /// </summary>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="platform"></param>
        /// <param name="handleOAuthCallbackRequest"></param>
        /// <returns></returns>
        void HandleOAuthCallback(string platform, HandleOAuthCallbackRequest handleOAuthCallbackRequest);

        /// <summary>
        /// Complete OAuth token exchange manually (for server-side flows)
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="platform"></param>
        /// <param name="handleOAuthCallbackRequest"></param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> HandleOAuthCallbackWithHttpInfo(string platform, HandleOAuthCallbackRequest handleOAuthCallbackRequest);
        /// <summary>
        /// Direct Telegram connection (power users)
        /// </summary>
        /// <remarks>
        /// Connect a Telegram channel/group directly using the chat ID.  This is an alternative to the access code flow for power users who know their Telegram chat ID. The bot must already be added as an administrator in the channel/group. 
        /// </remarks>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="initiateTelegramConnectRequest"></param>
        /// <returns>InitiateTelegramConnect200Response</returns>
        InitiateTelegramConnect200Response InitiateTelegramConnect(InitiateTelegramConnectRequest initiateTelegramConnectRequest);

        /// <summary>
        /// Direct Telegram connection (power users)
        /// </summary>
        /// <remarks>
        /// Connect a Telegram channel/group directly using the chat ID.  This is an alternative to the access code flow for power users who know their Telegram chat ID. The bot must already be added as an administrator in the channel/group. 
        /// </remarks>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="initiateTelegramConnectRequest"></param>
        /// <returns>ApiResponse of InitiateTelegramConnect200Response</returns>
        ApiResponse<InitiateTelegramConnect200Response> InitiateTelegramConnectWithHttpInfo(InitiateTelegramConnectRequest initiateTelegramConnectRequest);
        /// <summary>
        /// List Facebook Pages after OAuth (Headless Mode)
        /// </summary>
        /// <remarks>
        /// **Headless Mode for Custom UI**  After initiating Facebook OAuth via &#x60;/v1/connect/facebook&#x60;, you&#39;ll be redirected to  &#x60;/connect/facebook/select-page&#x60; with query params including &#x60;tempToken&#x60; and &#x60;userProfile&#x60;.  For a **headless/whitelabeled flow**, extract these params from the URL and call this  endpoint to retrieve the list of Facebook Pages the user can manage. Then build your  own UI to let users select a page.  **Note:** Use the &#x60;X-Connect-Token&#x60; header if you initiated the connection via API key  (rather than a browser session). 
        /// </remarks>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="profileId">Profile ID from your connection flow</param>
        /// <param name="tempToken">Temporary Facebook access token from the OAuth callback redirect</param>
        /// <returns>ListFacebookPages200Response</returns>
        ListFacebookPages200Response ListFacebookPages(string profileId, string tempToken);

        /// <summary>
        /// List Facebook Pages after OAuth (Headless Mode)
        /// </summary>
        /// <remarks>
        /// **Headless Mode for Custom UI**  After initiating Facebook OAuth via &#x60;/v1/connect/facebook&#x60;, you&#39;ll be redirected to  &#x60;/connect/facebook/select-page&#x60; with query params including &#x60;tempToken&#x60; and &#x60;userProfile&#x60;.  For a **headless/whitelabeled flow**, extract these params from the URL and call this  endpoint to retrieve the list of Facebook Pages the user can manage. Then build your  own UI to let users select a page.  **Note:** Use the &#x60;X-Connect-Token&#x60; header if you initiated the connection via API key  (rather than a browser session). 
        /// </remarks>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="profileId">Profile ID from your connection flow</param>
        /// <param name="tempToken">Temporary Facebook access token from the OAuth callback redirect</param>
        /// <returns>ApiResponse of ListFacebookPages200Response</returns>
        ApiResponse<ListFacebookPages200Response> ListFacebookPagesWithHttpInfo(string profileId, string tempToken);
        /// <summary>
        /// List Google Business Locations after OAuth (Headless Mode)
        /// </summary>
        /// <remarks>
        /// **Headless Mode for Custom UI**  After initiating Google Business OAuth via &#x60;/v1/connect/googlebusiness?headless&#x3D;true&#x60;, you&#39;ll be redirected  to your &#x60;redirect_url&#x60; with query params including &#x60;tempToken&#x60; and &#x60;userProfile&#x60;.  For a **headless/whitelabeled flow**, extract these params from the URL and call this  endpoint to retrieve the list of Google Business locations the user can manage. Then build your  own UI to let users select a location.  **Note:** Use the &#x60;X-Connect-Token&#x60; header if you initiated the connection via API key  (rather than a browser session). 
        /// </remarks>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="profileId">Profile ID from your connection flow</param>
        /// <param name="tempToken">Temporary Google access token from the OAuth callback redirect</param>
        /// <returns>ListGoogleBusinessLocations200Response</returns>
        ListGoogleBusinessLocations200Response ListGoogleBusinessLocations(string profileId, string tempToken);

        /// <summary>
        /// List Google Business Locations after OAuth (Headless Mode)
        /// </summary>
        /// <remarks>
        /// **Headless Mode for Custom UI**  After initiating Google Business OAuth via &#x60;/v1/connect/googlebusiness?headless&#x3D;true&#x60;, you&#39;ll be redirected  to your &#x60;redirect_url&#x60; with query params including &#x60;tempToken&#x60; and &#x60;userProfile&#x60;.  For a **headless/whitelabeled flow**, extract these params from the URL and call this  endpoint to retrieve the list of Google Business locations the user can manage. Then build your  own UI to let users select a location.  **Note:** Use the &#x60;X-Connect-Token&#x60; header if you initiated the connection via API key  (rather than a browser session). 
        /// </remarks>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="profileId">Profile ID from your connection flow</param>
        /// <param name="tempToken">Temporary Google access token from the OAuth callback redirect</param>
        /// <returns>ApiResponse of ListGoogleBusinessLocations200Response</returns>
        ApiResponse<ListGoogleBusinessLocations200Response> ListGoogleBusinessLocationsWithHttpInfo(string profileId, string tempToken);
        /// <summary>
        /// Fetch full LinkedIn organization details (Headless Mode)
        /// </summary>
        /// <remarks>
        /// **Fetch Full Organization Details for Custom UI**  After LinkedIn OAuth in headless mode, the redirect URL contains organization data with only &#x60;id&#x60;, &#x60;urn&#x60;, and &#x60;name&#x60; fields (additional details are excluded to prevent URL length issues with many organizations).  Use this endpoint to fetch full organization details including logos, vanity names, websites, and more if you want to display them in your custom selection UI.  **Note:** This endpoint requires no authentication - just the &#x60;tempToken&#x60; from the OAuth redirect. Details are fetched directly from LinkedIn&#39;s API in parallel for fast response times. 
        /// </remarks>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="tempToken">The temporary LinkedIn access token from the OAuth redirect</param>
        /// <param name="orgIds">Comma-separated list of organization IDs to fetch details for (max 100)</param>
        /// <returns>ListLinkedInOrganizations200Response</returns>
        ListLinkedInOrganizations200Response ListLinkedInOrganizations(string tempToken, string orgIds);

        /// <summary>
        /// Fetch full LinkedIn organization details (Headless Mode)
        /// </summary>
        /// <remarks>
        /// **Fetch Full Organization Details for Custom UI**  After LinkedIn OAuth in headless mode, the redirect URL contains organization data with only &#x60;id&#x60;, &#x60;urn&#x60;, and &#x60;name&#x60; fields (additional details are excluded to prevent URL length issues with many organizations).  Use this endpoint to fetch full organization details including logos, vanity names, websites, and more if you want to display them in your custom selection UI.  **Note:** This endpoint requires no authentication - just the &#x60;tempToken&#x60; from the OAuth redirect. Details are fetched directly from LinkedIn&#39;s API in parallel for fast response times. 
        /// </remarks>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="tempToken">The temporary LinkedIn access token from the OAuth redirect</param>
        /// <param name="orgIds">Comma-separated list of organization IDs to fetch details for (max 100)</param>
        /// <returns>ApiResponse of ListLinkedInOrganizations200Response</returns>
        ApiResponse<ListLinkedInOrganizations200Response> ListLinkedInOrganizationsWithHttpInfo(string tempToken, string orgIds);
        /// <summary>
        /// List Pinterest Boards after OAuth (Headless Mode)
        /// </summary>
        /// <remarks>
        /// **Retrieve Pinterest Boards for Selection UI**  After initiating Pinterest OAuth via &#x60;/v1/connect/pinterest&#x60; with &#x60;headless&#x3D;true&#x60;, you&#39;ll be redirected to your &#x60;redirect_url&#x60; with query params including &#x60;tempToken&#x60; and &#x60;userProfile&#x60;.  If you want to build your own fully-branded board selector (instead of Late&#39;s hosted UI), call this endpoint to retrieve the list of Pinterest Boards the user can post to. Then build your UI and call &#x60;POST /v1/connect/pinterest/select-board&#x60; to save the selection.  **Authentication:** Use &#x60;X-Connect-Token&#x60; header with the &#x60;connect_token&#x60; from the redirect URL. 
        /// </remarks>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="xConnectToken">Short-lived connect token from the OAuth redirect</param>
        /// <param name="profileId">Your Late profile ID</param>
        /// <param name="tempToken">Temporary Pinterest access token from the OAuth callback redirect</param>
        /// <returns>ListPinterestBoardsForSelection200Response</returns>
        ListPinterestBoardsForSelection200Response ListPinterestBoardsForSelection(string xConnectToken, string profileId, string tempToken);

        /// <summary>
        /// List Pinterest Boards after OAuth (Headless Mode)
        /// </summary>
        /// <remarks>
        /// **Retrieve Pinterest Boards for Selection UI**  After initiating Pinterest OAuth via &#x60;/v1/connect/pinterest&#x60; with &#x60;headless&#x3D;true&#x60;, you&#39;ll be redirected to your &#x60;redirect_url&#x60; with query params including &#x60;tempToken&#x60; and &#x60;userProfile&#x60;.  If you want to build your own fully-branded board selector (instead of Late&#39;s hosted UI), call this endpoint to retrieve the list of Pinterest Boards the user can post to. Then build your UI and call &#x60;POST /v1/connect/pinterest/select-board&#x60; to save the selection.  **Authentication:** Use &#x60;X-Connect-Token&#x60; header with the &#x60;connect_token&#x60; from the redirect URL. 
        /// </remarks>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="xConnectToken">Short-lived connect token from the OAuth redirect</param>
        /// <param name="profileId">Your Late profile ID</param>
        /// <param name="tempToken">Temporary Pinterest access token from the OAuth callback redirect</param>
        /// <returns>ApiResponse of ListPinterestBoardsForSelection200Response</returns>
        ApiResponse<ListPinterestBoardsForSelection200Response> ListPinterestBoardsForSelectionWithHttpInfo(string xConnectToken, string profileId, string tempToken);
        /// <summary>
        /// List Snapchat Public Profiles after OAuth (Headless Mode)
        /// </summary>
        /// <remarks>
        /// **Headless Mode for Custom UI**  After initiating Snapchat OAuth via &#x60;/v1/connect/snapchat?headless&#x3D;true&#x60;, you&#39;ll be redirected to your &#x60;redirect_url&#x60; with query params including &#x60;tempToken&#x60;, &#x60;userProfile&#x60;, and &#x60;publicProfiles&#x60;.  If you want to build your own fully-branded profile selector (instead of Late&#39;s hosted UI), call this endpoint to retrieve the list of Snapchat Public Profiles the user can post to. Then build your UI and call &#x60;POST /v1/connect/snapchat/select-profile&#x60; to save the selection.  **Authentication:** Use &#x60;X-Connect-Token&#x60; header with the &#x60;connect_token&#x60; from the redirect URL. 
        /// </remarks>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="xConnectToken">Short-lived connect token from the OAuth redirect</param>
        /// <param name="profileId">Your Late profile ID</param>
        /// <param name="tempToken">Temporary Snapchat access token from the OAuth callback redirect</param>
        /// <returns>ListSnapchatProfiles200Response</returns>
        ListSnapchatProfiles200Response ListSnapchatProfiles(string xConnectToken, string profileId, string tempToken);

        /// <summary>
        /// List Snapchat Public Profiles after OAuth (Headless Mode)
        /// </summary>
        /// <remarks>
        /// **Headless Mode for Custom UI**  After initiating Snapchat OAuth via &#x60;/v1/connect/snapchat?headless&#x3D;true&#x60;, you&#39;ll be redirected to your &#x60;redirect_url&#x60; with query params including &#x60;tempToken&#x60;, &#x60;userProfile&#x60;, and &#x60;publicProfiles&#x60;.  If you want to build your own fully-branded profile selector (instead of Late&#39;s hosted UI), call this endpoint to retrieve the list of Snapchat Public Profiles the user can post to. Then build your UI and call &#x60;POST /v1/connect/snapchat/select-profile&#x60; to save the selection.  **Authentication:** Use &#x60;X-Connect-Token&#x60; header with the &#x60;connect_token&#x60; from the redirect URL. 
        /// </remarks>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="xConnectToken">Short-lived connect token from the OAuth redirect</param>
        /// <param name="profileId">Your Late profile ID</param>
        /// <param name="tempToken">Temporary Snapchat access token from the OAuth callback redirect</param>
        /// <returns>ApiResponse of ListSnapchatProfiles200Response</returns>
        ApiResponse<ListSnapchatProfiles200Response> ListSnapchatProfilesWithHttpInfo(string xConnectToken, string profileId, string tempToken);
        /// <summary>
        /// Select a Facebook Page to complete the connection (Headless Mode)
        /// </summary>
        /// <remarks>
        /// **Complete the Headless Flow**  After displaying your custom UI with the list of pages from the GET endpoint, call this  endpoint to finalize the connection with the user&#39;s selected page.  The &#x60;userProfile&#x60; should be the decoded JSON object from the &#x60;userProfile&#x60; query param  in the OAuth callback redirect URL.  **Note:** Use the &#x60;X-Connect-Token&#x60; header if you initiated the connection via API key. 
        /// </remarks>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="selectFacebookPageRequest"></param>
        /// <returns>SelectFacebookPage200Response</returns>
        SelectFacebookPage200Response SelectFacebookPage(SelectFacebookPageRequest selectFacebookPageRequest);

        /// <summary>
        /// Select a Facebook Page to complete the connection (Headless Mode)
        /// </summary>
        /// <remarks>
        /// **Complete the Headless Flow**  After displaying your custom UI with the list of pages from the GET endpoint, call this  endpoint to finalize the connection with the user&#39;s selected page.  The &#x60;userProfile&#x60; should be the decoded JSON object from the &#x60;userProfile&#x60; query param  in the OAuth callback redirect URL.  **Note:** Use the &#x60;X-Connect-Token&#x60; header if you initiated the connection via API key. 
        /// </remarks>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="selectFacebookPageRequest"></param>
        /// <returns>ApiResponse of SelectFacebookPage200Response</returns>
        ApiResponse<SelectFacebookPage200Response> SelectFacebookPageWithHttpInfo(SelectFacebookPageRequest selectFacebookPageRequest);
        /// <summary>
        /// Select a Google Business location to complete the connection (Headless Mode)
        /// </summary>
        /// <remarks>
        /// **Complete the Headless Flow**  After displaying your custom UI with the list of locations from the GET &#x60;/v1/connect/googlebusiness/locations&#x60;  endpoint, call this endpoint to finalize the connection with the user&#39;s selected location.  The &#x60;userProfile&#x60; should be the decoded JSON object from the &#x60;userProfile&#x60; query param  in the OAuth callback redirect URL. It contains important token information (including refresh token).  **Note:** Use the &#x60;X-Connect-Token&#x60; header if you initiated the connection via API key. 
        /// </remarks>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="selectGoogleBusinessLocationRequest"></param>
        /// <returns>SelectGoogleBusinessLocation200Response</returns>
        SelectGoogleBusinessLocation200Response SelectGoogleBusinessLocation(SelectGoogleBusinessLocationRequest selectGoogleBusinessLocationRequest);

        /// <summary>
        /// Select a Google Business location to complete the connection (Headless Mode)
        /// </summary>
        /// <remarks>
        /// **Complete the Headless Flow**  After displaying your custom UI with the list of locations from the GET &#x60;/v1/connect/googlebusiness/locations&#x60;  endpoint, call this endpoint to finalize the connection with the user&#39;s selected location.  The &#x60;userProfile&#x60; should be the decoded JSON object from the &#x60;userProfile&#x60; query param  in the OAuth callback redirect URL. It contains important token information (including refresh token).  **Note:** Use the &#x60;X-Connect-Token&#x60; header if you initiated the connection via API key. 
        /// </remarks>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="selectGoogleBusinessLocationRequest"></param>
        /// <returns>ApiResponse of SelectGoogleBusinessLocation200Response</returns>
        ApiResponse<SelectGoogleBusinessLocation200Response> SelectGoogleBusinessLocationWithHttpInfo(SelectGoogleBusinessLocationRequest selectGoogleBusinessLocationRequest);
        /// <summary>
        /// Select LinkedIn organization or personal account after OAuth
        /// </summary>
        /// <remarks>
        /// **Complete the LinkedIn Connection Flow**  After OAuth, the user is redirected with &#x60;organizations&#x60; in the URL params (if they have org admin access). The organizations array contains &#x60;id&#x60;, &#x60;urn&#x60;, and &#x60;name&#x60; fields. Use this data to build your UI,  then call this endpoint to save the selection.  Set &#x60;accountType&#x60; to &#x60;personal&#x60; to connect as the user&#39;s personal LinkedIn profile, or &#x60;organization&#x60; to connect as a company page (requires &#x60;selectedOrganization&#x60; object).  **Personal Profile:** To connect a personal LinkedIn account, set &#x60;accountType&#x60; to &#x60;\&quot;personal\&quot;&#x60; and **omit** the &#x60;selectedOrganization&#x60; field entirely. This is the simplest flow.  **Headless Mode:** Use the &#x60;X-Connect-Token&#x60; header if you initiated the connection via API key. 
        /// </remarks>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="selectLinkedInOrganizationRequest"></param>
        /// <returns>SelectLinkedInOrganization200Response</returns>
        SelectLinkedInOrganization200Response SelectLinkedInOrganization(SelectLinkedInOrganizationRequest selectLinkedInOrganizationRequest);

        /// <summary>
        /// Select LinkedIn organization or personal account after OAuth
        /// </summary>
        /// <remarks>
        /// **Complete the LinkedIn Connection Flow**  After OAuth, the user is redirected with &#x60;organizations&#x60; in the URL params (if they have org admin access). The organizations array contains &#x60;id&#x60;, &#x60;urn&#x60;, and &#x60;name&#x60; fields. Use this data to build your UI,  then call this endpoint to save the selection.  Set &#x60;accountType&#x60; to &#x60;personal&#x60; to connect as the user&#39;s personal LinkedIn profile, or &#x60;organization&#x60; to connect as a company page (requires &#x60;selectedOrganization&#x60; object).  **Personal Profile:** To connect a personal LinkedIn account, set &#x60;accountType&#x60; to &#x60;\&quot;personal\&quot;&#x60; and **omit** the &#x60;selectedOrganization&#x60; field entirely. This is the simplest flow.  **Headless Mode:** Use the &#x60;X-Connect-Token&#x60; header if you initiated the connection via API key. 
        /// </remarks>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="selectLinkedInOrganizationRequest"></param>
        /// <returns>ApiResponse of SelectLinkedInOrganization200Response</returns>
        ApiResponse<SelectLinkedInOrganization200Response> SelectLinkedInOrganizationWithHttpInfo(SelectLinkedInOrganizationRequest selectLinkedInOrganizationRequest);
        /// <summary>
        /// Select a Pinterest Board to complete the connection (Headless Mode)
        /// </summary>
        /// <remarks>
        /// **Complete the Pinterest Connection Flow**  After OAuth, use this endpoint to save the selected board and complete the Pinterest account connection.  **Headless Mode:** Use the &#x60;X-Connect-Token&#x60; header if you initiated the connection via API key. 
        /// </remarks>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="selectPinterestBoardRequest"></param>
        /// <returns>SelectPinterestBoard200Response</returns>
        SelectPinterestBoard200Response SelectPinterestBoard(SelectPinterestBoardRequest selectPinterestBoardRequest);

        /// <summary>
        /// Select a Pinterest Board to complete the connection (Headless Mode)
        /// </summary>
        /// <remarks>
        /// **Complete the Pinterest Connection Flow**  After OAuth, use this endpoint to save the selected board and complete the Pinterest account connection.  **Headless Mode:** Use the &#x60;X-Connect-Token&#x60; header if you initiated the connection via API key. 
        /// </remarks>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="selectPinterestBoardRequest"></param>
        /// <returns>ApiResponse of SelectPinterestBoard200Response</returns>
        ApiResponse<SelectPinterestBoard200Response> SelectPinterestBoardWithHttpInfo(SelectPinterestBoardRequest selectPinterestBoardRequest);
        /// <summary>
        /// Select a Snapchat Public Profile to complete the connection (Headless Mode)
        /// </summary>
        /// <remarks>
        /// **Complete the Snapchat Connection Flow**  After OAuth, use this endpoint to save the selected Public Profile and complete the Snapchat account connection. Snapchat requires a Public Profile to publish Stories, Saved Stories, and Spotlight content.  **Headless Mode:** Use the &#x60;X-Connect-Token&#x60; header if you initiated the connection via API key.  After initiating Snapchat OAuth via &#x60;/v1/connect/snapchat?headless&#x3D;true&#x60;, you&#39;ll be redirected to your &#x60;redirect_url&#x60; with query params including: - &#x60;tempToken&#x60; - Temporary access token - &#x60;userProfile&#x60; - URL-encoded JSON with user info - &#x60;publicProfiles&#x60; - URL-encoded JSON array of available public profiles - &#x60;connect_token&#x60; - Short-lived token for API authentication - &#x60;platform&#x3D;snapchat&#x60; - &#x60;step&#x3D;select_public_profile&#x60;  Parse &#x60;publicProfiles&#x60; to build your custom selector UI, then call this endpoint with the selected profile. 
        /// </remarks>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="selectSnapchatProfileRequest"></param>
        /// <param name="xConnectToken">Short-lived connect token from the OAuth redirect (for API users) (optional)</param>
        /// <returns>SelectSnapchatProfile200Response</returns>
        SelectSnapchatProfile200Response SelectSnapchatProfile(SelectSnapchatProfileRequest selectSnapchatProfileRequest, string? xConnectToken = default);

        /// <summary>
        /// Select a Snapchat Public Profile to complete the connection (Headless Mode)
        /// </summary>
        /// <remarks>
        /// **Complete the Snapchat Connection Flow**  After OAuth, use this endpoint to save the selected Public Profile and complete the Snapchat account connection. Snapchat requires a Public Profile to publish Stories, Saved Stories, and Spotlight content.  **Headless Mode:** Use the &#x60;X-Connect-Token&#x60; header if you initiated the connection via API key.  After initiating Snapchat OAuth via &#x60;/v1/connect/snapchat?headless&#x3D;true&#x60;, you&#39;ll be redirected to your &#x60;redirect_url&#x60; with query params including: - &#x60;tempToken&#x60; - Temporary access token - &#x60;userProfile&#x60; - URL-encoded JSON with user info - &#x60;publicProfiles&#x60; - URL-encoded JSON array of available public profiles - &#x60;connect_token&#x60; - Short-lived token for API authentication - &#x60;platform&#x3D;snapchat&#x60; - &#x60;step&#x3D;select_public_profile&#x60;  Parse &#x60;publicProfiles&#x60; to build your custom selector UI, then call this endpoint with the selected profile. 
        /// </remarks>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="selectSnapchatProfileRequest"></param>
        /// <param name="xConnectToken">Short-lived connect token from the OAuth redirect (for API users) (optional)</param>
        /// <returns>ApiResponse of SelectSnapchatProfile200Response</returns>
        ApiResponse<SelectSnapchatProfile200Response> SelectSnapchatProfileWithHttpInfo(SelectSnapchatProfileRequest selectSnapchatProfileRequest, string? xConnectToken = default);
        /// <summary>
        /// Update selected Facebook page for a connected account
        /// </summary>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="accountId"></param>
        /// <param name="updateFacebookPageRequest"></param>
        /// <returns>UpdateFacebookPage200Response</returns>
        UpdateFacebookPage200Response UpdateFacebookPage(string accountId, UpdateFacebookPageRequest updateFacebookPageRequest);

        /// <summary>
        /// Update selected Facebook page for a connected account
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="accountId"></param>
        /// <param name="updateFacebookPageRequest"></param>
        /// <returns>ApiResponse of UpdateFacebookPage200Response</returns>
        ApiResponse<UpdateFacebookPage200Response> UpdateFacebookPageWithHttpInfo(string accountId, UpdateFacebookPageRequest updateFacebookPageRequest);
        /// <summary>
        /// Update selected Google Business Profile location for a connected account
        /// </summary>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="accountId"></param>
        /// <param name="updateGmbLocationRequest"></param>
        /// <returns>UpdateGmbLocation200Response</returns>
        UpdateGmbLocation200Response UpdateGmbLocation(string accountId, UpdateGmbLocationRequest updateGmbLocationRequest);

        /// <summary>
        /// Update selected Google Business Profile location for a connected account
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="accountId"></param>
        /// <param name="updateGmbLocationRequest"></param>
        /// <returns>ApiResponse of UpdateGmbLocation200Response</returns>
        ApiResponse<UpdateGmbLocation200Response> UpdateGmbLocationWithHttpInfo(string accountId, UpdateGmbLocationRequest updateGmbLocationRequest);
        /// <summary>
        /// Switch LinkedIn account type (personal/organization)
        /// </summary>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="accountId"></param>
        /// <param name="updateLinkedInOrganizationRequest"></param>
        /// <returns>ConnectBlueskyCredentials200Response</returns>
        ConnectBlueskyCredentials200Response UpdateLinkedInOrganization(string accountId, UpdateLinkedInOrganizationRequest updateLinkedInOrganizationRequest);

        /// <summary>
        /// Switch LinkedIn account type (personal/organization)
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="accountId"></param>
        /// <param name="updateLinkedInOrganizationRequest"></param>
        /// <returns>ApiResponse of ConnectBlueskyCredentials200Response</returns>
        ApiResponse<ConnectBlueskyCredentials200Response> UpdateLinkedInOrganizationWithHttpInfo(string accountId, UpdateLinkedInOrganizationRequest updateLinkedInOrganizationRequest);
        /// <summary>
        /// Set default Pinterest board on the connection
        /// </summary>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="accountId"></param>
        /// <param name="updatePinterestBoardsRequest"></param>
        /// <returns>ConnectBlueskyCredentials200Response</returns>
        ConnectBlueskyCredentials200Response UpdatePinterestBoards(string accountId, UpdatePinterestBoardsRequest updatePinterestBoardsRequest);

        /// <summary>
        /// Set default Pinterest board on the connection
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="accountId"></param>
        /// <param name="updatePinterestBoardsRequest"></param>
        /// <returns>ApiResponse of ConnectBlueskyCredentials200Response</returns>
        ApiResponse<ConnectBlueskyCredentials200Response> UpdatePinterestBoardsWithHttpInfo(string accountId, UpdatePinterestBoardsRequest updatePinterestBoardsRequest);
        /// <summary>
        /// Set default subreddit on the connection
        /// </summary>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="accountId"></param>
        /// <param name="updateRedditSubredditsRequest"></param>
        /// <returns>UpdateRedditSubreddits200Response</returns>
        UpdateRedditSubreddits200Response UpdateRedditSubreddits(string accountId, UpdateRedditSubredditsRequest updateRedditSubredditsRequest);

        /// <summary>
        /// Set default subreddit on the connection
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="accountId"></param>
        /// <param name="updateRedditSubredditsRequest"></param>
        /// <returns>ApiResponse of UpdateRedditSubreddits200Response</returns>
        ApiResponse<UpdateRedditSubreddits200Response> UpdateRedditSubredditsWithHttpInfo(string accountId, UpdateRedditSubredditsRequest updateRedditSubredditsRequest);
        #endregion Synchronous Operations
    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public interface IConnectApiAsync : IApiAccessor
    {
        #region Asynchronous Operations
        /// <summary>
        /// Check Telegram connection status
        /// </summary>
        /// <remarks>
        /// Poll this endpoint to check if a Telegram access code has been used to connect a channel/group.  **Recommended polling interval:** 3 seconds  **Status values:** - &#x60;pending&#x60;: Code is valid, waiting for user to complete connection - &#x60;connected&#x60;: Connection successful - channel/group is now linked - &#x60;expired&#x60;: Code has expired, generate a new one 
        /// </remarks>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="code">The access code to check status for</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of CompleteTelegramConnect200Response</returns>
        System.Threading.Tasks.Task<CompleteTelegramConnect200Response> CompleteTelegramConnectAsync(string code, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Check Telegram connection status
        /// </summary>
        /// <remarks>
        /// Poll this endpoint to check if a Telegram access code has been used to connect a channel/group.  **Recommended polling interval:** 3 seconds  **Status values:** - &#x60;pending&#x60;: Code is valid, waiting for user to complete connection - &#x60;connected&#x60;: Connection successful - channel/group is now linked - &#x60;expired&#x60;: Code has expired, generate a new one 
        /// </remarks>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="code">The access code to check status for</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (CompleteTelegramConnect200Response)</returns>
        System.Threading.Tasks.Task<ApiResponse<CompleteTelegramConnect200Response>> CompleteTelegramConnectWithHttpInfoAsync(string code, System.Threading.CancellationToken cancellationToken = default);
        /// <summary>
        /// Connect Bluesky using app password
        /// </summary>
        /// <remarks>
        /// Connect a Bluesky account using identifier (handle or email) and an app password.  To get your userId for the state parameter, call &#x60;GET /v1/users&#x60; - the response includes a &#x60;currentUserId&#x60; field. 
        /// </remarks>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="connectBlueskyCredentialsRequest"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ConnectBlueskyCredentials200Response</returns>
        System.Threading.Tasks.Task<ConnectBlueskyCredentials200Response> ConnectBlueskyCredentialsAsync(ConnectBlueskyCredentialsRequest connectBlueskyCredentialsRequest, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Connect Bluesky using app password
        /// </summary>
        /// <remarks>
        /// Connect a Bluesky account using identifier (handle or email) and an app password.  To get your userId for the state parameter, call &#x60;GET /v1/users&#x60; - the response includes a &#x60;currentUserId&#x60; field. 
        /// </remarks>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="connectBlueskyCredentialsRequest"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (ConnectBlueskyCredentials200Response)</returns>
        System.Threading.Tasks.Task<ApiResponse<ConnectBlueskyCredentials200Response>> ConnectBlueskyCredentialsWithHttpInfoAsync(ConnectBlueskyCredentialsRequest connectBlueskyCredentialsRequest, System.Threading.CancellationToken cancellationToken = default);
        /// <summary>
        /// Start OAuth connection for a platform
        /// </summary>
        /// <remarks>
        /// Initiate an OAuth connection flow for any supported social media platform.  **Standard Flow (Hosted UI):** For Facebook connections, Late hosts the page selection UI:  1. Call this endpoint with your API key and &#x60;redirect_url&#x60; (optional) 2. Redirect your user to the returned &#x60;authUrl&#x60; 3. After OAuth, the user is redirected to Late’s hosted page selector at      &#x60;/connect/facebook/select-page?profileId&#x3D;X&amp;tempToken&#x3D;Y&amp;userProfile&#x3D;Z&amp;redirect_url&#x3D;YOUR_URL&amp;connect_token&#x3D;CT&#x60; 4. After they pick a page, Late saves the connection and finally redirects to your &#x60;redirect_url&#x60; (if provided)  **Headless/Whitelabel Mode (Facebook, LinkedIn, Pinterest &amp; Google Business Profile):** Build your own fully branded selection UI while Late handles OAuth:  **Facebook:** 1. Call this endpoint with your API key and add &#x60;&amp;headless&#x3D;true&#x60;, e.g.      &#x60;GET /v1/connect/facebook?profileId&#x3D;PROFILE_ID&amp;redirect_url&#x3D;https://yourapp.com/callback&amp;headless&#x3D;true&#x60; 2. Redirect your user to the returned &#x60;authUrl&#x60; 3. After OAuth, the user is redirected directly to **your** &#x60;redirect_url&#x60; with:    - &#x60;profileId&#x60; – your Late profile ID      - &#x60;tempToken&#x60; – temporary Facebook access token      - &#x60;userProfile&#x60; – URL‑encoded JSON user profile      - &#x60;connect_token&#x60; – short‑lived connect token (for API auth)      - &#x60;platform&#x3D;facebook&#x60;      - &#x60;step&#x3D;select_page&#x60; 4. Use &#x60;tempToken&#x60;, &#x60;userProfile&#x60;, and the &#x60;X-Connect-Token&#x60; header with:    - &#x60;GET /v1/connect/facebook/select-page&#x60; to fetch pages    - &#x60;POST /v1/connect/facebook/select-page&#x60; to save the selected page 5. In this mode, users never see Late&#39;s hosted page selector – only your UI.  **LinkedIn:** 1. Call this endpoint with &#x60;&amp;headless&#x3D;true&#x60;, e.g.    &#x60;GET /v1/connect/linkedin?profileId&#x3D;PROFILE_ID&amp;redirect_url&#x3D;https://yourapp.com/callback&amp;headless&#x3D;true&#x60; 2. Redirect your user to the returned &#x60;authUrl&#x60; 3. After OAuth, the user is redirected directly to **your** &#x60;redirect_url&#x60; with:    - &#x60;profileId&#x60; – your Late profile ID    - &#x60;pendingDataToken&#x60; – token to fetch OAuth data via API (see step 4)    - &#x60;connect_token&#x60; – short-lived connect token (for API auth)    - &#x60;platform&#x3D;linkedin&#x60;    - &#x60;step&#x3D;select_organization&#x60; 4. Call &#x60;GET /v1/connect/pending-data?token&#x3D;PENDING_DATA_TOKEN&#x60; to fetch the OAuth data:    - &#x60;tempToken&#x60; – temporary LinkedIn access token    - &#x60;userProfile&#x60; – JSON object with &#x60;id&#x60;, &#x60;username&#x60;, &#x60;displayName&#x60;, &#x60;profilePicture&#x60;    - &#x60;organizations&#x60; – JSON array with &#x60;id&#x60;, &#x60;urn&#x60;, &#x60;name&#x60;, &#x60;vanityName&#x60; for each org    - &#x60;refreshToken&#x60; / &#x60;expiresIn&#x60; – token metadata    This endpoint is one-time use and data expires after 10 minutes. 5. **Optional:** To fetch full organization details (logos, website, industry, description), call &#x60;GET /v1/connect/linkedin/organizations?tempToken&#x3D;X&amp;orgIds&#x3D;id1,id2,...&#x60; 6. Call &#x60;POST /v1/connect/linkedin/select-organization&#x60; with the &#x60;X-Connect-Token&#x60; header to save the selection. 7. In this mode, users never see Late&#39;s hosted organization selector – only your UI. 8. Note: If the user has no organization admin access, &#x60;step&#x3D;select_organization&#x60; will NOT be present,    and the account will be connected directly as a personal account.  **Pinterest:** 1. Call this endpoint with &#x60;&amp;headless&#x3D;true&#x60;, e.g.    &#x60;GET /v1/connect/pinterest?profileId&#x3D;PROFILE_ID&amp;redirect_url&#x3D;https://yourapp.com/callback&amp;headless&#x3D;true&#x60; 2. Redirect your user to the returned &#x60;authUrl&#x60; 3. After OAuth, the user is redirected directly to **your** &#x60;redirect_url&#x60; with:    - &#x60;profileId&#x60; – your Late profile ID    - &#x60;tempToken&#x60; – temporary Pinterest access token    - &#x60;userProfile&#x60; – URL‑encoded JSON user profile    - &#x60;connect_token&#x60; – short‑lived connect token (for API auth)    - &#x60;platform&#x3D;pinterest&#x60;    - &#x60;step&#x3D;select_board&#x60; 4. Use &#x60;tempToken&#x60;, &#x60;userProfile&#x60;, and the &#x60;X-Connect-Token&#x60; header with:    - &#x60;GET /v1/connect/pinterest/select-board&#x60; to fetch boards    - &#x60;POST /v1/connect/pinterest/select-board&#x60; to save the selected board 5. In this mode, users never see Late&#39;s hosted board selector – only your UI.  **Google Business Profile:** 1. Call this endpoint with &#x60;&amp;headless&#x3D;true&#x60;, e.g.    &#x60;GET /v1/connect/googlebusiness?profileId&#x3D;PROFILE_ID&amp;redirect_url&#x3D;https://yourapp.com/callback&amp;headless&#x3D;true&#x60; 2. Redirect your user to the returned &#x60;authUrl&#x60; 3. After OAuth, the user is redirected directly to **your** &#x60;redirect_url&#x60; with:    - &#x60;profileId&#x60; – your Late profile ID    - &#x60;tempToken&#x60; – temporary Google access token    - &#x60;userProfile&#x60; – URL‑encoded JSON user profile (includes refresh token info)    - &#x60;connect_token&#x60; – short‑lived connect token (for API auth)    - &#x60;platform&#x3D;googlebusiness&#x60;    - &#x60;step&#x3D;select_location&#x60; 4. Use &#x60;tempToken&#x60;, &#x60;userProfile&#x60;, and the &#x60;X-Connect-Token&#x60; header with:    - &#x60;GET /v1/connect/googlebusiness/locations&#x60; to fetch business locations    - &#x60;POST /v1/connect/googlebusiness/select-location&#x60; to save the selected location 5. In this mode, users never see Late&#39;s hosted location selector – only your UI. 
        /// </remarks>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="platform">Social media platform to connect</param>
        /// <param name="profileId">Your Late profile ID (get from /v1/profiles)</param>
        /// <param name="redirectUrl">Optional: Your custom redirect URL after connection completes.  **Standard Mode:** Omit &#x60;headless&#x3D;true&#x60; to use our hosted page selection UI.   After the user selects a Facebook Page, Late redirects here with:   &#x60;?connected&#x3D;facebook&amp;profileId&#x3D;X&amp;username&#x3D;Y&#x60;  **Headless Mode (Facebook, LinkedIn, Pinterest, Google Business Profile &amp; Snapchat):** Pass &#x60;headless&#x3D;true&#x60; as a query parameter on this endpoint (not inside &#x60;redirect_url&#x60;), e.g.: &#x60;GET /v1/connect/facebook?profileId&#x3D;PROFILE_ID&amp;redirect_url&#x3D;https://yourapp.com/callback&amp;headless&#x3D;true&#x60; &#x60;GET /v1/connect/linkedin?profileId&#x3D;PROFILE_ID&amp;redirect_url&#x3D;https://yourapp.com/callback&amp;headless&#x3D;true&#x60; &#x60;GET /v1/connect/pinterest?profileId&#x3D;PROFILE_ID&amp;redirect_url&#x3D;https://yourapp.com/callback&amp;headless&#x3D;true&#x60; &#x60;GET /v1/connect/googlebusiness?profileId&#x3D;PROFILE_ID&amp;redirect_url&#x3D;https://yourapp.com/callback&amp;headless&#x3D;true&#x60; &#x60;GET /v1/connect/snapchat?profileId&#x3D;PROFILE_ID&amp;redirect_url&#x3D;https://yourapp.com/callback&amp;headless&#x3D;true&#x60;  After OAuth, the user is redirected directly to your &#x60;redirect_url&#x60; with OAuth data: - **Facebook:** &#x60;?profileId&#x3D;X&amp;tempToken&#x3D;Y&amp;userProfile&#x3D;Z&amp;connect_token&#x3D;CT&amp;platform&#x3D;facebook&amp;step&#x3D;select_page&#x60; - **LinkedIn:** &#x60;?profileId&#x3D;X&amp;pendingDataToken&#x3D;TOKEN&amp;connect_token&#x3D;CT&amp;platform&#x3D;linkedin&amp;step&#x3D;select_organization&#x60;   Use &#x60;GET /v1/connect/pending-data?token&#x3D;TOKEN&#x60; to fetch tempToken, userProfile, organizations, refreshToken. - **Pinterest:** &#x60;?profileId&#x3D;X&amp;tempToken&#x3D;Y&amp;userProfile&#x3D;Z&amp;connect_token&#x3D;CT&amp;platform&#x3D;pinterest&amp;step&#x3D;select_board&#x60; - **Google Business:** &#x60;?profileId&#x3D;X&amp;tempToken&#x3D;Y&amp;userProfile&#x3D;Z&amp;connect_token&#x3D;CT&amp;platform&#x3D;googlebusiness&amp;step&#x3D;select_location&#x60; - **Snapchat:** &#x60;?profileId&#x3D;X&amp;tempToken&#x3D;Y&amp;userProfile&#x3D;Z&amp;publicProfiles&#x3D;PROFILES&amp;connect_token&#x3D;CT&amp;platform&#x3D;snapchat&amp;step&#x3D;select_public_profile&#x60;   (publicProfiles contains &#x60;id&#x60;, &#x60;display_name&#x60;, &#x60;username&#x60;, &#x60;profile_image_url&#x60;, &#x60;subscriber_count&#x60;)  Then use the respective endpoints to build your custom UI: - Facebook: &#x60;/v1/connect/facebook/select-page&#x60; (GET to fetch, POST to save) - LinkedIn: &#x60;/v1/connect/linkedin/organizations&#x60; (GET to fetch logos), &#x60;/v1/connect/linkedin/select-organization&#x60; (POST to save) - Pinterest: &#x60;/v1/connect/pinterest/select-board&#x60; (GET to fetch, POST to save) - Google Business: &#x60;/v1/connect/googlebusiness/locations&#x60; (GET) and &#x60;/v1/connect/googlebusiness/select-location&#x60; (POST) - Snapchat: &#x60;/v1/connect/snapchat/select-profile&#x60; (POST to save selected public profile)  Example: &#x60;https://yourdomain.com/integrations/callback&#x60;  (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of GetConnectUrl200Response</returns>
        System.Threading.Tasks.Task<GetConnectUrl200Response> GetConnectUrlAsync(string platform, string profileId, string? redirectUrl = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Start OAuth connection for a platform
        /// </summary>
        /// <remarks>
        /// Initiate an OAuth connection flow for any supported social media platform.  **Standard Flow (Hosted UI):** For Facebook connections, Late hosts the page selection UI:  1. Call this endpoint with your API key and &#x60;redirect_url&#x60; (optional) 2. Redirect your user to the returned &#x60;authUrl&#x60; 3. After OAuth, the user is redirected to Late’s hosted page selector at      &#x60;/connect/facebook/select-page?profileId&#x3D;X&amp;tempToken&#x3D;Y&amp;userProfile&#x3D;Z&amp;redirect_url&#x3D;YOUR_URL&amp;connect_token&#x3D;CT&#x60; 4. After they pick a page, Late saves the connection and finally redirects to your &#x60;redirect_url&#x60; (if provided)  **Headless/Whitelabel Mode (Facebook, LinkedIn, Pinterest &amp; Google Business Profile):** Build your own fully branded selection UI while Late handles OAuth:  **Facebook:** 1. Call this endpoint with your API key and add &#x60;&amp;headless&#x3D;true&#x60;, e.g.      &#x60;GET /v1/connect/facebook?profileId&#x3D;PROFILE_ID&amp;redirect_url&#x3D;https://yourapp.com/callback&amp;headless&#x3D;true&#x60; 2. Redirect your user to the returned &#x60;authUrl&#x60; 3. After OAuth, the user is redirected directly to **your** &#x60;redirect_url&#x60; with:    - &#x60;profileId&#x60; – your Late profile ID      - &#x60;tempToken&#x60; – temporary Facebook access token      - &#x60;userProfile&#x60; – URL‑encoded JSON user profile      - &#x60;connect_token&#x60; – short‑lived connect token (for API auth)      - &#x60;platform&#x3D;facebook&#x60;      - &#x60;step&#x3D;select_page&#x60; 4. Use &#x60;tempToken&#x60;, &#x60;userProfile&#x60;, and the &#x60;X-Connect-Token&#x60; header with:    - &#x60;GET /v1/connect/facebook/select-page&#x60; to fetch pages    - &#x60;POST /v1/connect/facebook/select-page&#x60; to save the selected page 5. In this mode, users never see Late&#39;s hosted page selector – only your UI.  **LinkedIn:** 1. Call this endpoint with &#x60;&amp;headless&#x3D;true&#x60;, e.g.    &#x60;GET /v1/connect/linkedin?profileId&#x3D;PROFILE_ID&amp;redirect_url&#x3D;https://yourapp.com/callback&amp;headless&#x3D;true&#x60; 2. Redirect your user to the returned &#x60;authUrl&#x60; 3. After OAuth, the user is redirected directly to **your** &#x60;redirect_url&#x60; with:    - &#x60;profileId&#x60; – your Late profile ID    - &#x60;pendingDataToken&#x60; – token to fetch OAuth data via API (see step 4)    - &#x60;connect_token&#x60; – short-lived connect token (for API auth)    - &#x60;platform&#x3D;linkedin&#x60;    - &#x60;step&#x3D;select_organization&#x60; 4. Call &#x60;GET /v1/connect/pending-data?token&#x3D;PENDING_DATA_TOKEN&#x60; to fetch the OAuth data:    - &#x60;tempToken&#x60; – temporary LinkedIn access token    - &#x60;userProfile&#x60; – JSON object with &#x60;id&#x60;, &#x60;username&#x60;, &#x60;displayName&#x60;, &#x60;profilePicture&#x60;    - &#x60;organizations&#x60; – JSON array with &#x60;id&#x60;, &#x60;urn&#x60;, &#x60;name&#x60;, &#x60;vanityName&#x60; for each org    - &#x60;refreshToken&#x60; / &#x60;expiresIn&#x60; – token metadata    This endpoint is one-time use and data expires after 10 minutes. 5. **Optional:** To fetch full organization details (logos, website, industry, description), call &#x60;GET /v1/connect/linkedin/organizations?tempToken&#x3D;X&amp;orgIds&#x3D;id1,id2,...&#x60; 6. Call &#x60;POST /v1/connect/linkedin/select-organization&#x60; with the &#x60;X-Connect-Token&#x60; header to save the selection. 7. In this mode, users never see Late&#39;s hosted organization selector – only your UI. 8. Note: If the user has no organization admin access, &#x60;step&#x3D;select_organization&#x60; will NOT be present,    and the account will be connected directly as a personal account.  **Pinterest:** 1. Call this endpoint with &#x60;&amp;headless&#x3D;true&#x60;, e.g.    &#x60;GET /v1/connect/pinterest?profileId&#x3D;PROFILE_ID&amp;redirect_url&#x3D;https://yourapp.com/callback&amp;headless&#x3D;true&#x60; 2. Redirect your user to the returned &#x60;authUrl&#x60; 3. After OAuth, the user is redirected directly to **your** &#x60;redirect_url&#x60; with:    - &#x60;profileId&#x60; – your Late profile ID    - &#x60;tempToken&#x60; – temporary Pinterest access token    - &#x60;userProfile&#x60; – URL‑encoded JSON user profile    - &#x60;connect_token&#x60; – short‑lived connect token (for API auth)    - &#x60;platform&#x3D;pinterest&#x60;    - &#x60;step&#x3D;select_board&#x60; 4. Use &#x60;tempToken&#x60;, &#x60;userProfile&#x60;, and the &#x60;X-Connect-Token&#x60; header with:    - &#x60;GET /v1/connect/pinterest/select-board&#x60; to fetch boards    - &#x60;POST /v1/connect/pinterest/select-board&#x60; to save the selected board 5. In this mode, users never see Late&#39;s hosted board selector – only your UI.  **Google Business Profile:** 1. Call this endpoint with &#x60;&amp;headless&#x3D;true&#x60;, e.g.    &#x60;GET /v1/connect/googlebusiness?profileId&#x3D;PROFILE_ID&amp;redirect_url&#x3D;https://yourapp.com/callback&amp;headless&#x3D;true&#x60; 2. Redirect your user to the returned &#x60;authUrl&#x60; 3. After OAuth, the user is redirected directly to **your** &#x60;redirect_url&#x60; with:    - &#x60;profileId&#x60; – your Late profile ID    - &#x60;tempToken&#x60; – temporary Google access token    - &#x60;userProfile&#x60; – URL‑encoded JSON user profile (includes refresh token info)    - &#x60;connect_token&#x60; – short‑lived connect token (for API auth)    - &#x60;platform&#x3D;googlebusiness&#x60;    - &#x60;step&#x3D;select_location&#x60; 4. Use &#x60;tempToken&#x60;, &#x60;userProfile&#x60;, and the &#x60;X-Connect-Token&#x60; header with:    - &#x60;GET /v1/connect/googlebusiness/locations&#x60; to fetch business locations    - &#x60;POST /v1/connect/googlebusiness/select-location&#x60; to save the selected location 5. In this mode, users never see Late&#39;s hosted location selector – only your UI. 
        /// </remarks>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="platform">Social media platform to connect</param>
        /// <param name="profileId">Your Late profile ID (get from /v1/profiles)</param>
        /// <param name="redirectUrl">Optional: Your custom redirect URL after connection completes.  **Standard Mode:** Omit &#x60;headless&#x3D;true&#x60; to use our hosted page selection UI.   After the user selects a Facebook Page, Late redirects here with:   &#x60;?connected&#x3D;facebook&amp;profileId&#x3D;X&amp;username&#x3D;Y&#x60;  **Headless Mode (Facebook, LinkedIn, Pinterest, Google Business Profile &amp; Snapchat):** Pass &#x60;headless&#x3D;true&#x60; as a query parameter on this endpoint (not inside &#x60;redirect_url&#x60;), e.g.: &#x60;GET /v1/connect/facebook?profileId&#x3D;PROFILE_ID&amp;redirect_url&#x3D;https://yourapp.com/callback&amp;headless&#x3D;true&#x60; &#x60;GET /v1/connect/linkedin?profileId&#x3D;PROFILE_ID&amp;redirect_url&#x3D;https://yourapp.com/callback&amp;headless&#x3D;true&#x60; &#x60;GET /v1/connect/pinterest?profileId&#x3D;PROFILE_ID&amp;redirect_url&#x3D;https://yourapp.com/callback&amp;headless&#x3D;true&#x60; &#x60;GET /v1/connect/googlebusiness?profileId&#x3D;PROFILE_ID&amp;redirect_url&#x3D;https://yourapp.com/callback&amp;headless&#x3D;true&#x60; &#x60;GET /v1/connect/snapchat?profileId&#x3D;PROFILE_ID&amp;redirect_url&#x3D;https://yourapp.com/callback&amp;headless&#x3D;true&#x60;  After OAuth, the user is redirected directly to your &#x60;redirect_url&#x60; with OAuth data: - **Facebook:** &#x60;?profileId&#x3D;X&amp;tempToken&#x3D;Y&amp;userProfile&#x3D;Z&amp;connect_token&#x3D;CT&amp;platform&#x3D;facebook&amp;step&#x3D;select_page&#x60; - **LinkedIn:** &#x60;?profileId&#x3D;X&amp;pendingDataToken&#x3D;TOKEN&amp;connect_token&#x3D;CT&amp;platform&#x3D;linkedin&amp;step&#x3D;select_organization&#x60;   Use &#x60;GET /v1/connect/pending-data?token&#x3D;TOKEN&#x60; to fetch tempToken, userProfile, organizations, refreshToken. - **Pinterest:** &#x60;?profileId&#x3D;X&amp;tempToken&#x3D;Y&amp;userProfile&#x3D;Z&amp;connect_token&#x3D;CT&amp;platform&#x3D;pinterest&amp;step&#x3D;select_board&#x60; - **Google Business:** &#x60;?profileId&#x3D;X&amp;tempToken&#x3D;Y&amp;userProfile&#x3D;Z&amp;connect_token&#x3D;CT&amp;platform&#x3D;googlebusiness&amp;step&#x3D;select_location&#x60; - **Snapchat:** &#x60;?profileId&#x3D;X&amp;tempToken&#x3D;Y&amp;userProfile&#x3D;Z&amp;publicProfiles&#x3D;PROFILES&amp;connect_token&#x3D;CT&amp;platform&#x3D;snapchat&amp;step&#x3D;select_public_profile&#x60;   (publicProfiles contains &#x60;id&#x60;, &#x60;display_name&#x60;, &#x60;username&#x60;, &#x60;profile_image_url&#x60;, &#x60;subscriber_count&#x60;)  Then use the respective endpoints to build your custom UI: - Facebook: &#x60;/v1/connect/facebook/select-page&#x60; (GET to fetch, POST to save) - LinkedIn: &#x60;/v1/connect/linkedin/organizations&#x60; (GET to fetch logos), &#x60;/v1/connect/linkedin/select-organization&#x60; (POST to save) - Pinterest: &#x60;/v1/connect/pinterest/select-board&#x60; (GET to fetch, POST to save) - Google Business: &#x60;/v1/connect/googlebusiness/locations&#x60; (GET) and &#x60;/v1/connect/googlebusiness/select-location&#x60; (POST) - Snapchat: &#x60;/v1/connect/snapchat/select-profile&#x60; (POST to save selected public profile)  Example: &#x60;https://yourdomain.com/integrations/callback&#x60;  (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (GetConnectUrl200Response)</returns>
        System.Threading.Tasks.Task<ApiResponse<GetConnectUrl200Response>> GetConnectUrlWithHttpInfoAsync(string platform, string profileId, string? redirectUrl = default, System.Threading.CancellationToken cancellationToken = default);
        /// <summary>
        /// List available Facebook pages for a connected account
        /// </summary>
        /// <remarks>
        /// Returns all Facebook pages the connected account has access to, including the currently selected page.
        /// </remarks>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="accountId"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of GetFacebookPages200Response</returns>
        System.Threading.Tasks.Task<GetFacebookPages200Response> GetFacebookPagesAsync(string accountId, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// List available Facebook pages for a connected account
        /// </summary>
        /// <remarks>
        /// Returns all Facebook pages the connected account has access to, including the currently selected page.
        /// </remarks>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="accountId"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (GetFacebookPages200Response)</returns>
        System.Threading.Tasks.Task<ApiResponse<GetFacebookPages200Response>> GetFacebookPagesWithHttpInfoAsync(string accountId, System.Threading.CancellationToken cancellationToken = default);
        /// <summary>
        /// List available Google Business Profile locations for a connected account
        /// </summary>
        /// <remarks>
        /// Returns all Google Business Profile locations the connected account has access to, including the currently selected location.
        /// </remarks>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="accountId"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of GetGmbLocations200Response</returns>
        System.Threading.Tasks.Task<GetGmbLocations200Response> GetGmbLocationsAsync(string accountId, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// List available Google Business Profile locations for a connected account
        /// </summary>
        /// <remarks>
        /// Returns all Google Business Profile locations the connected account has access to, including the currently selected location.
        /// </remarks>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="accountId"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (GetGmbLocations200Response)</returns>
        System.Threading.Tasks.Task<ApiResponse<GetGmbLocations200Response>> GetGmbLocationsWithHttpInfoAsync(string accountId, System.Threading.CancellationToken cancellationToken = default);
        /// <summary>
        /// Get available LinkedIn organizations for a connected account
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="accountId"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of GetLinkedInOrganizations200Response</returns>
        System.Threading.Tasks.Task<GetLinkedInOrganizations200Response> GetLinkedInOrganizationsAsync(string accountId, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Get available LinkedIn organizations for a connected account
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="accountId"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (GetLinkedInOrganizations200Response)</returns>
        System.Threading.Tasks.Task<ApiResponse<GetLinkedInOrganizations200Response>> GetLinkedInOrganizationsWithHttpInfoAsync(string accountId, System.Threading.CancellationToken cancellationToken = default);
        /// <summary>
        /// Fetch pending OAuth selection data (Headless Mode)
        /// </summary>
        /// <remarks>
        /// **Fetch Pending OAuth Data for Headless Mode**  In headless mode, platforms like LinkedIn store OAuth selection data (organizations, pages, etc.) in the database instead of passing it via URL parameters. This prevents URI_TOO_LONG errors when users have many organizations/pages to select from.  After OAuth redirect, use the &#x60;pendingDataToken&#x60; from the URL to fetch the stored data.  **Important:** - This endpoint is one-time use: data is deleted after being fetched - Data expires automatically after 10 minutes if not fetched - No authentication required, just the token from the redirect URL 
        /// </remarks>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="token">The pending data token from the OAuth redirect URL (&#x60;pendingDataToken&#x60; parameter)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of GetPendingOAuthData200Response</returns>
        System.Threading.Tasks.Task<GetPendingOAuthData200Response> GetPendingOAuthDataAsync(string token, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Fetch pending OAuth selection data (Headless Mode)
        /// </summary>
        /// <remarks>
        /// **Fetch Pending OAuth Data for Headless Mode**  In headless mode, platforms like LinkedIn store OAuth selection data (organizations, pages, etc.) in the database instead of passing it via URL parameters. This prevents URI_TOO_LONG errors when users have many organizations/pages to select from.  After OAuth redirect, use the &#x60;pendingDataToken&#x60; from the URL to fetch the stored data.  **Important:** - This endpoint is one-time use: data is deleted after being fetched - Data expires automatically after 10 minutes if not fetched - No authentication required, just the token from the redirect URL 
        /// </remarks>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="token">The pending data token from the OAuth redirect URL (&#x60;pendingDataToken&#x60; parameter)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (GetPendingOAuthData200Response)</returns>
        System.Threading.Tasks.Task<ApiResponse<GetPendingOAuthData200Response>> GetPendingOAuthDataWithHttpInfoAsync(string token, System.Threading.CancellationToken cancellationToken = default);
        /// <summary>
        /// List Pinterest boards for a connected account
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="accountId"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of GetPinterestBoards200Response</returns>
        System.Threading.Tasks.Task<GetPinterestBoards200Response> GetPinterestBoardsAsync(string accountId, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// List Pinterest boards for a connected account
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="accountId"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (GetPinterestBoards200Response)</returns>
        System.Threading.Tasks.Task<ApiResponse<GetPinterestBoards200Response>> GetPinterestBoardsWithHttpInfoAsync(string accountId, System.Threading.CancellationToken cancellationToken = default);
        /// <summary>
        /// List Reddit subreddits for a connected account
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="accountId"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of GetRedditSubreddits200Response</returns>
        System.Threading.Tasks.Task<GetRedditSubreddits200Response> GetRedditSubredditsAsync(string accountId, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// List Reddit subreddits for a connected account
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="accountId"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (GetRedditSubreddits200Response)</returns>
        System.Threading.Tasks.Task<ApiResponse<GetRedditSubreddits200Response>> GetRedditSubredditsWithHttpInfoAsync(string accountId, System.Threading.CancellationToken cancellationToken = default);
        /// <summary>
        /// Generate Telegram access code
        /// </summary>
        /// <remarks>
        /// Generate a unique access code for connecting a Telegram channel or group.  **Connection Flow:** 1. Call this endpoint to get an access code (valid for 15 minutes) 2. Add the bot (@LateScheduleBot or your configured bot) as an administrator in your Telegram channel/group 3. Open a private chat with the bot 4. Send: &#x60;{CODE} @yourchannel&#x60; (e.g., &#x60;LATE-ABC123 @mychannel&#x60;) 5. Poll &#x60;PATCH /v1/connect/telegram?code&#x3D;{CODE}&#x60; to check connection status  **Alternative for private channels:** If your channel has no public username, forward any message from the channel to the bot along with the access code. 
        /// </remarks>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="profileId">The profile ID to connect the Telegram account to</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of GetTelegramConnectStatus200Response</returns>
        System.Threading.Tasks.Task<GetTelegramConnectStatus200Response> GetTelegramConnectStatusAsync(string profileId, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Generate Telegram access code
        /// </summary>
        /// <remarks>
        /// Generate a unique access code for connecting a Telegram channel or group.  **Connection Flow:** 1. Call this endpoint to get an access code (valid for 15 minutes) 2. Add the bot (@LateScheduleBot or your configured bot) as an administrator in your Telegram channel/group 3. Open a private chat with the bot 4. Send: &#x60;{CODE} @yourchannel&#x60; (e.g., &#x60;LATE-ABC123 @mychannel&#x60;) 5. Poll &#x60;PATCH /v1/connect/telegram?code&#x3D;{CODE}&#x60; to check connection status  **Alternative for private channels:** If your channel has no public username, forward any message from the channel to the bot along with the access code. 
        /// </remarks>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="profileId">The profile ID to connect the Telegram account to</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (GetTelegramConnectStatus200Response)</returns>
        System.Threading.Tasks.Task<ApiResponse<GetTelegramConnectStatus200Response>> GetTelegramConnectStatusWithHttpInfoAsync(string profileId, System.Threading.CancellationToken cancellationToken = default);
        /// <summary>
        /// Complete OAuth token exchange manually (for server-side flows)
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="platform"></param>
        /// <param name="handleOAuthCallbackRequest"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of void</returns>
        System.Threading.Tasks.Task HandleOAuthCallbackAsync(string platform, HandleOAuthCallbackRequest handleOAuthCallbackRequest, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Complete OAuth token exchange manually (for server-side flows)
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="platform"></param>
        /// <param name="handleOAuthCallbackRequest"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        System.Threading.Tasks.Task<ApiResponse<Object>> HandleOAuthCallbackWithHttpInfoAsync(string platform, HandleOAuthCallbackRequest handleOAuthCallbackRequest, System.Threading.CancellationToken cancellationToken = default);
        /// <summary>
        /// Direct Telegram connection (power users)
        /// </summary>
        /// <remarks>
        /// Connect a Telegram channel/group directly using the chat ID.  This is an alternative to the access code flow for power users who know their Telegram chat ID. The bot must already be added as an administrator in the channel/group. 
        /// </remarks>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="initiateTelegramConnectRequest"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of InitiateTelegramConnect200Response</returns>
        System.Threading.Tasks.Task<InitiateTelegramConnect200Response> InitiateTelegramConnectAsync(InitiateTelegramConnectRequest initiateTelegramConnectRequest, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Direct Telegram connection (power users)
        /// </summary>
        /// <remarks>
        /// Connect a Telegram channel/group directly using the chat ID.  This is an alternative to the access code flow for power users who know their Telegram chat ID. The bot must already be added as an administrator in the channel/group. 
        /// </remarks>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="initiateTelegramConnectRequest"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (InitiateTelegramConnect200Response)</returns>
        System.Threading.Tasks.Task<ApiResponse<InitiateTelegramConnect200Response>> InitiateTelegramConnectWithHttpInfoAsync(InitiateTelegramConnectRequest initiateTelegramConnectRequest, System.Threading.CancellationToken cancellationToken = default);
        /// <summary>
        /// List Facebook Pages after OAuth (Headless Mode)
        /// </summary>
        /// <remarks>
        /// **Headless Mode for Custom UI**  After initiating Facebook OAuth via &#x60;/v1/connect/facebook&#x60;, you&#39;ll be redirected to  &#x60;/connect/facebook/select-page&#x60; with query params including &#x60;tempToken&#x60; and &#x60;userProfile&#x60;.  For a **headless/whitelabeled flow**, extract these params from the URL and call this  endpoint to retrieve the list of Facebook Pages the user can manage. Then build your  own UI to let users select a page.  **Note:** Use the &#x60;X-Connect-Token&#x60; header if you initiated the connection via API key  (rather than a browser session). 
        /// </remarks>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="profileId">Profile ID from your connection flow</param>
        /// <param name="tempToken">Temporary Facebook access token from the OAuth callback redirect</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ListFacebookPages200Response</returns>
        System.Threading.Tasks.Task<ListFacebookPages200Response> ListFacebookPagesAsync(string profileId, string tempToken, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// List Facebook Pages after OAuth (Headless Mode)
        /// </summary>
        /// <remarks>
        /// **Headless Mode for Custom UI**  After initiating Facebook OAuth via &#x60;/v1/connect/facebook&#x60;, you&#39;ll be redirected to  &#x60;/connect/facebook/select-page&#x60; with query params including &#x60;tempToken&#x60; and &#x60;userProfile&#x60;.  For a **headless/whitelabeled flow**, extract these params from the URL and call this  endpoint to retrieve the list of Facebook Pages the user can manage. Then build your  own UI to let users select a page.  **Note:** Use the &#x60;X-Connect-Token&#x60; header if you initiated the connection via API key  (rather than a browser session). 
        /// </remarks>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="profileId">Profile ID from your connection flow</param>
        /// <param name="tempToken">Temporary Facebook access token from the OAuth callback redirect</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (ListFacebookPages200Response)</returns>
        System.Threading.Tasks.Task<ApiResponse<ListFacebookPages200Response>> ListFacebookPagesWithHttpInfoAsync(string profileId, string tempToken, System.Threading.CancellationToken cancellationToken = default);
        /// <summary>
        /// List Google Business Locations after OAuth (Headless Mode)
        /// </summary>
        /// <remarks>
        /// **Headless Mode for Custom UI**  After initiating Google Business OAuth via &#x60;/v1/connect/googlebusiness?headless&#x3D;true&#x60;, you&#39;ll be redirected  to your &#x60;redirect_url&#x60; with query params including &#x60;tempToken&#x60; and &#x60;userProfile&#x60;.  For a **headless/whitelabeled flow**, extract these params from the URL and call this  endpoint to retrieve the list of Google Business locations the user can manage. Then build your  own UI to let users select a location.  **Note:** Use the &#x60;X-Connect-Token&#x60; header if you initiated the connection via API key  (rather than a browser session). 
        /// </remarks>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="profileId">Profile ID from your connection flow</param>
        /// <param name="tempToken">Temporary Google access token from the OAuth callback redirect</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ListGoogleBusinessLocations200Response</returns>
        System.Threading.Tasks.Task<ListGoogleBusinessLocations200Response> ListGoogleBusinessLocationsAsync(string profileId, string tempToken, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// List Google Business Locations after OAuth (Headless Mode)
        /// </summary>
        /// <remarks>
        /// **Headless Mode for Custom UI**  After initiating Google Business OAuth via &#x60;/v1/connect/googlebusiness?headless&#x3D;true&#x60;, you&#39;ll be redirected  to your &#x60;redirect_url&#x60; with query params including &#x60;tempToken&#x60; and &#x60;userProfile&#x60;.  For a **headless/whitelabeled flow**, extract these params from the URL and call this  endpoint to retrieve the list of Google Business locations the user can manage. Then build your  own UI to let users select a location.  **Note:** Use the &#x60;X-Connect-Token&#x60; header if you initiated the connection via API key  (rather than a browser session). 
        /// </remarks>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="profileId">Profile ID from your connection flow</param>
        /// <param name="tempToken">Temporary Google access token from the OAuth callback redirect</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (ListGoogleBusinessLocations200Response)</returns>
        System.Threading.Tasks.Task<ApiResponse<ListGoogleBusinessLocations200Response>> ListGoogleBusinessLocationsWithHttpInfoAsync(string profileId, string tempToken, System.Threading.CancellationToken cancellationToken = default);
        /// <summary>
        /// Fetch full LinkedIn organization details (Headless Mode)
        /// </summary>
        /// <remarks>
        /// **Fetch Full Organization Details for Custom UI**  After LinkedIn OAuth in headless mode, the redirect URL contains organization data with only &#x60;id&#x60;, &#x60;urn&#x60;, and &#x60;name&#x60; fields (additional details are excluded to prevent URL length issues with many organizations).  Use this endpoint to fetch full organization details including logos, vanity names, websites, and more if you want to display them in your custom selection UI.  **Note:** This endpoint requires no authentication - just the &#x60;tempToken&#x60; from the OAuth redirect. Details are fetched directly from LinkedIn&#39;s API in parallel for fast response times. 
        /// </remarks>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="tempToken">The temporary LinkedIn access token from the OAuth redirect</param>
        /// <param name="orgIds">Comma-separated list of organization IDs to fetch details for (max 100)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ListLinkedInOrganizations200Response</returns>
        System.Threading.Tasks.Task<ListLinkedInOrganizations200Response> ListLinkedInOrganizationsAsync(string tempToken, string orgIds, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Fetch full LinkedIn organization details (Headless Mode)
        /// </summary>
        /// <remarks>
        /// **Fetch Full Organization Details for Custom UI**  After LinkedIn OAuth in headless mode, the redirect URL contains organization data with only &#x60;id&#x60;, &#x60;urn&#x60;, and &#x60;name&#x60; fields (additional details are excluded to prevent URL length issues with many organizations).  Use this endpoint to fetch full organization details including logos, vanity names, websites, and more if you want to display them in your custom selection UI.  **Note:** This endpoint requires no authentication - just the &#x60;tempToken&#x60; from the OAuth redirect. Details are fetched directly from LinkedIn&#39;s API in parallel for fast response times. 
        /// </remarks>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="tempToken">The temporary LinkedIn access token from the OAuth redirect</param>
        /// <param name="orgIds">Comma-separated list of organization IDs to fetch details for (max 100)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (ListLinkedInOrganizations200Response)</returns>
        System.Threading.Tasks.Task<ApiResponse<ListLinkedInOrganizations200Response>> ListLinkedInOrganizationsWithHttpInfoAsync(string tempToken, string orgIds, System.Threading.CancellationToken cancellationToken = default);
        /// <summary>
        /// List Pinterest Boards after OAuth (Headless Mode)
        /// </summary>
        /// <remarks>
        /// **Retrieve Pinterest Boards for Selection UI**  After initiating Pinterest OAuth via &#x60;/v1/connect/pinterest&#x60; with &#x60;headless&#x3D;true&#x60;, you&#39;ll be redirected to your &#x60;redirect_url&#x60; with query params including &#x60;tempToken&#x60; and &#x60;userProfile&#x60;.  If you want to build your own fully-branded board selector (instead of Late&#39;s hosted UI), call this endpoint to retrieve the list of Pinterest Boards the user can post to. Then build your UI and call &#x60;POST /v1/connect/pinterest/select-board&#x60; to save the selection.  **Authentication:** Use &#x60;X-Connect-Token&#x60; header with the &#x60;connect_token&#x60; from the redirect URL. 
        /// </remarks>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="xConnectToken">Short-lived connect token from the OAuth redirect</param>
        /// <param name="profileId">Your Late profile ID</param>
        /// <param name="tempToken">Temporary Pinterest access token from the OAuth callback redirect</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ListPinterestBoardsForSelection200Response</returns>
        System.Threading.Tasks.Task<ListPinterestBoardsForSelection200Response> ListPinterestBoardsForSelectionAsync(string xConnectToken, string profileId, string tempToken, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// List Pinterest Boards after OAuth (Headless Mode)
        /// </summary>
        /// <remarks>
        /// **Retrieve Pinterest Boards for Selection UI**  After initiating Pinterest OAuth via &#x60;/v1/connect/pinterest&#x60; with &#x60;headless&#x3D;true&#x60;, you&#39;ll be redirected to your &#x60;redirect_url&#x60; with query params including &#x60;tempToken&#x60; and &#x60;userProfile&#x60;.  If you want to build your own fully-branded board selector (instead of Late&#39;s hosted UI), call this endpoint to retrieve the list of Pinterest Boards the user can post to. Then build your UI and call &#x60;POST /v1/connect/pinterest/select-board&#x60; to save the selection.  **Authentication:** Use &#x60;X-Connect-Token&#x60; header with the &#x60;connect_token&#x60; from the redirect URL. 
        /// </remarks>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="xConnectToken">Short-lived connect token from the OAuth redirect</param>
        /// <param name="profileId">Your Late profile ID</param>
        /// <param name="tempToken">Temporary Pinterest access token from the OAuth callback redirect</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (ListPinterestBoardsForSelection200Response)</returns>
        System.Threading.Tasks.Task<ApiResponse<ListPinterestBoardsForSelection200Response>> ListPinterestBoardsForSelectionWithHttpInfoAsync(string xConnectToken, string profileId, string tempToken, System.Threading.CancellationToken cancellationToken = default);
        /// <summary>
        /// List Snapchat Public Profiles after OAuth (Headless Mode)
        /// </summary>
        /// <remarks>
        /// **Headless Mode for Custom UI**  After initiating Snapchat OAuth via &#x60;/v1/connect/snapchat?headless&#x3D;true&#x60;, you&#39;ll be redirected to your &#x60;redirect_url&#x60; with query params including &#x60;tempToken&#x60;, &#x60;userProfile&#x60;, and &#x60;publicProfiles&#x60;.  If you want to build your own fully-branded profile selector (instead of Late&#39;s hosted UI), call this endpoint to retrieve the list of Snapchat Public Profiles the user can post to. Then build your UI and call &#x60;POST /v1/connect/snapchat/select-profile&#x60; to save the selection.  **Authentication:** Use &#x60;X-Connect-Token&#x60; header with the &#x60;connect_token&#x60; from the redirect URL. 
        /// </remarks>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="xConnectToken">Short-lived connect token from the OAuth redirect</param>
        /// <param name="profileId">Your Late profile ID</param>
        /// <param name="tempToken">Temporary Snapchat access token from the OAuth callback redirect</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ListSnapchatProfiles200Response</returns>
        System.Threading.Tasks.Task<ListSnapchatProfiles200Response> ListSnapchatProfilesAsync(string xConnectToken, string profileId, string tempToken, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// List Snapchat Public Profiles after OAuth (Headless Mode)
        /// </summary>
        /// <remarks>
        /// **Headless Mode for Custom UI**  After initiating Snapchat OAuth via &#x60;/v1/connect/snapchat?headless&#x3D;true&#x60;, you&#39;ll be redirected to your &#x60;redirect_url&#x60; with query params including &#x60;tempToken&#x60;, &#x60;userProfile&#x60;, and &#x60;publicProfiles&#x60;.  If you want to build your own fully-branded profile selector (instead of Late&#39;s hosted UI), call this endpoint to retrieve the list of Snapchat Public Profiles the user can post to. Then build your UI and call &#x60;POST /v1/connect/snapchat/select-profile&#x60; to save the selection.  **Authentication:** Use &#x60;X-Connect-Token&#x60; header with the &#x60;connect_token&#x60; from the redirect URL. 
        /// </remarks>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="xConnectToken">Short-lived connect token from the OAuth redirect</param>
        /// <param name="profileId">Your Late profile ID</param>
        /// <param name="tempToken">Temporary Snapchat access token from the OAuth callback redirect</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (ListSnapchatProfiles200Response)</returns>
        System.Threading.Tasks.Task<ApiResponse<ListSnapchatProfiles200Response>> ListSnapchatProfilesWithHttpInfoAsync(string xConnectToken, string profileId, string tempToken, System.Threading.CancellationToken cancellationToken = default);
        /// <summary>
        /// Select a Facebook Page to complete the connection (Headless Mode)
        /// </summary>
        /// <remarks>
        /// **Complete the Headless Flow**  After displaying your custom UI with the list of pages from the GET endpoint, call this  endpoint to finalize the connection with the user&#39;s selected page.  The &#x60;userProfile&#x60; should be the decoded JSON object from the &#x60;userProfile&#x60; query param  in the OAuth callback redirect URL.  **Note:** Use the &#x60;X-Connect-Token&#x60; header if you initiated the connection via API key. 
        /// </remarks>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="selectFacebookPageRequest"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of SelectFacebookPage200Response</returns>
        System.Threading.Tasks.Task<SelectFacebookPage200Response> SelectFacebookPageAsync(SelectFacebookPageRequest selectFacebookPageRequest, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Select a Facebook Page to complete the connection (Headless Mode)
        /// </summary>
        /// <remarks>
        /// **Complete the Headless Flow**  After displaying your custom UI with the list of pages from the GET endpoint, call this  endpoint to finalize the connection with the user&#39;s selected page.  The &#x60;userProfile&#x60; should be the decoded JSON object from the &#x60;userProfile&#x60; query param  in the OAuth callback redirect URL.  **Note:** Use the &#x60;X-Connect-Token&#x60; header if you initiated the connection via API key. 
        /// </remarks>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="selectFacebookPageRequest"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (SelectFacebookPage200Response)</returns>
        System.Threading.Tasks.Task<ApiResponse<SelectFacebookPage200Response>> SelectFacebookPageWithHttpInfoAsync(SelectFacebookPageRequest selectFacebookPageRequest, System.Threading.CancellationToken cancellationToken = default);
        /// <summary>
        /// Select a Google Business location to complete the connection (Headless Mode)
        /// </summary>
        /// <remarks>
        /// **Complete the Headless Flow**  After displaying your custom UI with the list of locations from the GET &#x60;/v1/connect/googlebusiness/locations&#x60;  endpoint, call this endpoint to finalize the connection with the user&#39;s selected location.  The &#x60;userProfile&#x60; should be the decoded JSON object from the &#x60;userProfile&#x60; query param  in the OAuth callback redirect URL. It contains important token information (including refresh token).  **Note:** Use the &#x60;X-Connect-Token&#x60; header if you initiated the connection via API key. 
        /// </remarks>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="selectGoogleBusinessLocationRequest"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of SelectGoogleBusinessLocation200Response</returns>
        System.Threading.Tasks.Task<SelectGoogleBusinessLocation200Response> SelectGoogleBusinessLocationAsync(SelectGoogleBusinessLocationRequest selectGoogleBusinessLocationRequest, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Select a Google Business location to complete the connection (Headless Mode)
        /// </summary>
        /// <remarks>
        /// **Complete the Headless Flow**  After displaying your custom UI with the list of locations from the GET &#x60;/v1/connect/googlebusiness/locations&#x60;  endpoint, call this endpoint to finalize the connection with the user&#39;s selected location.  The &#x60;userProfile&#x60; should be the decoded JSON object from the &#x60;userProfile&#x60; query param  in the OAuth callback redirect URL. It contains important token information (including refresh token).  **Note:** Use the &#x60;X-Connect-Token&#x60; header if you initiated the connection via API key. 
        /// </remarks>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="selectGoogleBusinessLocationRequest"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (SelectGoogleBusinessLocation200Response)</returns>
        System.Threading.Tasks.Task<ApiResponse<SelectGoogleBusinessLocation200Response>> SelectGoogleBusinessLocationWithHttpInfoAsync(SelectGoogleBusinessLocationRequest selectGoogleBusinessLocationRequest, System.Threading.CancellationToken cancellationToken = default);
        /// <summary>
        /// Select LinkedIn organization or personal account after OAuth
        /// </summary>
        /// <remarks>
        /// **Complete the LinkedIn Connection Flow**  After OAuth, the user is redirected with &#x60;organizations&#x60; in the URL params (if they have org admin access). The organizations array contains &#x60;id&#x60;, &#x60;urn&#x60;, and &#x60;name&#x60; fields. Use this data to build your UI,  then call this endpoint to save the selection.  Set &#x60;accountType&#x60; to &#x60;personal&#x60; to connect as the user&#39;s personal LinkedIn profile, or &#x60;organization&#x60; to connect as a company page (requires &#x60;selectedOrganization&#x60; object).  **Personal Profile:** To connect a personal LinkedIn account, set &#x60;accountType&#x60; to &#x60;\&quot;personal\&quot;&#x60; and **omit** the &#x60;selectedOrganization&#x60; field entirely. This is the simplest flow.  **Headless Mode:** Use the &#x60;X-Connect-Token&#x60; header if you initiated the connection via API key. 
        /// </remarks>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="selectLinkedInOrganizationRequest"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of SelectLinkedInOrganization200Response</returns>
        System.Threading.Tasks.Task<SelectLinkedInOrganization200Response> SelectLinkedInOrganizationAsync(SelectLinkedInOrganizationRequest selectLinkedInOrganizationRequest, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Select LinkedIn organization or personal account after OAuth
        /// </summary>
        /// <remarks>
        /// **Complete the LinkedIn Connection Flow**  After OAuth, the user is redirected with &#x60;organizations&#x60; in the URL params (if they have org admin access). The organizations array contains &#x60;id&#x60;, &#x60;urn&#x60;, and &#x60;name&#x60; fields. Use this data to build your UI,  then call this endpoint to save the selection.  Set &#x60;accountType&#x60; to &#x60;personal&#x60; to connect as the user&#39;s personal LinkedIn profile, or &#x60;organization&#x60; to connect as a company page (requires &#x60;selectedOrganization&#x60; object).  **Personal Profile:** To connect a personal LinkedIn account, set &#x60;accountType&#x60; to &#x60;\&quot;personal\&quot;&#x60; and **omit** the &#x60;selectedOrganization&#x60; field entirely. This is the simplest flow.  **Headless Mode:** Use the &#x60;X-Connect-Token&#x60; header if you initiated the connection via API key. 
        /// </remarks>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="selectLinkedInOrganizationRequest"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (SelectLinkedInOrganization200Response)</returns>
        System.Threading.Tasks.Task<ApiResponse<SelectLinkedInOrganization200Response>> SelectLinkedInOrganizationWithHttpInfoAsync(SelectLinkedInOrganizationRequest selectLinkedInOrganizationRequest, System.Threading.CancellationToken cancellationToken = default);
        /// <summary>
        /// Select a Pinterest Board to complete the connection (Headless Mode)
        /// </summary>
        /// <remarks>
        /// **Complete the Pinterest Connection Flow**  After OAuth, use this endpoint to save the selected board and complete the Pinterest account connection.  **Headless Mode:** Use the &#x60;X-Connect-Token&#x60; header if you initiated the connection via API key. 
        /// </remarks>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="selectPinterestBoardRequest"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of SelectPinterestBoard200Response</returns>
        System.Threading.Tasks.Task<SelectPinterestBoard200Response> SelectPinterestBoardAsync(SelectPinterestBoardRequest selectPinterestBoardRequest, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Select a Pinterest Board to complete the connection (Headless Mode)
        /// </summary>
        /// <remarks>
        /// **Complete the Pinterest Connection Flow**  After OAuth, use this endpoint to save the selected board and complete the Pinterest account connection.  **Headless Mode:** Use the &#x60;X-Connect-Token&#x60; header if you initiated the connection via API key. 
        /// </remarks>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="selectPinterestBoardRequest"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (SelectPinterestBoard200Response)</returns>
        System.Threading.Tasks.Task<ApiResponse<SelectPinterestBoard200Response>> SelectPinterestBoardWithHttpInfoAsync(SelectPinterestBoardRequest selectPinterestBoardRequest, System.Threading.CancellationToken cancellationToken = default);
        /// <summary>
        /// Select a Snapchat Public Profile to complete the connection (Headless Mode)
        /// </summary>
        /// <remarks>
        /// **Complete the Snapchat Connection Flow**  After OAuth, use this endpoint to save the selected Public Profile and complete the Snapchat account connection. Snapchat requires a Public Profile to publish Stories, Saved Stories, and Spotlight content.  **Headless Mode:** Use the &#x60;X-Connect-Token&#x60; header if you initiated the connection via API key.  After initiating Snapchat OAuth via &#x60;/v1/connect/snapchat?headless&#x3D;true&#x60;, you&#39;ll be redirected to your &#x60;redirect_url&#x60; with query params including: - &#x60;tempToken&#x60; - Temporary access token - &#x60;userProfile&#x60; - URL-encoded JSON with user info - &#x60;publicProfiles&#x60; - URL-encoded JSON array of available public profiles - &#x60;connect_token&#x60; - Short-lived token for API authentication - &#x60;platform&#x3D;snapchat&#x60; - &#x60;step&#x3D;select_public_profile&#x60;  Parse &#x60;publicProfiles&#x60; to build your custom selector UI, then call this endpoint with the selected profile. 
        /// </remarks>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="selectSnapchatProfileRequest"></param>
        /// <param name="xConnectToken">Short-lived connect token from the OAuth redirect (for API users) (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of SelectSnapchatProfile200Response</returns>
        System.Threading.Tasks.Task<SelectSnapchatProfile200Response> SelectSnapchatProfileAsync(SelectSnapchatProfileRequest selectSnapchatProfileRequest, string? xConnectToken = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Select a Snapchat Public Profile to complete the connection (Headless Mode)
        /// </summary>
        /// <remarks>
        /// **Complete the Snapchat Connection Flow**  After OAuth, use this endpoint to save the selected Public Profile and complete the Snapchat account connection. Snapchat requires a Public Profile to publish Stories, Saved Stories, and Spotlight content.  **Headless Mode:** Use the &#x60;X-Connect-Token&#x60; header if you initiated the connection via API key.  After initiating Snapchat OAuth via &#x60;/v1/connect/snapchat?headless&#x3D;true&#x60;, you&#39;ll be redirected to your &#x60;redirect_url&#x60; with query params including: - &#x60;tempToken&#x60; - Temporary access token - &#x60;userProfile&#x60; - URL-encoded JSON with user info - &#x60;publicProfiles&#x60; - URL-encoded JSON array of available public profiles - &#x60;connect_token&#x60; - Short-lived token for API authentication - &#x60;platform&#x3D;snapchat&#x60; - &#x60;step&#x3D;select_public_profile&#x60;  Parse &#x60;publicProfiles&#x60; to build your custom selector UI, then call this endpoint with the selected profile. 
        /// </remarks>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="selectSnapchatProfileRequest"></param>
        /// <param name="xConnectToken">Short-lived connect token from the OAuth redirect (for API users) (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (SelectSnapchatProfile200Response)</returns>
        System.Threading.Tasks.Task<ApiResponse<SelectSnapchatProfile200Response>> SelectSnapchatProfileWithHttpInfoAsync(SelectSnapchatProfileRequest selectSnapchatProfileRequest, string? xConnectToken = default, System.Threading.CancellationToken cancellationToken = default);
        /// <summary>
        /// Update selected Facebook page for a connected account
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="accountId"></param>
        /// <param name="updateFacebookPageRequest"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of UpdateFacebookPage200Response</returns>
        System.Threading.Tasks.Task<UpdateFacebookPage200Response> UpdateFacebookPageAsync(string accountId, UpdateFacebookPageRequest updateFacebookPageRequest, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Update selected Facebook page for a connected account
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="accountId"></param>
        /// <param name="updateFacebookPageRequest"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (UpdateFacebookPage200Response)</returns>
        System.Threading.Tasks.Task<ApiResponse<UpdateFacebookPage200Response>> UpdateFacebookPageWithHttpInfoAsync(string accountId, UpdateFacebookPageRequest updateFacebookPageRequest, System.Threading.CancellationToken cancellationToken = default);
        /// <summary>
        /// Update selected Google Business Profile location for a connected account
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="accountId"></param>
        /// <param name="updateGmbLocationRequest"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of UpdateGmbLocation200Response</returns>
        System.Threading.Tasks.Task<UpdateGmbLocation200Response> UpdateGmbLocationAsync(string accountId, UpdateGmbLocationRequest updateGmbLocationRequest, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Update selected Google Business Profile location for a connected account
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="accountId"></param>
        /// <param name="updateGmbLocationRequest"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (UpdateGmbLocation200Response)</returns>
        System.Threading.Tasks.Task<ApiResponse<UpdateGmbLocation200Response>> UpdateGmbLocationWithHttpInfoAsync(string accountId, UpdateGmbLocationRequest updateGmbLocationRequest, System.Threading.CancellationToken cancellationToken = default);
        /// <summary>
        /// Switch LinkedIn account type (personal/organization)
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="accountId"></param>
        /// <param name="updateLinkedInOrganizationRequest"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ConnectBlueskyCredentials200Response</returns>
        System.Threading.Tasks.Task<ConnectBlueskyCredentials200Response> UpdateLinkedInOrganizationAsync(string accountId, UpdateLinkedInOrganizationRequest updateLinkedInOrganizationRequest, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Switch LinkedIn account type (personal/organization)
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="accountId"></param>
        /// <param name="updateLinkedInOrganizationRequest"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (ConnectBlueskyCredentials200Response)</returns>
        System.Threading.Tasks.Task<ApiResponse<ConnectBlueskyCredentials200Response>> UpdateLinkedInOrganizationWithHttpInfoAsync(string accountId, UpdateLinkedInOrganizationRequest updateLinkedInOrganizationRequest, System.Threading.CancellationToken cancellationToken = default);
        /// <summary>
        /// Set default Pinterest board on the connection
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="accountId"></param>
        /// <param name="updatePinterestBoardsRequest"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ConnectBlueskyCredentials200Response</returns>
        System.Threading.Tasks.Task<ConnectBlueskyCredentials200Response> UpdatePinterestBoardsAsync(string accountId, UpdatePinterestBoardsRequest updatePinterestBoardsRequest, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Set default Pinterest board on the connection
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="accountId"></param>
        /// <param name="updatePinterestBoardsRequest"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (ConnectBlueskyCredentials200Response)</returns>
        System.Threading.Tasks.Task<ApiResponse<ConnectBlueskyCredentials200Response>> UpdatePinterestBoardsWithHttpInfoAsync(string accountId, UpdatePinterestBoardsRequest updatePinterestBoardsRequest, System.Threading.CancellationToken cancellationToken = default);
        /// <summary>
        /// Set default subreddit on the connection
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="accountId"></param>
        /// <param name="updateRedditSubredditsRequest"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of UpdateRedditSubreddits200Response</returns>
        System.Threading.Tasks.Task<UpdateRedditSubreddits200Response> UpdateRedditSubredditsAsync(string accountId, UpdateRedditSubredditsRequest updateRedditSubredditsRequest, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Set default subreddit on the connection
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="accountId"></param>
        /// <param name="updateRedditSubredditsRequest"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (UpdateRedditSubreddits200Response)</returns>
        System.Threading.Tasks.Task<ApiResponse<UpdateRedditSubreddits200Response>> UpdateRedditSubredditsWithHttpInfoAsync(string accountId, UpdateRedditSubredditsRequest updateRedditSubredditsRequest, System.Threading.CancellationToken cancellationToken = default);
        #endregion Asynchronous Operations
    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public interface IConnectApi : IConnectApiSync, IConnectApiAsync
    {

    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public partial class ConnectApi : IDisposable, IConnectApi
    {
        private Late.Client.ExceptionFactory _exceptionFactory = (name, response) => null;

        /// <summary>
        /// Initializes a new instance of the <see cref="ConnectApi"/> class.
        /// **IMPORTANT** This will also create an instance of HttpClient, which is less than ideal.
        /// It's better to reuse the <see href="https://docs.microsoft.com/en-us/dotnet/architecture/microservices/implement-resilient-applications/use-httpclientfactory-to-implement-resilient-http-requests#issues-with-the-original-httpclient-class-available-in-net">HttpClient and HttpClientHandler</see>.
        /// </summary>
        /// <returns></returns>
        public ConnectApi() : this((string)null)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="ConnectApi"/> class.
        /// **IMPORTANT** This will also create an instance of HttpClient, which is less than ideal.
        /// It's better to reuse the <see href="https://docs.microsoft.com/en-us/dotnet/architecture/microservices/implement-resilient-applications/use-httpclientfactory-to-implement-resilient-http-requests#issues-with-the-original-httpclient-class-available-in-net">HttpClient and HttpClientHandler</see>.
        /// </summary>
        /// <param name="basePath">The target service's base path in URL format.</param>
        /// <exception cref="ArgumentException"></exception>
        /// <returns></returns>
        public ConnectApi(string basePath)
        {
            this.Configuration = Late.Client.Configuration.MergeConfigurations(
                Late.Client.GlobalConfiguration.Instance,
                new Late.Client.Configuration { BasePath = basePath }
            );
            this.ApiClient = new Late.Client.ApiClient(this.Configuration.BasePath);
            this.Client =  this.ApiClient;
            this.AsynchronousClient = this.ApiClient;
            this.ExceptionFactory = Late.Client.Configuration.DefaultExceptionFactory;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="ConnectApi"/> class using Configuration object.
        /// **IMPORTANT** This will also create an instance of HttpClient, which is less than ideal.
        /// It's better to reuse the <see href="https://docs.microsoft.com/en-us/dotnet/architecture/microservices/implement-resilient-applications/use-httpclientfactory-to-implement-resilient-http-requests#issues-with-the-original-httpclient-class-available-in-net">HttpClient and HttpClientHandler</see>.
        /// </summary>
        /// <param name="configuration">An instance of Configuration.</param>
        /// <exception cref="ArgumentNullException"></exception>
        /// <returns></returns>
        public ConnectApi(Late.Client.Configuration configuration)
        {
            if (configuration == null) throw new ArgumentNullException("configuration");

            this.Configuration = Late.Client.Configuration.MergeConfigurations(
                Late.Client.GlobalConfiguration.Instance,
                configuration
            );
            this.ApiClient = new Late.Client.ApiClient(this.Configuration.BasePath);
            this.Client = this.ApiClient;
            this.AsynchronousClient = this.ApiClient;
            ExceptionFactory = Late.Client.Configuration.DefaultExceptionFactory;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="ConnectApi"/> class.
        /// </summary>
        /// <param name="client">An instance of HttpClient.</param>
        /// <param name="handler">An optional instance of HttpClientHandler that is used by HttpClient.</param>
        /// <exception cref="ArgumentNullException"></exception>
        /// <returns></returns>
        /// <remarks>
        /// Some configuration settings will not be applied without passing an HttpClientHandler.
        /// The features affected are: Setting and Retrieving Cookies, Client Certificates, Proxy settings.
        /// </remarks>
        public ConnectApi(HttpClient client, HttpClientHandler handler = null) : this(client, (string)null, handler)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="ConnectApi"/> class.
        /// </summary>
        /// <param name="client">An instance of HttpClient.</param>
        /// <param name="basePath">The target service's base path in URL format.</param>
        /// <param name="handler">An optional instance of HttpClientHandler that is used by HttpClient.</param>
        /// <exception cref="ArgumentNullException"></exception>
        /// <exception cref="ArgumentException"></exception>
        /// <returns></returns>
        /// <remarks>
        /// Some configuration settings will not be applied without passing an HttpClientHandler.
        /// The features affected are: Setting and Retrieving Cookies, Client Certificates, Proxy settings.
        /// </remarks>
        public ConnectApi(HttpClient client, string basePath, HttpClientHandler handler = null)
        {
            if (client == null) throw new ArgumentNullException("client");

            this.Configuration = Late.Client.Configuration.MergeConfigurations(
                Late.Client.GlobalConfiguration.Instance,
                new Late.Client.Configuration { BasePath = basePath }
            );
            this.ApiClient = new Late.Client.ApiClient(client, this.Configuration.BasePath, handler);
            this.Client =  this.ApiClient;
            this.AsynchronousClient = this.ApiClient;
            this.ExceptionFactory = Late.Client.Configuration.DefaultExceptionFactory;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="ConnectApi"/> class using Configuration object.
        /// </summary>
        /// <param name="client">An instance of HttpClient.</param>
        /// <param name="configuration">An instance of Configuration.</param>
        /// <param name="handler">An optional instance of HttpClientHandler that is used by HttpClient.</param>
        /// <exception cref="ArgumentNullException"></exception>
        /// <returns></returns>
        /// <remarks>
        /// Some configuration settings will not be applied without passing an HttpClientHandler.
        /// The features affected are: Setting and Retrieving Cookies, Client Certificates, Proxy settings.
        /// </remarks>
        public ConnectApi(HttpClient client, Late.Client.Configuration configuration, HttpClientHandler handler = null)
        {
            if (configuration == null) throw new ArgumentNullException("configuration");
            if (client == null) throw new ArgumentNullException("client");

            this.Configuration = Late.Client.Configuration.MergeConfigurations(
                Late.Client.GlobalConfiguration.Instance,
                configuration
            );
            this.ApiClient = new Late.Client.ApiClient(client, this.Configuration.BasePath, handler);
            this.Client = this.ApiClient;
            this.AsynchronousClient = this.ApiClient;
            ExceptionFactory = Late.Client.Configuration.DefaultExceptionFactory;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="ConnectApi"/> class
        /// using a Configuration object and client instance.
        /// </summary>
        /// <param name="client">The client interface for synchronous API access.</param>
        /// <param name="asyncClient">The client interface for asynchronous API access.</param>
        /// <param name="configuration">The configuration object.</param>
        /// <exception cref="ArgumentNullException"></exception>
        public ConnectApi(Late.Client.ISynchronousClient client, Late.Client.IAsynchronousClient asyncClient, Late.Client.IReadableConfiguration configuration)
        {
            if (client == null) throw new ArgumentNullException("client");
            if (asyncClient == null) throw new ArgumentNullException("asyncClient");
            if (configuration == null) throw new ArgumentNullException("configuration");

            this.Client = client;
            this.AsynchronousClient = asyncClient;
            this.Configuration = configuration;
            this.ExceptionFactory = Late.Client.Configuration.DefaultExceptionFactory;
        }

        /// <summary>
        /// Disposes resources if they were created by us
        /// </summary>
        public void Dispose()
        {
            this.ApiClient?.Dispose();
        }

        /// <summary>
        /// Holds the ApiClient if created
        /// </summary>
        public Late.Client.ApiClient ApiClient { get; set; } = null;

        /// <summary>
        /// The client for accessing this underlying API asynchronously.
        /// </summary>
        public Late.Client.IAsynchronousClient AsynchronousClient { get; set; }

        /// <summary>
        /// The client for accessing this underlying API synchronously.
        /// </summary>
        public Late.Client.ISynchronousClient Client { get; set; }

        /// <summary>
        /// Gets the base path of the API client.
        /// </summary>
        /// <value>The base path</value>
        public string GetBasePath()
        {
            return this.Configuration.BasePath;
        }

        /// <summary>
        /// Gets or sets the configuration object
        /// </summary>
        /// <value>An instance of the Configuration</value>
        public Late.Client.IReadableConfiguration Configuration { get; set; }

        /// <summary>
        /// Provides a factory method hook for the creation of exceptions.
        /// </summary>
        public Late.Client.ExceptionFactory ExceptionFactory
        {
            get
            {
                if (_exceptionFactory != null && _exceptionFactory.GetInvocationList().Length > 1)
                {
                    throw new InvalidOperationException("Multicast delegate for ExceptionFactory is unsupported.");
                }
                return _exceptionFactory;
            }
            set { _exceptionFactory = value; }
        }

        /// <summary>
        /// Check Telegram connection status Poll this endpoint to check if a Telegram access code has been used to connect a channel/group.  **Recommended polling interval:** 3 seconds  **Status values:** - &#x60;pending&#x60;: Code is valid, waiting for user to complete connection - &#x60;connected&#x60;: Connection successful - channel/group is now linked - &#x60;expired&#x60;: Code has expired, generate a new one 
        /// </summary>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="code">The access code to check status for</param>
        /// <returns>CompleteTelegramConnect200Response</returns>
        public CompleteTelegramConnect200Response CompleteTelegramConnect(string code)
        {
            Late.Client.ApiResponse<CompleteTelegramConnect200Response> localVarResponse = CompleteTelegramConnectWithHttpInfo(code);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Check Telegram connection status Poll this endpoint to check if a Telegram access code has been used to connect a channel/group.  **Recommended polling interval:** 3 seconds  **Status values:** - &#x60;pending&#x60;: Code is valid, waiting for user to complete connection - &#x60;connected&#x60;: Connection successful - channel/group is now linked - &#x60;expired&#x60;: Code has expired, generate a new one 
        /// </summary>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="code">The access code to check status for</param>
        /// <returns>ApiResponse of CompleteTelegramConnect200Response</returns>
        public Late.Client.ApiResponse<CompleteTelegramConnect200Response> CompleteTelegramConnectWithHttpInfo(string code)
        {
            // verify the required parameter 'code' is set
            if (code == null)
                throw new Late.Client.ApiException(400, "Missing required parameter 'code' when calling ConnectApi->CompleteTelegramConnect");

            Late.Client.RequestOptions localVarRequestOptions = new Late.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Late.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Late.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.QueryParameters.Add(Late.Client.ClientUtils.ParameterToMultiMap("", "code", code));

            // authentication (bearerAuth) required
            // bearer authentication required
            if (!string.IsNullOrEmpty(this.Configuration.AccessToken) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
            }

            // make the HTTP request
            var localVarResponse = this.Client.Patch<CompleteTelegramConnect200Response>("/v1/connect/telegram", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("CompleteTelegramConnect", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Check Telegram connection status Poll this endpoint to check if a Telegram access code has been used to connect a channel/group.  **Recommended polling interval:** 3 seconds  **Status values:** - &#x60;pending&#x60;: Code is valid, waiting for user to complete connection - &#x60;connected&#x60;: Connection successful - channel/group is now linked - &#x60;expired&#x60;: Code has expired, generate a new one 
        /// </summary>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="code">The access code to check status for</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of CompleteTelegramConnect200Response</returns>
        public async System.Threading.Tasks.Task<CompleteTelegramConnect200Response> CompleteTelegramConnectAsync(string code, System.Threading.CancellationToken cancellationToken = default)
        {
            Late.Client.ApiResponse<CompleteTelegramConnect200Response> localVarResponse = await CompleteTelegramConnectWithHttpInfoAsync(code, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Check Telegram connection status Poll this endpoint to check if a Telegram access code has been used to connect a channel/group.  **Recommended polling interval:** 3 seconds  **Status values:** - &#x60;pending&#x60;: Code is valid, waiting for user to complete connection - &#x60;connected&#x60;: Connection successful - channel/group is now linked - &#x60;expired&#x60;: Code has expired, generate a new one 
        /// </summary>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="code">The access code to check status for</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (CompleteTelegramConnect200Response)</returns>
        public async System.Threading.Tasks.Task<Late.Client.ApiResponse<CompleteTelegramConnect200Response>> CompleteTelegramConnectWithHttpInfoAsync(string code, System.Threading.CancellationToken cancellationToken = default)
        {
            // verify the required parameter 'code' is set
            if (code == null)
                throw new Late.Client.ApiException(400, "Missing required parameter 'code' when calling ConnectApi->CompleteTelegramConnect");


            Late.Client.RequestOptions localVarRequestOptions = new Late.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };


            var localVarContentType = Late.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Late.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.QueryParameters.Add(Late.Client.ClientUtils.ParameterToMultiMap("", "code", code));

            // authentication (bearerAuth) required
            // bearer authentication required
            if (!string.IsNullOrEmpty(this.Configuration.AccessToken) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
            }

            // make the HTTP request

            var localVarResponse = await this.AsynchronousClient.PatchAsync<CompleteTelegramConnect200Response>("/v1/connect/telegram", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("CompleteTelegramConnect", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Connect Bluesky using app password Connect a Bluesky account using identifier (handle or email) and an app password.  To get your userId for the state parameter, call &#x60;GET /v1/users&#x60; - the response includes a &#x60;currentUserId&#x60; field. 
        /// </summary>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="connectBlueskyCredentialsRequest"></param>
        /// <returns>ConnectBlueskyCredentials200Response</returns>
        public ConnectBlueskyCredentials200Response ConnectBlueskyCredentials(ConnectBlueskyCredentialsRequest connectBlueskyCredentialsRequest)
        {
            Late.Client.ApiResponse<ConnectBlueskyCredentials200Response> localVarResponse = ConnectBlueskyCredentialsWithHttpInfo(connectBlueskyCredentialsRequest);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Connect Bluesky using app password Connect a Bluesky account using identifier (handle or email) and an app password.  To get your userId for the state parameter, call &#x60;GET /v1/users&#x60; - the response includes a &#x60;currentUserId&#x60; field. 
        /// </summary>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="connectBlueskyCredentialsRequest"></param>
        /// <returns>ApiResponse of ConnectBlueskyCredentials200Response</returns>
        public Late.Client.ApiResponse<ConnectBlueskyCredentials200Response> ConnectBlueskyCredentialsWithHttpInfo(ConnectBlueskyCredentialsRequest connectBlueskyCredentialsRequest)
        {
            // verify the required parameter 'connectBlueskyCredentialsRequest' is set
            if (connectBlueskyCredentialsRequest == null)
                throw new Late.Client.ApiException(400, "Missing required parameter 'connectBlueskyCredentialsRequest' when calling ConnectApi->ConnectBlueskyCredentials");

            Late.Client.RequestOptions localVarRequestOptions = new Late.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Late.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Late.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.Data = connectBlueskyCredentialsRequest;

            // authentication (bearerAuth) required
            // bearer authentication required
            if (!string.IsNullOrEmpty(this.Configuration.AccessToken) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
            }

            // make the HTTP request
            var localVarResponse = this.Client.Post<ConnectBlueskyCredentials200Response>("/v1/connect/bluesky/credentials", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ConnectBlueskyCredentials", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Connect Bluesky using app password Connect a Bluesky account using identifier (handle or email) and an app password.  To get your userId for the state parameter, call &#x60;GET /v1/users&#x60; - the response includes a &#x60;currentUserId&#x60; field. 
        /// </summary>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="connectBlueskyCredentialsRequest"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ConnectBlueskyCredentials200Response</returns>
        public async System.Threading.Tasks.Task<ConnectBlueskyCredentials200Response> ConnectBlueskyCredentialsAsync(ConnectBlueskyCredentialsRequest connectBlueskyCredentialsRequest, System.Threading.CancellationToken cancellationToken = default)
        {
            Late.Client.ApiResponse<ConnectBlueskyCredentials200Response> localVarResponse = await ConnectBlueskyCredentialsWithHttpInfoAsync(connectBlueskyCredentialsRequest, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Connect Bluesky using app password Connect a Bluesky account using identifier (handle or email) and an app password.  To get your userId for the state parameter, call &#x60;GET /v1/users&#x60; - the response includes a &#x60;currentUserId&#x60; field. 
        /// </summary>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="connectBlueskyCredentialsRequest"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (ConnectBlueskyCredentials200Response)</returns>
        public async System.Threading.Tasks.Task<Late.Client.ApiResponse<ConnectBlueskyCredentials200Response>> ConnectBlueskyCredentialsWithHttpInfoAsync(ConnectBlueskyCredentialsRequest connectBlueskyCredentialsRequest, System.Threading.CancellationToken cancellationToken = default)
        {
            // verify the required parameter 'connectBlueskyCredentialsRequest' is set
            if (connectBlueskyCredentialsRequest == null)
                throw new Late.Client.ApiException(400, "Missing required parameter 'connectBlueskyCredentialsRequest' when calling ConnectApi->ConnectBlueskyCredentials");


            Late.Client.RequestOptions localVarRequestOptions = new Late.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };


            var localVarContentType = Late.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Late.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.Data = connectBlueskyCredentialsRequest;

            // authentication (bearerAuth) required
            // bearer authentication required
            if (!string.IsNullOrEmpty(this.Configuration.AccessToken) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
            }

            // make the HTTP request

            var localVarResponse = await this.AsynchronousClient.PostAsync<ConnectBlueskyCredentials200Response>("/v1/connect/bluesky/credentials", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ConnectBlueskyCredentials", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Start OAuth connection for a platform Initiate an OAuth connection flow for any supported social media platform.  **Standard Flow (Hosted UI):** For Facebook connections, Late hosts the page selection UI:  1. Call this endpoint with your API key and &#x60;redirect_url&#x60; (optional) 2. Redirect your user to the returned &#x60;authUrl&#x60; 3. After OAuth, the user is redirected to Late’s hosted page selector at      &#x60;/connect/facebook/select-page?profileId&#x3D;X&amp;tempToken&#x3D;Y&amp;userProfile&#x3D;Z&amp;redirect_url&#x3D;YOUR_URL&amp;connect_token&#x3D;CT&#x60; 4. After they pick a page, Late saves the connection and finally redirects to your &#x60;redirect_url&#x60; (if provided)  **Headless/Whitelabel Mode (Facebook, LinkedIn, Pinterest &amp; Google Business Profile):** Build your own fully branded selection UI while Late handles OAuth:  **Facebook:** 1. Call this endpoint with your API key and add &#x60;&amp;headless&#x3D;true&#x60;, e.g.      &#x60;GET /v1/connect/facebook?profileId&#x3D;PROFILE_ID&amp;redirect_url&#x3D;https://yourapp.com/callback&amp;headless&#x3D;true&#x60; 2. Redirect your user to the returned &#x60;authUrl&#x60; 3. After OAuth, the user is redirected directly to **your** &#x60;redirect_url&#x60; with:    - &#x60;profileId&#x60; – your Late profile ID      - &#x60;tempToken&#x60; – temporary Facebook access token      - &#x60;userProfile&#x60; – URL‑encoded JSON user profile      - &#x60;connect_token&#x60; – short‑lived connect token (for API auth)      - &#x60;platform&#x3D;facebook&#x60;      - &#x60;step&#x3D;select_page&#x60; 4. Use &#x60;tempToken&#x60;, &#x60;userProfile&#x60;, and the &#x60;X-Connect-Token&#x60; header with:    - &#x60;GET /v1/connect/facebook/select-page&#x60; to fetch pages    - &#x60;POST /v1/connect/facebook/select-page&#x60; to save the selected page 5. In this mode, users never see Late&#39;s hosted page selector – only your UI.  **LinkedIn:** 1. Call this endpoint with &#x60;&amp;headless&#x3D;true&#x60;, e.g.    &#x60;GET /v1/connect/linkedin?profileId&#x3D;PROFILE_ID&amp;redirect_url&#x3D;https://yourapp.com/callback&amp;headless&#x3D;true&#x60; 2. Redirect your user to the returned &#x60;authUrl&#x60; 3. After OAuth, the user is redirected directly to **your** &#x60;redirect_url&#x60; with:    - &#x60;profileId&#x60; – your Late profile ID    - &#x60;pendingDataToken&#x60; – token to fetch OAuth data via API (see step 4)    - &#x60;connect_token&#x60; – short-lived connect token (for API auth)    - &#x60;platform&#x3D;linkedin&#x60;    - &#x60;step&#x3D;select_organization&#x60; 4. Call &#x60;GET /v1/connect/pending-data?token&#x3D;PENDING_DATA_TOKEN&#x60; to fetch the OAuth data:    - &#x60;tempToken&#x60; – temporary LinkedIn access token    - &#x60;userProfile&#x60; – JSON object with &#x60;id&#x60;, &#x60;username&#x60;, &#x60;displayName&#x60;, &#x60;profilePicture&#x60;    - &#x60;organizations&#x60; – JSON array with &#x60;id&#x60;, &#x60;urn&#x60;, &#x60;name&#x60;, &#x60;vanityName&#x60; for each org    - &#x60;refreshToken&#x60; / &#x60;expiresIn&#x60; – token metadata    This endpoint is one-time use and data expires after 10 minutes. 5. **Optional:** To fetch full organization details (logos, website, industry, description), call &#x60;GET /v1/connect/linkedin/organizations?tempToken&#x3D;X&amp;orgIds&#x3D;id1,id2,...&#x60; 6. Call &#x60;POST /v1/connect/linkedin/select-organization&#x60; with the &#x60;X-Connect-Token&#x60; header to save the selection. 7. In this mode, users never see Late&#39;s hosted organization selector – only your UI. 8. Note: If the user has no organization admin access, &#x60;step&#x3D;select_organization&#x60; will NOT be present,    and the account will be connected directly as a personal account.  **Pinterest:** 1. Call this endpoint with &#x60;&amp;headless&#x3D;true&#x60;, e.g.    &#x60;GET /v1/connect/pinterest?profileId&#x3D;PROFILE_ID&amp;redirect_url&#x3D;https://yourapp.com/callback&amp;headless&#x3D;true&#x60; 2. Redirect your user to the returned &#x60;authUrl&#x60; 3. After OAuth, the user is redirected directly to **your** &#x60;redirect_url&#x60; with:    - &#x60;profileId&#x60; – your Late profile ID    - &#x60;tempToken&#x60; – temporary Pinterest access token    - &#x60;userProfile&#x60; – URL‑encoded JSON user profile    - &#x60;connect_token&#x60; – short‑lived connect token (for API auth)    - &#x60;platform&#x3D;pinterest&#x60;    - &#x60;step&#x3D;select_board&#x60; 4. Use &#x60;tempToken&#x60;, &#x60;userProfile&#x60;, and the &#x60;X-Connect-Token&#x60; header with:    - &#x60;GET /v1/connect/pinterest/select-board&#x60; to fetch boards    - &#x60;POST /v1/connect/pinterest/select-board&#x60; to save the selected board 5. In this mode, users never see Late&#39;s hosted board selector – only your UI.  **Google Business Profile:** 1. Call this endpoint with &#x60;&amp;headless&#x3D;true&#x60;, e.g.    &#x60;GET /v1/connect/googlebusiness?profileId&#x3D;PROFILE_ID&amp;redirect_url&#x3D;https://yourapp.com/callback&amp;headless&#x3D;true&#x60; 2. Redirect your user to the returned &#x60;authUrl&#x60; 3. After OAuth, the user is redirected directly to **your** &#x60;redirect_url&#x60; with:    - &#x60;profileId&#x60; – your Late profile ID    - &#x60;tempToken&#x60; – temporary Google access token    - &#x60;userProfile&#x60; – URL‑encoded JSON user profile (includes refresh token info)    - &#x60;connect_token&#x60; – short‑lived connect token (for API auth)    - &#x60;platform&#x3D;googlebusiness&#x60;    - &#x60;step&#x3D;select_location&#x60; 4. Use &#x60;tempToken&#x60;, &#x60;userProfile&#x60;, and the &#x60;X-Connect-Token&#x60; header with:    - &#x60;GET /v1/connect/googlebusiness/locations&#x60; to fetch business locations    - &#x60;POST /v1/connect/googlebusiness/select-location&#x60; to save the selected location 5. In this mode, users never see Late&#39;s hosted location selector – only your UI. 
        /// </summary>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="platform">Social media platform to connect</param>
        /// <param name="profileId">Your Late profile ID (get from /v1/profiles)</param>
        /// <param name="redirectUrl">Optional: Your custom redirect URL after connection completes.  **Standard Mode:** Omit &#x60;headless&#x3D;true&#x60; to use our hosted page selection UI.   After the user selects a Facebook Page, Late redirects here with:   &#x60;?connected&#x3D;facebook&amp;profileId&#x3D;X&amp;username&#x3D;Y&#x60;  **Headless Mode (Facebook, LinkedIn, Pinterest, Google Business Profile &amp; Snapchat):** Pass &#x60;headless&#x3D;true&#x60; as a query parameter on this endpoint (not inside &#x60;redirect_url&#x60;), e.g.: &#x60;GET /v1/connect/facebook?profileId&#x3D;PROFILE_ID&amp;redirect_url&#x3D;https://yourapp.com/callback&amp;headless&#x3D;true&#x60; &#x60;GET /v1/connect/linkedin?profileId&#x3D;PROFILE_ID&amp;redirect_url&#x3D;https://yourapp.com/callback&amp;headless&#x3D;true&#x60; &#x60;GET /v1/connect/pinterest?profileId&#x3D;PROFILE_ID&amp;redirect_url&#x3D;https://yourapp.com/callback&amp;headless&#x3D;true&#x60; &#x60;GET /v1/connect/googlebusiness?profileId&#x3D;PROFILE_ID&amp;redirect_url&#x3D;https://yourapp.com/callback&amp;headless&#x3D;true&#x60; &#x60;GET /v1/connect/snapchat?profileId&#x3D;PROFILE_ID&amp;redirect_url&#x3D;https://yourapp.com/callback&amp;headless&#x3D;true&#x60;  After OAuth, the user is redirected directly to your &#x60;redirect_url&#x60; with OAuth data: - **Facebook:** &#x60;?profileId&#x3D;X&amp;tempToken&#x3D;Y&amp;userProfile&#x3D;Z&amp;connect_token&#x3D;CT&amp;platform&#x3D;facebook&amp;step&#x3D;select_page&#x60; - **LinkedIn:** &#x60;?profileId&#x3D;X&amp;pendingDataToken&#x3D;TOKEN&amp;connect_token&#x3D;CT&amp;platform&#x3D;linkedin&amp;step&#x3D;select_organization&#x60;   Use &#x60;GET /v1/connect/pending-data?token&#x3D;TOKEN&#x60; to fetch tempToken, userProfile, organizations, refreshToken. - **Pinterest:** &#x60;?profileId&#x3D;X&amp;tempToken&#x3D;Y&amp;userProfile&#x3D;Z&amp;connect_token&#x3D;CT&amp;platform&#x3D;pinterest&amp;step&#x3D;select_board&#x60; - **Google Business:** &#x60;?profileId&#x3D;X&amp;tempToken&#x3D;Y&amp;userProfile&#x3D;Z&amp;connect_token&#x3D;CT&amp;platform&#x3D;googlebusiness&amp;step&#x3D;select_location&#x60; - **Snapchat:** &#x60;?profileId&#x3D;X&amp;tempToken&#x3D;Y&amp;userProfile&#x3D;Z&amp;publicProfiles&#x3D;PROFILES&amp;connect_token&#x3D;CT&amp;platform&#x3D;snapchat&amp;step&#x3D;select_public_profile&#x60;   (publicProfiles contains &#x60;id&#x60;, &#x60;display_name&#x60;, &#x60;username&#x60;, &#x60;profile_image_url&#x60;, &#x60;subscriber_count&#x60;)  Then use the respective endpoints to build your custom UI: - Facebook: &#x60;/v1/connect/facebook/select-page&#x60; (GET to fetch, POST to save) - LinkedIn: &#x60;/v1/connect/linkedin/organizations&#x60; (GET to fetch logos), &#x60;/v1/connect/linkedin/select-organization&#x60; (POST to save) - Pinterest: &#x60;/v1/connect/pinterest/select-board&#x60; (GET to fetch, POST to save) - Google Business: &#x60;/v1/connect/googlebusiness/locations&#x60; (GET) and &#x60;/v1/connect/googlebusiness/select-location&#x60; (POST) - Snapchat: &#x60;/v1/connect/snapchat/select-profile&#x60; (POST to save selected public profile)  Example: &#x60;https://yourdomain.com/integrations/callback&#x60;  (optional)</param>
        /// <returns>GetConnectUrl200Response</returns>
        public GetConnectUrl200Response GetConnectUrl(string platform, string profileId, string? redirectUrl = default)
        {
            Late.Client.ApiResponse<GetConnectUrl200Response> localVarResponse = GetConnectUrlWithHttpInfo(platform, profileId, redirectUrl);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Start OAuth connection for a platform Initiate an OAuth connection flow for any supported social media platform.  **Standard Flow (Hosted UI):** For Facebook connections, Late hosts the page selection UI:  1. Call this endpoint with your API key and &#x60;redirect_url&#x60; (optional) 2. Redirect your user to the returned &#x60;authUrl&#x60; 3. After OAuth, the user is redirected to Late’s hosted page selector at      &#x60;/connect/facebook/select-page?profileId&#x3D;X&amp;tempToken&#x3D;Y&amp;userProfile&#x3D;Z&amp;redirect_url&#x3D;YOUR_URL&amp;connect_token&#x3D;CT&#x60; 4. After they pick a page, Late saves the connection and finally redirects to your &#x60;redirect_url&#x60; (if provided)  **Headless/Whitelabel Mode (Facebook, LinkedIn, Pinterest &amp; Google Business Profile):** Build your own fully branded selection UI while Late handles OAuth:  **Facebook:** 1. Call this endpoint with your API key and add &#x60;&amp;headless&#x3D;true&#x60;, e.g.      &#x60;GET /v1/connect/facebook?profileId&#x3D;PROFILE_ID&amp;redirect_url&#x3D;https://yourapp.com/callback&amp;headless&#x3D;true&#x60; 2. Redirect your user to the returned &#x60;authUrl&#x60; 3. After OAuth, the user is redirected directly to **your** &#x60;redirect_url&#x60; with:    - &#x60;profileId&#x60; – your Late profile ID      - &#x60;tempToken&#x60; – temporary Facebook access token      - &#x60;userProfile&#x60; – URL‑encoded JSON user profile      - &#x60;connect_token&#x60; – short‑lived connect token (for API auth)      - &#x60;platform&#x3D;facebook&#x60;      - &#x60;step&#x3D;select_page&#x60; 4. Use &#x60;tempToken&#x60;, &#x60;userProfile&#x60;, and the &#x60;X-Connect-Token&#x60; header with:    - &#x60;GET /v1/connect/facebook/select-page&#x60; to fetch pages    - &#x60;POST /v1/connect/facebook/select-page&#x60; to save the selected page 5. In this mode, users never see Late&#39;s hosted page selector – only your UI.  **LinkedIn:** 1. Call this endpoint with &#x60;&amp;headless&#x3D;true&#x60;, e.g.    &#x60;GET /v1/connect/linkedin?profileId&#x3D;PROFILE_ID&amp;redirect_url&#x3D;https://yourapp.com/callback&amp;headless&#x3D;true&#x60; 2. Redirect your user to the returned &#x60;authUrl&#x60; 3. After OAuth, the user is redirected directly to **your** &#x60;redirect_url&#x60; with:    - &#x60;profileId&#x60; – your Late profile ID    - &#x60;pendingDataToken&#x60; – token to fetch OAuth data via API (see step 4)    - &#x60;connect_token&#x60; – short-lived connect token (for API auth)    - &#x60;platform&#x3D;linkedin&#x60;    - &#x60;step&#x3D;select_organization&#x60; 4. Call &#x60;GET /v1/connect/pending-data?token&#x3D;PENDING_DATA_TOKEN&#x60; to fetch the OAuth data:    - &#x60;tempToken&#x60; – temporary LinkedIn access token    - &#x60;userProfile&#x60; – JSON object with &#x60;id&#x60;, &#x60;username&#x60;, &#x60;displayName&#x60;, &#x60;profilePicture&#x60;    - &#x60;organizations&#x60; – JSON array with &#x60;id&#x60;, &#x60;urn&#x60;, &#x60;name&#x60;, &#x60;vanityName&#x60; for each org    - &#x60;refreshToken&#x60; / &#x60;expiresIn&#x60; – token metadata    This endpoint is one-time use and data expires after 10 minutes. 5. **Optional:** To fetch full organization details (logos, website, industry, description), call &#x60;GET /v1/connect/linkedin/organizations?tempToken&#x3D;X&amp;orgIds&#x3D;id1,id2,...&#x60; 6. Call &#x60;POST /v1/connect/linkedin/select-organization&#x60; with the &#x60;X-Connect-Token&#x60; header to save the selection. 7. In this mode, users never see Late&#39;s hosted organization selector – only your UI. 8. Note: If the user has no organization admin access, &#x60;step&#x3D;select_organization&#x60; will NOT be present,    and the account will be connected directly as a personal account.  **Pinterest:** 1. Call this endpoint with &#x60;&amp;headless&#x3D;true&#x60;, e.g.    &#x60;GET /v1/connect/pinterest?profileId&#x3D;PROFILE_ID&amp;redirect_url&#x3D;https://yourapp.com/callback&amp;headless&#x3D;true&#x60; 2. Redirect your user to the returned &#x60;authUrl&#x60; 3. After OAuth, the user is redirected directly to **your** &#x60;redirect_url&#x60; with:    - &#x60;profileId&#x60; – your Late profile ID    - &#x60;tempToken&#x60; – temporary Pinterest access token    - &#x60;userProfile&#x60; – URL‑encoded JSON user profile    - &#x60;connect_token&#x60; – short‑lived connect token (for API auth)    - &#x60;platform&#x3D;pinterest&#x60;    - &#x60;step&#x3D;select_board&#x60; 4. Use &#x60;tempToken&#x60;, &#x60;userProfile&#x60;, and the &#x60;X-Connect-Token&#x60; header with:    - &#x60;GET /v1/connect/pinterest/select-board&#x60; to fetch boards    - &#x60;POST /v1/connect/pinterest/select-board&#x60; to save the selected board 5. In this mode, users never see Late&#39;s hosted board selector – only your UI.  **Google Business Profile:** 1. Call this endpoint with &#x60;&amp;headless&#x3D;true&#x60;, e.g.    &#x60;GET /v1/connect/googlebusiness?profileId&#x3D;PROFILE_ID&amp;redirect_url&#x3D;https://yourapp.com/callback&amp;headless&#x3D;true&#x60; 2. Redirect your user to the returned &#x60;authUrl&#x60; 3. After OAuth, the user is redirected directly to **your** &#x60;redirect_url&#x60; with:    - &#x60;profileId&#x60; – your Late profile ID    - &#x60;tempToken&#x60; – temporary Google access token    - &#x60;userProfile&#x60; – URL‑encoded JSON user profile (includes refresh token info)    - &#x60;connect_token&#x60; – short‑lived connect token (for API auth)    - &#x60;platform&#x3D;googlebusiness&#x60;    - &#x60;step&#x3D;select_location&#x60; 4. Use &#x60;tempToken&#x60;, &#x60;userProfile&#x60;, and the &#x60;X-Connect-Token&#x60; header with:    - &#x60;GET /v1/connect/googlebusiness/locations&#x60; to fetch business locations    - &#x60;POST /v1/connect/googlebusiness/select-location&#x60; to save the selected location 5. In this mode, users never see Late&#39;s hosted location selector – only your UI. 
        /// </summary>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="platform">Social media platform to connect</param>
        /// <param name="profileId">Your Late profile ID (get from /v1/profiles)</param>
        /// <param name="redirectUrl">Optional: Your custom redirect URL after connection completes.  **Standard Mode:** Omit &#x60;headless&#x3D;true&#x60; to use our hosted page selection UI.   After the user selects a Facebook Page, Late redirects here with:   &#x60;?connected&#x3D;facebook&amp;profileId&#x3D;X&amp;username&#x3D;Y&#x60;  **Headless Mode (Facebook, LinkedIn, Pinterest, Google Business Profile &amp; Snapchat):** Pass &#x60;headless&#x3D;true&#x60; as a query parameter on this endpoint (not inside &#x60;redirect_url&#x60;), e.g.: &#x60;GET /v1/connect/facebook?profileId&#x3D;PROFILE_ID&amp;redirect_url&#x3D;https://yourapp.com/callback&amp;headless&#x3D;true&#x60; &#x60;GET /v1/connect/linkedin?profileId&#x3D;PROFILE_ID&amp;redirect_url&#x3D;https://yourapp.com/callback&amp;headless&#x3D;true&#x60; &#x60;GET /v1/connect/pinterest?profileId&#x3D;PROFILE_ID&amp;redirect_url&#x3D;https://yourapp.com/callback&amp;headless&#x3D;true&#x60; &#x60;GET /v1/connect/googlebusiness?profileId&#x3D;PROFILE_ID&amp;redirect_url&#x3D;https://yourapp.com/callback&amp;headless&#x3D;true&#x60; &#x60;GET /v1/connect/snapchat?profileId&#x3D;PROFILE_ID&amp;redirect_url&#x3D;https://yourapp.com/callback&amp;headless&#x3D;true&#x60;  After OAuth, the user is redirected directly to your &#x60;redirect_url&#x60; with OAuth data: - **Facebook:** &#x60;?profileId&#x3D;X&amp;tempToken&#x3D;Y&amp;userProfile&#x3D;Z&amp;connect_token&#x3D;CT&amp;platform&#x3D;facebook&amp;step&#x3D;select_page&#x60; - **LinkedIn:** &#x60;?profileId&#x3D;X&amp;pendingDataToken&#x3D;TOKEN&amp;connect_token&#x3D;CT&amp;platform&#x3D;linkedin&amp;step&#x3D;select_organization&#x60;   Use &#x60;GET /v1/connect/pending-data?token&#x3D;TOKEN&#x60; to fetch tempToken, userProfile, organizations, refreshToken. - **Pinterest:** &#x60;?profileId&#x3D;X&amp;tempToken&#x3D;Y&amp;userProfile&#x3D;Z&amp;connect_token&#x3D;CT&amp;platform&#x3D;pinterest&amp;step&#x3D;select_board&#x60; - **Google Business:** &#x60;?profileId&#x3D;X&amp;tempToken&#x3D;Y&amp;userProfile&#x3D;Z&amp;connect_token&#x3D;CT&amp;platform&#x3D;googlebusiness&amp;step&#x3D;select_location&#x60; - **Snapchat:** &#x60;?profileId&#x3D;X&amp;tempToken&#x3D;Y&amp;userProfile&#x3D;Z&amp;publicProfiles&#x3D;PROFILES&amp;connect_token&#x3D;CT&amp;platform&#x3D;snapchat&amp;step&#x3D;select_public_profile&#x60;   (publicProfiles contains &#x60;id&#x60;, &#x60;display_name&#x60;, &#x60;username&#x60;, &#x60;profile_image_url&#x60;, &#x60;subscriber_count&#x60;)  Then use the respective endpoints to build your custom UI: - Facebook: &#x60;/v1/connect/facebook/select-page&#x60; (GET to fetch, POST to save) - LinkedIn: &#x60;/v1/connect/linkedin/organizations&#x60; (GET to fetch logos), &#x60;/v1/connect/linkedin/select-organization&#x60; (POST to save) - Pinterest: &#x60;/v1/connect/pinterest/select-board&#x60; (GET to fetch, POST to save) - Google Business: &#x60;/v1/connect/googlebusiness/locations&#x60; (GET) and &#x60;/v1/connect/googlebusiness/select-location&#x60; (POST) - Snapchat: &#x60;/v1/connect/snapchat/select-profile&#x60; (POST to save selected public profile)  Example: &#x60;https://yourdomain.com/integrations/callback&#x60;  (optional)</param>
        /// <returns>ApiResponse of GetConnectUrl200Response</returns>
        public Late.Client.ApiResponse<GetConnectUrl200Response> GetConnectUrlWithHttpInfo(string platform, string profileId, string? redirectUrl = default)
        {
            // verify the required parameter 'platform' is set
            if (platform == null)
                throw new Late.Client.ApiException(400, "Missing required parameter 'platform' when calling ConnectApi->GetConnectUrl");

            // verify the required parameter 'profileId' is set
            if (profileId == null)
                throw new Late.Client.ApiException(400, "Missing required parameter 'profileId' when calling ConnectApi->GetConnectUrl");

            Late.Client.RequestOptions localVarRequestOptions = new Late.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Late.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Late.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("platform", Late.Client.ClientUtils.ParameterToString(platform)); // path parameter
            localVarRequestOptions.QueryParameters.Add(Late.Client.ClientUtils.ParameterToMultiMap("", "profileId", profileId));
            if (redirectUrl != null)
            {
                localVarRequestOptions.QueryParameters.Add(Late.Client.ClientUtils.ParameterToMultiMap("", "redirect_url", redirectUrl));
            }

            // authentication (bearerAuth) required
            // bearer authentication required
            if (!string.IsNullOrEmpty(this.Configuration.AccessToken) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
            }

            // make the HTTP request
            var localVarResponse = this.Client.Get<GetConnectUrl200Response>("/v1/connect/{platform}", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetConnectUrl", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Start OAuth connection for a platform Initiate an OAuth connection flow for any supported social media platform.  **Standard Flow (Hosted UI):** For Facebook connections, Late hosts the page selection UI:  1. Call this endpoint with your API key and &#x60;redirect_url&#x60; (optional) 2. Redirect your user to the returned &#x60;authUrl&#x60; 3. After OAuth, the user is redirected to Late’s hosted page selector at      &#x60;/connect/facebook/select-page?profileId&#x3D;X&amp;tempToken&#x3D;Y&amp;userProfile&#x3D;Z&amp;redirect_url&#x3D;YOUR_URL&amp;connect_token&#x3D;CT&#x60; 4. After they pick a page, Late saves the connection and finally redirects to your &#x60;redirect_url&#x60; (if provided)  **Headless/Whitelabel Mode (Facebook, LinkedIn, Pinterest &amp; Google Business Profile):** Build your own fully branded selection UI while Late handles OAuth:  **Facebook:** 1. Call this endpoint with your API key and add &#x60;&amp;headless&#x3D;true&#x60;, e.g.      &#x60;GET /v1/connect/facebook?profileId&#x3D;PROFILE_ID&amp;redirect_url&#x3D;https://yourapp.com/callback&amp;headless&#x3D;true&#x60; 2. Redirect your user to the returned &#x60;authUrl&#x60; 3. After OAuth, the user is redirected directly to **your** &#x60;redirect_url&#x60; with:    - &#x60;profileId&#x60; – your Late profile ID      - &#x60;tempToken&#x60; – temporary Facebook access token      - &#x60;userProfile&#x60; – URL‑encoded JSON user profile      - &#x60;connect_token&#x60; – short‑lived connect token (for API auth)      - &#x60;platform&#x3D;facebook&#x60;      - &#x60;step&#x3D;select_page&#x60; 4. Use &#x60;tempToken&#x60;, &#x60;userProfile&#x60;, and the &#x60;X-Connect-Token&#x60; header with:    - &#x60;GET /v1/connect/facebook/select-page&#x60; to fetch pages    - &#x60;POST /v1/connect/facebook/select-page&#x60; to save the selected page 5. In this mode, users never see Late&#39;s hosted page selector – only your UI.  **LinkedIn:** 1. Call this endpoint with &#x60;&amp;headless&#x3D;true&#x60;, e.g.    &#x60;GET /v1/connect/linkedin?profileId&#x3D;PROFILE_ID&amp;redirect_url&#x3D;https://yourapp.com/callback&amp;headless&#x3D;true&#x60; 2. Redirect your user to the returned &#x60;authUrl&#x60; 3. After OAuth, the user is redirected directly to **your** &#x60;redirect_url&#x60; with:    - &#x60;profileId&#x60; – your Late profile ID    - &#x60;pendingDataToken&#x60; – token to fetch OAuth data via API (see step 4)    - &#x60;connect_token&#x60; – short-lived connect token (for API auth)    - &#x60;platform&#x3D;linkedin&#x60;    - &#x60;step&#x3D;select_organization&#x60; 4. Call &#x60;GET /v1/connect/pending-data?token&#x3D;PENDING_DATA_TOKEN&#x60; to fetch the OAuth data:    - &#x60;tempToken&#x60; – temporary LinkedIn access token    - &#x60;userProfile&#x60; – JSON object with &#x60;id&#x60;, &#x60;username&#x60;, &#x60;displayName&#x60;, &#x60;profilePicture&#x60;    - &#x60;organizations&#x60; – JSON array with &#x60;id&#x60;, &#x60;urn&#x60;, &#x60;name&#x60;, &#x60;vanityName&#x60; for each org    - &#x60;refreshToken&#x60; / &#x60;expiresIn&#x60; – token metadata    This endpoint is one-time use and data expires after 10 minutes. 5. **Optional:** To fetch full organization details (logos, website, industry, description), call &#x60;GET /v1/connect/linkedin/organizations?tempToken&#x3D;X&amp;orgIds&#x3D;id1,id2,...&#x60; 6. Call &#x60;POST /v1/connect/linkedin/select-organization&#x60; with the &#x60;X-Connect-Token&#x60; header to save the selection. 7. In this mode, users never see Late&#39;s hosted organization selector – only your UI. 8. Note: If the user has no organization admin access, &#x60;step&#x3D;select_organization&#x60; will NOT be present,    and the account will be connected directly as a personal account.  **Pinterest:** 1. Call this endpoint with &#x60;&amp;headless&#x3D;true&#x60;, e.g.    &#x60;GET /v1/connect/pinterest?profileId&#x3D;PROFILE_ID&amp;redirect_url&#x3D;https://yourapp.com/callback&amp;headless&#x3D;true&#x60; 2. Redirect your user to the returned &#x60;authUrl&#x60; 3. After OAuth, the user is redirected directly to **your** &#x60;redirect_url&#x60; with:    - &#x60;profileId&#x60; – your Late profile ID    - &#x60;tempToken&#x60; – temporary Pinterest access token    - &#x60;userProfile&#x60; – URL‑encoded JSON user profile    - &#x60;connect_token&#x60; – short‑lived connect token (for API auth)    - &#x60;platform&#x3D;pinterest&#x60;    - &#x60;step&#x3D;select_board&#x60; 4. Use &#x60;tempToken&#x60;, &#x60;userProfile&#x60;, and the &#x60;X-Connect-Token&#x60; header with:    - &#x60;GET /v1/connect/pinterest/select-board&#x60; to fetch boards    - &#x60;POST /v1/connect/pinterest/select-board&#x60; to save the selected board 5. In this mode, users never see Late&#39;s hosted board selector – only your UI.  **Google Business Profile:** 1. Call this endpoint with &#x60;&amp;headless&#x3D;true&#x60;, e.g.    &#x60;GET /v1/connect/googlebusiness?profileId&#x3D;PROFILE_ID&amp;redirect_url&#x3D;https://yourapp.com/callback&amp;headless&#x3D;true&#x60; 2. Redirect your user to the returned &#x60;authUrl&#x60; 3. After OAuth, the user is redirected directly to **your** &#x60;redirect_url&#x60; with:    - &#x60;profileId&#x60; – your Late profile ID    - &#x60;tempToken&#x60; – temporary Google access token    - &#x60;userProfile&#x60; – URL‑encoded JSON user profile (includes refresh token info)    - &#x60;connect_token&#x60; – short‑lived connect token (for API auth)    - &#x60;platform&#x3D;googlebusiness&#x60;    - &#x60;step&#x3D;select_location&#x60; 4. Use &#x60;tempToken&#x60;, &#x60;userProfile&#x60;, and the &#x60;X-Connect-Token&#x60; header with:    - &#x60;GET /v1/connect/googlebusiness/locations&#x60; to fetch business locations    - &#x60;POST /v1/connect/googlebusiness/select-location&#x60; to save the selected location 5. In this mode, users never see Late&#39;s hosted location selector – only your UI. 
        /// </summary>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="platform">Social media platform to connect</param>
        /// <param name="profileId">Your Late profile ID (get from /v1/profiles)</param>
        /// <param name="redirectUrl">Optional: Your custom redirect URL after connection completes.  **Standard Mode:** Omit &#x60;headless&#x3D;true&#x60; to use our hosted page selection UI.   After the user selects a Facebook Page, Late redirects here with:   &#x60;?connected&#x3D;facebook&amp;profileId&#x3D;X&amp;username&#x3D;Y&#x60;  **Headless Mode (Facebook, LinkedIn, Pinterest, Google Business Profile &amp; Snapchat):** Pass &#x60;headless&#x3D;true&#x60; as a query parameter on this endpoint (not inside &#x60;redirect_url&#x60;), e.g.: &#x60;GET /v1/connect/facebook?profileId&#x3D;PROFILE_ID&amp;redirect_url&#x3D;https://yourapp.com/callback&amp;headless&#x3D;true&#x60; &#x60;GET /v1/connect/linkedin?profileId&#x3D;PROFILE_ID&amp;redirect_url&#x3D;https://yourapp.com/callback&amp;headless&#x3D;true&#x60; &#x60;GET /v1/connect/pinterest?profileId&#x3D;PROFILE_ID&amp;redirect_url&#x3D;https://yourapp.com/callback&amp;headless&#x3D;true&#x60; &#x60;GET /v1/connect/googlebusiness?profileId&#x3D;PROFILE_ID&amp;redirect_url&#x3D;https://yourapp.com/callback&amp;headless&#x3D;true&#x60; &#x60;GET /v1/connect/snapchat?profileId&#x3D;PROFILE_ID&amp;redirect_url&#x3D;https://yourapp.com/callback&amp;headless&#x3D;true&#x60;  After OAuth, the user is redirected directly to your &#x60;redirect_url&#x60; with OAuth data: - **Facebook:** &#x60;?profileId&#x3D;X&amp;tempToken&#x3D;Y&amp;userProfile&#x3D;Z&amp;connect_token&#x3D;CT&amp;platform&#x3D;facebook&amp;step&#x3D;select_page&#x60; - **LinkedIn:** &#x60;?profileId&#x3D;X&amp;pendingDataToken&#x3D;TOKEN&amp;connect_token&#x3D;CT&amp;platform&#x3D;linkedin&amp;step&#x3D;select_organization&#x60;   Use &#x60;GET /v1/connect/pending-data?token&#x3D;TOKEN&#x60; to fetch tempToken, userProfile, organizations, refreshToken. - **Pinterest:** &#x60;?profileId&#x3D;X&amp;tempToken&#x3D;Y&amp;userProfile&#x3D;Z&amp;connect_token&#x3D;CT&amp;platform&#x3D;pinterest&amp;step&#x3D;select_board&#x60; - **Google Business:** &#x60;?profileId&#x3D;X&amp;tempToken&#x3D;Y&amp;userProfile&#x3D;Z&amp;connect_token&#x3D;CT&amp;platform&#x3D;googlebusiness&amp;step&#x3D;select_location&#x60; - **Snapchat:** &#x60;?profileId&#x3D;X&amp;tempToken&#x3D;Y&amp;userProfile&#x3D;Z&amp;publicProfiles&#x3D;PROFILES&amp;connect_token&#x3D;CT&amp;platform&#x3D;snapchat&amp;step&#x3D;select_public_profile&#x60;   (publicProfiles contains &#x60;id&#x60;, &#x60;display_name&#x60;, &#x60;username&#x60;, &#x60;profile_image_url&#x60;, &#x60;subscriber_count&#x60;)  Then use the respective endpoints to build your custom UI: - Facebook: &#x60;/v1/connect/facebook/select-page&#x60; (GET to fetch, POST to save) - LinkedIn: &#x60;/v1/connect/linkedin/organizations&#x60; (GET to fetch logos), &#x60;/v1/connect/linkedin/select-organization&#x60; (POST to save) - Pinterest: &#x60;/v1/connect/pinterest/select-board&#x60; (GET to fetch, POST to save) - Google Business: &#x60;/v1/connect/googlebusiness/locations&#x60; (GET) and &#x60;/v1/connect/googlebusiness/select-location&#x60; (POST) - Snapchat: &#x60;/v1/connect/snapchat/select-profile&#x60; (POST to save selected public profile)  Example: &#x60;https://yourdomain.com/integrations/callback&#x60;  (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of GetConnectUrl200Response</returns>
        public async System.Threading.Tasks.Task<GetConnectUrl200Response> GetConnectUrlAsync(string platform, string profileId, string? redirectUrl = default, System.Threading.CancellationToken cancellationToken = default)
        {
            Late.Client.ApiResponse<GetConnectUrl200Response> localVarResponse = await GetConnectUrlWithHttpInfoAsync(platform, profileId, redirectUrl, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Start OAuth connection for a platform Initiate an OAuth connection flow for any supported social media platform.  **Standard Flow (Hosted UI):** For Facebook connections, Late hosts the page selection UI:  1. Call this endpoint with your API key and &#x60;redirect_url&#x60; (optional) 2. Redirect your user to the returned &#x60;authUrl&#x60; 3. After OAuth, the user is redirected to Late’s hosted page selector at      &#x60;/connect/facebook/select-page?profileId&#x3D;X&amp;tempToken&#x3D;Y&amp;userProfile&#x3D;Z&amp;redirect_url&#x3D;YOUR_URL&amp;connect_token&#x3D;CT&#x60; 4. After they pick a page, Late saves the connection and finally redirects to your &#x60;redirect_url&#x60; (if provided)  **Headless/Whitelabel Mode (Facebook, LinkedIn, Pinterest &amp; Google Business Profile):** Build your own fully branded selection UI while Late handles OAuth:  **Facebook:** 1. Call this endpoint with your API key and add &#x60;&amp;headless&#x3D;true&#x60;, e.g.      &#x60;GET /v1/connect/facebook?profileId&#x3D;PROFILE_ID&amp;redirect_url&#x3D;https://yourapp.com/callback&amp;headless&#x3D;true&#x60; 2. Redirect your user to the returned &#x60;authUrl&#x60; 3. After OAuth, the user is redirected directly to **your** &#x60;redirect_url&#x60; with:    - &#x60;profileId&#x60; – your Late profile ID      - &#x60;tempToken&#x60; – temporary Facebook access token      - &#x60;userProfile&#x60; – URL‑encoded JSON user profile      - &#x60;connect_token&#x60; – short‑lived connect token (for API auth)      - &#x60;platform&#x3D;facebook&#x60;      - &#x60;step&#x3D;select_page&#x60; 4. Use &#x60;tempToken&#x60;, &#x60;userProfile&#x60;, and the &#x60;X-Connect-Token&#x60; header with:    - &#x60;GET /v1/connect/facebook/select-page&#x60; to fetch pages    - &#x60;POST /v1/connect/facebook/select-page&#x60; to save the selected page 5. In this mode, users never see Late&#39;s hosted page selector – only your UI.  **LinkedIn:** 1. Call this endpoint with &#x60;&amp;headless&#x3D;true&#x60;, e.g.    &#x60;GET /v1/connect/linkedin?profileId&#x3D;PROFILE_ID&amp;redirect_url&#x3D;https://yourapp.com/callback&amp;headless&#x3D;true&#x60; 2. Redirect your user to the returned &#x60;authUrl&#x60; 3. After OAuth, the user is redirected directly to **your** &#x60;redirect_url&#x60; with:    - &#x60;profileId&#x60; – your Late profile ID    - &#x60;pendingDataToken&#x60; – token to fetch OAuth data via API (see step 4)    - &#x60;connect_token&#x60; – short-lived connect token (for API auth)    - &#x60;platform&#x3D;linkedin&#x60;    - &#x60;step&#x3D;select_organization&#x60; 4. Call &#x60;GET /v1/connect/pending-data?token&#x3D;PENDING_DATA_TOKEN&#x60; to fetch the OAuth data:    - &#x60;tempToken&#x60; – temporary LinkedIn access token    - &#x60;userProfile&#x60; – JSON object with &#x60;id&#x60;, &#x60;username&#x60;, &#x60;displayName&#x60;, &#x60;profilePicture&#x60;    - &#x60;organizations&#x60; – JSON array with &#x60;id&#x60;, &#x60;urn&#x60;, &#x60;name&#x60;, &#x60;vanityName&#x60; for each org    - &#x60;refreshToken&#x60; / &#x60;expiresIn&#x60; – token metadata    This endpoint is one-time use and data expires after 10 minutes. 5. **Optional:** To fetch full organization details (logos, website, industry, description), call &#x60;GET /v1/connect/linkedin/organizations?tempToken&#x3D;X&amp;orgIds&#x3D;id1,id2,...&#x60; 6. Call &#x60;POST /v1/connect/linkedin/select-organization&#x60; with the &#x60;X-Connect-Token&#x60; header to save the selection. 7. In this mode, users never see Late&#39;s hosted organization selector – only your UI. 8. Note: If the user has no organization admin access, &#x60;step&#x3D;select_organization&#x60; will NOT be present,    and the account will be connected directly as a personal account.  **Pinterest:** 1. Call this endpoint with &#x60;&amp;headless&#x3D;true&#x60;, e.g.    &#x60;GET /v1/connect/pinterest?profileId&#x3D;PROFILE_ID&amp;redirect_url&#x3D;https://yourapp.com/callback&amp;headless&#x3D;true&#x60; 2. Redirect your user to the returned &#x60;authUrl&#x60; 3. After OAuth, the user is redirected directly to **your** &#x60;redirect_url&#x60; with:    - &#x60;profileId&#x60; – your Late profile ID    - &#x60;tempToken&#x60; – temporary Pinterest access token    - &#x60;userProfile&#x60; – URL‑encoded JSON user profile    - &#x60;connect_token&#x60; – short‑lived connect token (for API auth)    - &#x60;platform&#x3D;pinterest&#x60;    - &#x60;step&#x3D;select_board&#x60; 4. Use &#x60;tempToken&#x60;, &#x60;userProfile&#x60;, and the &#x60;X-Connect-Token&#x60; header with:    - &#x60;GET /v1/connect/pinterest/select-board&#x60; to fetch boards    - &#x60;POST /v1/connect/pinterest/select-board&#x60; to save the selected board 5. In this mode, users never see Late&#39;s hosted board selector – only your UI.  **Google Business Profile:** 1. Call this endpoint with &#x60;&amp;headless&#x3D;true&#x60;, e.g.    &#x60;GET /v1/connect/googlebusiness?profileId&#x3D;PROFILE_ID&amp;redirect_url&#x3D;https://yourapp.com/callback&amp;headless&#x3D;true&#x60; 2. Redirect your user to the returned &#x60;authUrl&#x60; 3. After OAuth, the user is redirected directly to **your** &#x60;redirect_url&#x60; with:    - &#x60;profileId&#x60; – your Late profile ID    - &#x60;tempToken&#x60; – temporary Google access token    - &#x60;userProfile&#x60; – URL‑encoded JSON user profile (includes refresh token info)    - &#x60;connect_token&#x60; – short‑lived connect token (for API auth)    - &#x60;platform&#x3D;googlebusiness&#x60;    - &#x60;step&#x3D;select_location&#x60; 4. Use &#x60;tempToken&#x60;, &#x60;userProfile&#x60;, and the &#x60;X-Connect-Token&#x60; header with:    - &#x60;GET /v1/connect/googlebusiness/locations&#x60; to fetch business locations    - &#x60;POST /v1/connect/googlebusiness/select-location&#x60; to save the selected location 5. In this mode, users never see Late&#39;s hosted location selector – only your UI. 
        /// </summary>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="platform">Social media platform to connect</param>
        /// <param name="profileId">Your Late profile ID (get from /v1/profiles)</param>
        /// <param name="redirectUrl">Optional: Your custom redirect URL after connection completes.  **Standard Mode:** Omit &#x60;headless&#x3D;true&#x60; to use our hosted page selection UI.   After the user selects a Facebook Page, Late redirects here with:   &#x60;?connected&#x3D;facebook&amp;profileId&#x3D;X&amp;username&#x3D;Y&#x60;  **Headless Mode (Facebook, LinkedIn, Pinterest, Google Business Profile &amp; Snapchat):** Pass &#x60;headless&#x3D;true&#x60; as a query parameter on this endpoint (not inside &#x60;redirect_url&#x60;), e.g.: &#x60;GET /v1/connect/facebook?profileId&#x3D;PROFILE_ID&amp;redirect_url&#x3D;https://yourapp.com/callback&amp;headless&#x3D;true&#x60; &#x60;GET /v1/connect/linkedin?profileId&#x3D;PROFILE_ID&amp;redirect_url&#x3D;https://yourapp.com/callback&amp;headless&#x3D;true&#x60; &#x60;GET /v1/connect/pinterest?profileId&#x3D;PROFILE_ID&amp;redirect_url&#x3D;https://yourapp.com/callback&amp;headless&#x3D;true&#x60; &#x60;GET /v1/connect/googlebusiness?profileId&#x3D;PROFILE_ID&amp;redirect_url&#x3D;https://yourapp.com/callback&amp;headless&#x3D;true&#x60; &#x60;GET /v1/connect/snapchat?profileId&#x3D;PROFILE_ID&amp;redirect_url&#x3D;https://yourapp.com/callback&amp;headless&#x3D;true&#x60;  After OAuth, the user is redirected directly to your &#x60;redirect_url&#x60; with OAuth data: - **Facebook:** &#x60;?profileId&#x3D;X&amp;tempToken&#x3D;Y&amp;userProfile&#x3D;Z&amp;connect_token&#x3D;CT&amp;platform&#x3D;facebook&amp;step&#x3D;select_page&#x60; - **LinkedIn:** &#x60;?profileId&#x3D;X&amp;pendingDataToken&#x3D;TOKEN&amp;connect_token&#x3D;CT&amp;platform&#x3D;linkedin&amp;step&#x3D;select_organization&#x60;   Use &#x60;GET /v1/connect/pending-data?token&#x3D;TOKEN&#x60; to fetch tempToken, userProfile, organizations, refreshToken. - **Pinterest:** &#x60;?profileId&#x3D;X&amp;tempToken&#x3D;Y&amp;userProfile&#x3D;Z&amp;connect_token&#x3D;CT&amp;platform&#x3D;pinterest&amp;step&#x3D;select_board&#x60; - **Google Business:** &#x60;?profileId&#x3D;X&amp;tempToken&#x3D;Y&amp;userProfile&#x3D;Z&amp;connect_token&#x3D;CT&amp;platform&#x3D;googlebusiness&amp;step&#x3D;select_location&#x60; - **Snapchat:** &#x60;?profileId&#x3D;X&amp;tempToken&#x3D;Y&amp;userProfile&#x3D;Z&amp;publicProfiles&#x3D;PROFILES&amp;connect_token&#x3D;CT&amp;platform&#x3D;snapchat&amp;step&#x3D;select_public_profile&#x60;   (publicProfiles contains &#x60;id&#x60;, &#x60;display_name&#x60;, &#x60;username&#x60;, &#x60;profile_image_url&#x60;, &#x60;subscriber_count&#x60;)  Then use the respective endpoints to build your custom UI: - Facebook: &#x60;/v1/connect/facebook/select-page&#x60; (GET to fetch, POST to save) - LinkedIn: &#x60;/v1/connect/linkedin/organizations&#x60; (GET to fetch logos), &#x60;/v1/connect/linkedin/select-organization&#x60; (POST to save) - Pinterest: &#x60;/v1/connect/pinterest/select-board&#x60; (GET to fetch, POST to save) - Google Business: &#x60;/v1/connect/googlebusiness/locations&#x60; (GET) and &#x60;/v1/connect/googlebusiness/select-location&#x60; (POST) - Snapchat: &#x60;/v1/connect/snapchat/select-profile&#x60; (POST to save selected public profile)  Example: &#x60;https://yourdomain.com/integrations/callback&#x60;  (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (GetConnectUrl200Response)</returns>
        public async System.Threading.Tasks.Task<Late.Client.ApiResponse<GetConnectUrl200Response>> GetConnectUrlWithHttpInfoAsync(string platform, string profileId, string? redirectUrl = default, System.Threading.CancellationToken cancellationToken = default)
        {
            // verify the required parameter 'platform' is set
            if (platform == null)
                throw new Late.Client.ApiException(400, "Missing required parameter 'platform' when calling ConnectApi->GetConnectUrl");

            // verify the required parameter 'profileId' is set
            if (profileId == null)
                throw new Late.Client.ApiException(400, "Missing required parameter 'profileId' when calling ConnectApi->GetConnectUrl");


            Late.Client.RequestOptions localVarRequestOptions = new Late.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };


            var localVarContentType = Late.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Late.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("platform", Late.Client.ClientUtils.ParameterToString(platform)); // path parameter
            localVarRequestOptions.QueryParameters.Add(Late.Client.ClientUtils.ParameterToMultiMap("", "profileId", profileId));
            if (redirectUrl != null)
            {
                localVarRequestOptions.QueryParameters.Add(Late.Client.ClientUtils.ParameterToMultiMap("", "redirect_url", redirectUrl));
            }

            // authentication (bearerAuth) required
            // bearer authentication required
            if (!string.IsNullOrEmpty(this.Configuration.AccessToken) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
            }

            // make the HTTP request

            var localVarResponse = await this.AsynchronousClient.GetAsync<GetConnectUrl200Response>("/v1/connect/{platform}", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetConnectUrl", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// List available Facebook pages for a connected account Returns all Facebook pages the connected account has access to, including the currently selected page.
        /// </summary>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="accountId"></param>
        /// <returns>GetFacebookPages200Response</returns>
        public GetFacebookPages200Response GetFacebookPages(string accountId)
        {
            Late.Client.ApiResponse<GetFacebookPages200Response> localVarResponse = GetFacebookPagesWithHttpInfo(accountId);
            return localVarResponse.Data;
        }

        /// <summary>
        /// List available Facebook pages for a connected account Returns all Facebook pages the connected account has access to, including the currently selected page.
        /// </summary>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="accountId"></param>
        /// <returns>ApiResponse of GetFacebookPages200Response</returns>
        public Late.Client.ApiResponse<GetFacebookPages200Response> GetFacebookPagesWithHttpInfo(string accountId)
        {
            // verify the required parameter 'accountId' is set
            if (accountId == null)
                throw new Late.Client.ApiException(400, "Missing required parameter 'accountId' when calling ConnectApi->GetFacebookPages");

            Late.Client.RequestOptions localVarRequestOptions = new Late.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Late.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Late.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("accountId", Late.Client.ClientUtils.ParameterToString(accountId)); // path parameter

            // authentication (bearerAuth) required
            // bearer authentication required
            if (!string.IsNullOrEmpty(this.Configuration.AccessToken) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
            }

            // make the HTTP request
            var localVarResponse = this.Client.Get<GetFacebookPages200Response>("/v1/accounts/{accountId}/facebook-page", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetFacebookPages", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// List available Facebook pages for a connected account Returns all Facebook pages the connected account has access to, including the currently selected page.
        /// </summary>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="accountId"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of GetFacebookPages200Response</returns>
        public async System.Threading.Tasks.Task<GetFacebookPages200Response> GetFacebookPagesAsync(string accountId, System.Threading.CancellationToken cancellationToken = default)
        {
            Late.Client.ApiResponse<GetFacebookPages200Response> localVarResponse = await GetFacebookPagesWithHttpInfoAsync(accountId, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// List available Facebook pages for a connected account Returns all Facebook pages the connected account has access to, including the currently selected page.
        /// </summary>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="accountId"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (GetFacebookPages200Response)</returns>
        public async System.Threading.Tasks.Task<Late.Client.ApiResponse<GetFacebookPages200Response>> GetFacebookPagesWithHttpInfoAsync(string accountId, System.Threading.CancellationToken cancellationToken = default)
        {
            // verify the required parameter 'accountId' is set
            if (accountId == null)
                throw new Late.Client.ApiException(400, "Missing required parameter 'accountId' when calling ConnectApi->GetFacebookPages");


            Late.Client.RequestOptions localVarRequestOptions = new Late.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };


            var localVarContentType = Late.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Late.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("accountId", Late.Client.ClientUtils.ParameterToString(accountId)); // path parameter

            // authentication (bearerAuth) required
            // bearer authentication required
            if (!string.IsNullOrEmpty(this.Configuration.AccessToken) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
            }

            // make the HTTP request

            var localVarResponse = await this.AsynchronousClient.GetAsync<GetFacebookPages200Response>("/v1/accounts/{accountId}/facebook-page", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetFacebookPages", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// List available Google Business Profile locations for a connected account Returns all Google Business Profile locations the connected account has access to, including the currently selected location.
        /// </summary>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="accountId"></param>
        /// <returns>GetGmbLocations200Response</returns>
        public GetGmbLocations200Response GetGmbLocations(string accountId)
        {
            Late.Client.ApiResponse<GetGmbLocations200Response> localVarResponse = GetGmbLocationsWithHttpInfo(accountId);
            return localVarResponse.Data;
        }

        /// <summary>
        /// List available Google Business Profile locations for a connected account Returns all Google Business Profile locations the connected account has access to, including the currently selected location.
        /// </summary>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="accountId"></param>
        /// <returns>ApiResponse of GetGmbLocations200Response</returns>
        public Late.Client.ApiResponse<GetGmbLocations200Response> GetGmbLocationsWithHttpInfo(string accountId)
        {
            // verify the required parameter 'accountId' is set
            if (accountId == null)
                throw new Late.Client.ApiException(400, "Missing required parameter 'accountId' when calling ConnectApi->GetGmbLocations");

            Late.Client.RequestOptions localVarRequestOptions = new Late.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Late.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Late.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("accountId", Late.Client.ClientUtils.ParameterToString(accountId)); // path parameter

            // authentication (bearerAuth) required
            // bearer authentication required
            if (!string.IsNullOrEmpty(this.Configuration.AccessToken) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
            }

            // make the HTTP request
            var localVarResponse = this.Client.Get<GetGmbLocations200Response>("/v1/accounts/{accountId}/gmb-locations", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetGmbLocations", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// List available Google Business Profile locations for a connected account Returns all Google Business Profile locations the connected account has access to, including the currently selected location.
        /// </summary>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="accountId"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of GetGmbLocations200Response</returns>
        public async System.Threading.Tasks.Task<GetGmbLocations200Response> GetGmbLocationsAsync(string accountId, System.Threading.CancellationToken cancellationToken = default)
        {
            Late.Client.ApiResponse<GetGmbLocations200Response> localVarResponse = await GetGmbLocationsWithHttpInfoAsync(accountId, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// List available Google Business Profile locations for a connected account Returns all Google Business Profile locations the connected account has access to, including the currently selected location.
        /// </summary>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="accountId"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (GetGmbLocations200Response)</returns>
        public async System.Threading.Tasks.Task<Late.Client.ApiResponse<GetGmbLocations200Response>> GetGmbLocationsWithHttpInfoAsync(string accountId, System.Threading.CancellationToken cancellationToken = default)
        {
            // verify the required parameter 'accountId' is set
            if (accountId == null)
                throw new Late.Client.ApiException(400, "Missing required parameter 'accountId' when calling ConnectApi->GetGmbLocations");


            Late.Client.RequestOptions localVarRequestOptions = new Late.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };


            var localVarContentType = Late.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Late.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("accountId", Late.Client.ClientUtils.ParameterToString(accountId)); // path parameter

            // authentication (bearerAuth) required
            // bearer authentication required
            if (!string.IsNullOrEmpty(this.Configuration.AccessToken) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
            }

            // make the HTTP request

            var localVarResponse = await this.AsynchronousClient.GetAsync<GetGmbLocations200Response>("/v1/accounts/{accountId}/gmb-locations", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetGmbLocations", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Get available LinkedIn organizations for a connected account 
        /// </summary>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="accountId"></param>
        /// <returns>GetLinkedInOrganizations200Response</returns>
        public GetLinkedInOrganizations200Response GetLinkedInOrganizations(string accountId)
        {
            Late.Client.ApiResponse<GetLinkedInOrganizations200Response> localVarResponse = GetLinkedInOrganizationsWithHttpInfo(accountId);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Get available LinkedIn organizations for a connected account 
        /// </summary>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="accountId"></param>
        /// <returns>ApiResponse of GetLinkedInOrganizations200Response</returns>
        public Late.Client.ApiResponse<GetLinkedInOrganizations200Response> GetLinkedInOrganizationsWithHttpInfo(string accountId)
        {
            // verify the required parameter 'accountId' is set
            if (accountId == null)
                throw new Late.Client.ApiException(400, "Missing required parameter 'accountId' when calling ConnectApi->GetLinkedInOrganizations");

            Late.Client.RequestOptions localVarRequestOptions = new Late.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Late.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Late.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("accountId", Late.Client.ClientUtils.ParameterToString(accountId)); // path parameter

            // authentication (bearerAuth) required
            // bearer authentication required
            if (!string.IsNullOrEmpty(this.Configuration.AccessToken) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
            }

            // make the HTTP request
            var localVarResponse = this.Client.Get<GetLinkedInOrganizations200Response>("/v1/accounts/{accountId}/linkedin-organizations", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetLinkedInOrganizations", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Get available LinkedIn organizations for a connected account 
        /// </summary>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="accountId"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of GetLinkedInOrganizations200Response</returns>
        public async System.Threading.Tasks.Task<GetLinkedInOrganizations200Response> GetLinkedInOrganizationsAsync(string accountId, System.Threading.CancellationToken cancellationToken = default)
        {
            Late.Client.ApiResponse<GetLinkedInOrganizations200Response> localVarResponse = await GetLinkedInOrganizationsWithHttpInfoAsync(accountId, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Get available LinkedIn organizations for a connected account 
        /// </summary>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="accountId"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (GetLinkedInOrganizations200Response)</returns>
        public async System.Threading.Tasks.Task<Late.Client.ApiResponse<GetLinkedInOrganizations200Response>> GetLinkedInOrganizationsWithHttpInfoAsync(string accountId, System.Threading.CancellationToken cancellationToken = default)
        {
            // verify the required parameter 'accountId' is set
            if (accountId == null)
                throw new Late.Client.ApiException(400, "Missing required parameter 'accountId' when calling ConnectApi->GetLinkedInOrganizations");


            Late.Client.RequestOptions localVarRequestOptions = new Late.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };


            var localVarContentType = Late.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Late.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("accountId", Late.Client.ClientUtils.ParameterToString(accountId)); // path parameter

            // authentication (bearerAuth) required
            // bearer authentication required
            if (!string.IsNullOrEmpty(this.Configuration.AccessToken) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
            }

            // make the HTTP request

            var localVarResponse = await this.AsynchronousClient.GetAsync<GetLinkedInOrganizations200Response>("/v1/accounts/{accountId}/linkedin-organizations", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetLinkedInOrganizations", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Fetch pending OAuth selection data (Headless Mode) **Fetch Pending OAuth Data for Headless Mode**  In headless mode, platforms like LinkedIn store OAuth selection data (organizations, pages, etc.) in the database instead of passing it via URL parameters. This prevents URI_TOO_LONG errors when users have many organizations/pages to select from.  After OAuth redirect, use the &#x60;pendingDataToken&#x60; from the URL to fetch the stored data.  **Important:** - This endpoint is one-time use: data is deleted after being fetched - Data expires automatically after 10 minutes if not fetched - No authentication required, just the token from the redirect URL 
        /// </summary>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="token">The pending data token from the OAuth redirect URL (&#x60;pendingDataToken&#x60; parameter)</param>
        /// <returns>GetPendingOAuthData200Response</returns>
        public GetPendingOAuthData200Response GetPendingOAuthData(string token)
        {
            Late.Client.ApiResponse<GetPendingOAuthData200Response> localVarResponse = GetPendingOAuthDataWithHttpInfo(token);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Fetch pending OAuth selection data (Headless Mode) **Fetch Pending OAuth Data for Headless Mode**  In headless mode, platforms like LinkedIn store OAuth selection data (organizations, pages, etc.) in the database instead of passing it via URL parameters. This prevents URI_TOO_LONG errors when users have many organizations/pages to select from.  After OAuth redirect, use the &#x60;pendingDataToken&#x60; from the URL to fetch the stored data.  **Important:** - This endpoint is one-time use: data is deleted after being fetched - Data expires automatically after 10 minutes if not fetched - No authentication required, just the token from the redirect URL 
        /// </summary>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="token">The pending data token from the OAuth redirect URL (&#x60;pendingDataToken&#x60; parameter)</param>
        /// <returns>ApiResponse of GetPendingOAuthData200Response</returns>
        public Late.Client.ApiResponse<GetPendingOAuthData200Response> GetPendingOAuthDataWithHttpInfo(string token)
        {
            // verify the required parameter 'token' is set
            if (token == null)
                throw new Late.Client.ApiException(400, "Missing required parameter 'token' when calling ConnectApi->GetPendingOAuthData");

            Late.Client.RequestOptions localVarRequestOptions = new Late.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Late.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Late.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.QueryParameters.Add(Late.Client.ClientUtils.ParameterToMultiMap("", "token", token));

            // authentication (bearerAuth) required
            // bearer authentication required
            if (!string.IsNullOrEmpty(this.Configuration.AccessToken) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
            }

            // make the HTTP request
            var localVarResponse = this.Client.Get<GetPendingOAuthData200Response>("/v1/connect/pending-data", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetPendingOAuthData", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Fetch pending OAuth selection data (Headless Mode) **Fetch Pending OAuth Data for Headless Mode**  In headless mode, platforms like LinkedIn store OAuth selection data (organizations, pages, etc.) in the database instead of passing it via URL parameters. This prevents URI_TOO_LONG errors when users have many organizations/pages to select from.  After OAuth redirect, use the &#x60;pendingDataToken&#x60; from the URL to fetch the stored data.  **Important:** - This endpoint is one-time use: data is deleted after being fetched - Data expires automatically after 10 minutes if not fetched - No authentication required, just the token from the redirect URL 
        /// </summary>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="token">The pending data token from the OAuth redirect URL (&#x60;pendingDataToken&#x60; parameter)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of GetPendingOAuthData200Response</returns>
        public async System.Threading.Tasks.Task<GetPendingOAuthData200Response> GetPendingOAuthDataAsync(string token, System.Threading.CancellationToken cancellationToken = default)
        {
            Late.Client.ApiResponse<GetPendingOAuthData200Response> localVarResponse = await GetPendingOAuthDataWithHttpInfoAsync(token, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Fetch pending OAuth selection data (Headless Mode) **Fetch Pending OAuth Data for Headless Mode**  In headless mode, platforms like LinkedIn store OAuth selection data (organizations, pages, etc.) in the database instead of passing it via URL parameters. This prevents URI_TOO_LONG errors when users have many organizations/pages to select from.  After OAuth redirect, use the &#x60;pendingDataToken&#x60; from the URL to fetch the stored data.  **Important:** - This endpoint is one-time use: data is deleted after being fetched - Data expires automatically after 10 minutes if not fetched - No authentication required, just the token from the redirect URL 
        /// </summary>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="token">The pending data token from the OAuth redirect URL (&#x60;pendingDataToken&#x60; parameter)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (GetPendingOAuthData200Response)</returns>
        public async System.Threading.Tasks.Task<Late.Client.ApiResponse<GetPendingOAuthData200Response>> GetPendingOAuthDataWithHttpInfoAsync(string token, System.Threading.CancellationToken cancellationToken = default)
        {
            // verify the required parameter 'token' is set
            if (token == null)
                throw new Late.Client.ApiException(400, "Missing required parameter 'token' when calling ConnectApi->GetPendingOAuthData");


            Late.Client.RequestOptions localVarRequestOptions = new Late.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };


            var localVarContentType = Late.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Late.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.QueryParameters.Add(Late.Client.ClientUtils.ParameterToMultiMap("", "token", token));

            // authentication (bearerAuth) required
            // bearer authentication required
            if (!string.IsNullOrEmpty(this.Configuration.AccessToken) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
            }

            // make the HTTP request

            var localVarResponse = await this.AsynchronousClient.GetAsync<GetPendingOAuthData200Response>("/v1/connect/pending-data", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetPendingOAuthData", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// List Pinterest boards for a connected account 
        /// </summary>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="accountId"></param>
        /// <returns>GetPinterestBoards200Response</returns>
        public GetPinterestBoards200Response GetPinterestBoards(string accountId)
        {
            Late.Client.ApiResponse<GetPinterestBoards200Response> localVarResponse = GetPinterestBoardsWithHttpInfo(accountId);
            return localVarResponse.Data;
        }

        /// <summary>
        /// List Pinterest boards for a connected account 
        /// </summary>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="accountId"></param>
        /// <returns>ApiResponse of GetPinterestBoards200Response</returns>
        public Late.Client.ApiResponse<GetPinterestBoards200Response> GetPinterestBoardsWithHttpInfo(string accountId)
        {
            // verify the required parameter 'accountId' is set
            if (accountId == null)
                throw new Late.Client.ApiException(400, "Missing required parameter 'accountId' when calling ConnectApi->GetPinterestBoards");

            Late.Client.RequestOptions localVarRequestOptions = new Late.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Late.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Late.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("accountId", Late.Client.ClientUtils.ParameterToString(accountId)); // path parameter

            // authentication (bearerAuth) required
            // bearer authentication required
            if (!string.IsNullOrEmpty(this.Configuration.AccessToken) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
            }

            // make the HTTP request
            var localVarResponse = this.Client.Get<GetPinterestBoards200Response>("/v1/accounts/{accountId}/pinterest-boards", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetPinterestBoards", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// List Pinterest boards for a connected account 
        /// </summary>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="accountId"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of GetPinterestBoards200Response</returns>
        public async System.Threading.Tasks.Task<GetPinterestBoards200Response> GetPinterestBoardsAsync(string accountId, System.Threading.CancellationToken cancellationToken = default)
        {
            Late.Client.ApiResponse<GetPinterestBoards200Response> localVarResponse = await GetPinterestBoardsWithHttpInfoAsync(accountId, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// List Pinterest boards for a connected account 
        /// </summary>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="accountId"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (GetPinterestBoards200Response)</returns>
        public async System.Threading.Tasks.Task<Late.Client.ApiResponse<GetPinterestBoards200Response>> GetPinterestBoardsWithHttpInfoAsync(string accountId, System.Threading.CancellationToken cancellationToken = default)
        {
            // verify the required parameter 'accountId' is set
            if (accountId == null)
                throw new Late.Client.ApiException(400, "Missing required parameter 'accountId' when calling ConnectApi->GetPinterestBoards");


            Late.Client.RequestOptions localVarRequestOptions = new Late.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };


            var localVarContentType = Late.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Late.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("accountId", Late.Client.ClientUtils.ParameterToString(accountId)); // path parameter

            // authentication (bearerAuth) required
            // bearer authentication required
            if (!string.IsNullOrEmpty(this.Configuration.AccessToken) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
            }

            // make the HTTP request

            var localVarResponse = await this.AsynchronousClient.GetAsync<GetPinterestBoards200Response>("/v1/accounts/{accountId}/pinterest-boards", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetPinterestBoards", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// List Reddit subreddits for a connected account 
        /// </summary>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="accountId"></param>
        /// <returns>GetRedditSubreddits200Response</returns>
        public GetRedditSubreddits200Response GetRedditSubreddits(string accountId)
        {
            Late.Client.ApiResponse<GetRedditSubreddits200Response> localVarResponse = GetRedditSubredditsWithHttpInfo(accountId);
            return localVarResponse.Data;
        }

        /// <summary>
        /// List Reddit subreddits for a connected account 
        /// </summary>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="accountId"></param>
        /// <returns>ApiResponse of GetRedditSubreddits200Response</returns>
        public Late.Client.ApiResponse<GetRedditSubreddits200Response> GetRedditSubredditsWithHttpInfo(string accountId)
        {
            // verify the required parameter 'accountId' is set
            if (accountId == null)
                throw new Late.Client.ApiException(400, "Missing required parameter 'accountId' when calling ConnectApi->GetRedditSubreddits");

            Late.Client.RequestOptions localVarRequestOptions = new Late.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Late.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Late.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("accountId", Late.Client.ClientUtils.ParameterToString(accountId)); // path parameter

            // authentication (bearerAuth) required
            // bearer authentication required
            if (!string.IsNullOrEmpty(this.Configuration.AccessToken) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
            }

            // make the HTTP request
            var localVarResponse = this.Client.Get<GetRedditSubreddits200Response>("/v1/accounts/{accountId}/reddit-subreddits", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetRedditSubreddits", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// List Reddit subreddits for a connected account 
        /// </summary>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="accountId"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of GetRedditSubreddits200Response</returns>
        public async System.Threading.Tasks.Task<GetRedditSubreddits200Response> GetRedditSubredditsAsync(string accountId, System.Threading.CancellationToken cancellationToken = default)
        {
            Late.Client.ApiResponse<GetRedditSubreddits200Response> localVarResponse = await GetRedditSubredditsWithHttpInfoAsync(accountId, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// List Reddit subreddits for a connected account 
        /// </summary>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="accountId"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (GetRedditSubreddits200Response)</returns>
        public async System.Threading.Tasks.Task<Late.Client.ApiResponse<GetRedditSubreddits200Response>> GetRedditSubredditsWithHttpInfoAsync(string accountId, System.Threading.CancellationToken cancellationToken = default)
        {
            // verify the required parameter 'accountId' is set
            if (accountId == null)
                throw new Late.Client.ApiException(400, "Missing required parameter 'accountId' when calling ConnectApi->GetRedditSubreddits");


            Late.Client.RequestOptions localVarRequestOptions = new Late.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };


            var localVarContentType = Late.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Late.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("accountId", Late.Client.ClientUtils.ParameterToString(accountId)); // path parameter

            // authentication (bearerAuth) required
            // bearer authentication required
            if (!string.IsNullOrEmpty(this.Configuration.AccessToken) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
            }

            // make the HTTP request

            var localVarResponse = await this.AsynchronousClient.GetAsync<GetRedditSubreddits200Response>("/v1/accounts/{accountId}/reddit-subreddits", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetRedditSubreddits", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Generate Telegram access code Generate a unique access code for connecting a Telegram channel or group.  **Connection Flow:** 1. Call this endpoint to get an access code (valid for 15 minutes) 2. Add the bot (@LateScheduleBot or your configured bot) as an administrator in your Telegram channel/group 3. Open a private chat with the bot 4. Send: &#x60;{CODE} @yourchannel&#x60; (e.g., &#x60;LATE-ABC123 @mychannel&#x60;) 5. Poll &#x60;PATCH /v1/connect/telegram?code&#x3D;{CODE}&#x60; to check connection status  **Alternative for private channels:** If your channel has no public username, forward any message from the channel to the bot along with the access code. 
        /// </summary>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="profileId">The profile ID to connect the Telegram account to</param>
        /// <returns>GetTelegramConnectStatus200Response</returns>
        public GetTelegramConnectStatus200Response GetTelegramConnectStatus(string profileId)
        {
            Late.Client.ApiResponse<GetTelegramConnectStatus200Response> localVarResponse = GetTelegramConnectStatusWithHttpInfo(profileId);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Generate Telegram access code Generate a unique access code for connecting a Telegram channel or group.  **Connection Flow:** 1. Call this endpoint to get an access code (valid for 15 minutes) 2. Add the bot (@LateScheduleBot or your configured bot) as an administrator in your Telegram channel/group 3. Open a private chat with the bot 4. Send: &#x60;{CODE} @yourchannel&#x60; (e.g., &#x60;LATE-ABC123 @mychannel&#x60;) 5. Poll &#x60;PATCH /v1/connect/telegram?code&#x3D;{CODE}&#x60; to check connection status  **Alternative for private channels:** If your channel has no public username, forward any message from the channel to the bot along with the access code. 
        /// </summary>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="profileId">The profile ID to connect the Telegram account to</param>
        /// <returns>ApiResponse of GetTelegramConnectStatus200Response</returns>
        public Late.Client.ApiResponse<GetTelegramConnectStatus200Response> GetTelegramConnectStatusWithHttpInfo(string profileId)
        {
            // verify the required parameter 'profileId' is set
            if (profileId == null)
                throw new Late.Client.ApiException(400, "Missing required parameter 'profileId' when calling ConnectApi->GetTelegramConnectStatus");

            Late.Client.RequestOptions localVarRequestOptions = new Late.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Late.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Late.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.QueryParameters.Add(Late.Client.ClientUtils.ParameterToMultiMap("", "profileId", profileId));

            // authentication (bearerAuth) required
            // bearer authentication required
            if (!string.IsNullOrEmpty(this.Configuration.AccessToken) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
            }

            // make the HTTP request
            var localVarResponse = this.Client.Get<GetTelegramConnectStatus200Response>("/v1/connect/telegram", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetTelegramConnectStatus", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Generate Telegram access code Generate a unique access code for connecting a Telegram channel or group.  **Connection Flow:** 1. Call this endpoint to get an access code (valid for 15 minutes) 2. Add the bot (@LateScheduleBot or your configured bot) as an administrator in your Telegram channel/group 3. Open a private chat with the bot 4. Send: &#x60;{CODE} @yourchannel&#x60; (e.g., &#x60;LATE-ABC123 @mychannel&#x60;) 5. Poll &#x60;PATCH /v1/connect/telegram?code&#x3D;{CODE}&#x60; to check connection status  **Alternative for private channels:** If your channel has no public username, forward any message from the channel to the bot along with the access code. 
        /// </summary>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="profileId">The profile ID to connect the Telegram account to</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of GetTelegramConnectStatus200Response</returns>
        public async System.Threading.Tasks.Task<GetTelegramConnectStatus200Response> GetTelegramConnectStatusAsync(string profileId, System.Threading.CancellationToken cancellationToken = default)
        {
            Late.Client.ApiResponse<GetTelegramConnectStatus200Response> localVarResponse = await GetTelegramConnectStatusWithHttpInfoAsync(profileId, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Generate Telegram access code Generate a unique access code for connecting a Telegram channel or group.  **Connection Flow:** 1. Call this endpoint to get an access code (valid for 15 minutes) 2. Add the bot (@LateScheduleBot or your configured bot) as an administrator in your Telegram channel/group 3. Open a private chat with the bot 4. Send: &#x60;{CODE} @yourchannel&#x60; (e.g., &#x60;LATE-ABC123 @mychannel&#x60;) 5. Poll &#x60;PATCH /v1/connect/telegram?code&#x3D;{CODE}&#x60; to check connection status  **Alternative for private channels:** If your channel has no public username, forward any message from the channel to the bot along with the access code. 
        /// </summary>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="profileId">The profile ID to connect the Telegram account to</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (GetTelegramConnectStatus200Response)</returns>
        public async System.Threading.Tasks.Task<Late.Client.ApiResponse<GetTelegramConnectStatus200Response>> GetTelegramConnectStatusWithHttpInfoAsync(string profileId, System.Threading.CancellationToken cancellationToken = default)
        {
            // verify the required parameter 'profileId' is set
            if (profileId == null)
                throw new Late.Client.ApiException(400, "Missing required parameter 'profileId' when calling ConnectApi->GetTelegramConnectStatus");


            Late.Client.RequestOptions localVarRequestOptions = new Late.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };


            var localVarContentType = Late.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Late.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.QueryParameters.Add(Late.Client.ClientUtils.ParameterToMultiMap("", "profileId", profileId));

            // authentication (bearerAuth) required
            // bearer authentication required
            if (!string.IsNullOrEmpty(this.Configuration.AccessToken) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
            }

            // make the HTTP request

            var localVarResponse = await this.AsynchronousClient.GetAsync<GetTelegramConnectStatus200Response>("/v1/connect/telegram", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetTelegramConnectStatus", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Complete OAuth token exchange manually (for server-side flows) 
        /// </summary>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="platform"></param>
        /// <param name="handleOAuthCallbackRequest"></param>
        /// <returns></returns>
        public void HandleOAuthCallback(string platform, HandleOAuthCallbackRequest handleOAuthCallbackRequest)
        {
            HandleOAuthCallbackWithHttpInfo(platform, handleOAuthCallbackRequest);
        }

        /// <summary>
        /// Complete OAuth token exchange manually (for server-side flows) 
        /// </summary>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="platform"></param>
        /// <param name="handleOAuthCallbackRequest"></param>
        /// <returns>ApiResponse of Object(void)</returns>
        public Late.Client.ApiResponse<Object> HandleOAuthCallbackWithHttpInfo(string platform, HandleOAuthCallbackRequest handleOAuthCallbackRequest)
        {
            // verify the required parameter 'platform' is set
            if (platform == null)
                throw new Late.Client.ApiException(400, "Missing required parameter 'platform' when calling ConnectApi->HandleOAuthCallback");

            // verify the required parameter 'handleOAuthCallbackRequest' is set
            if (handleOAuthCallbackRequest == null)
                throw new Late.Client.ApiException(400, "Missing required parameter 'handleOAuthCallbackRequest' when calling ConnectApi->HandleOAuthCallback");

            Late.Client.RequestOptions localVarRequestOptions = new Late.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Late.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Late.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("platform", Late.Client.ClientUtils.ParameterToString(platform)); // path parameter
            localVarRequestOptions.Data = handleOAuthCallbackRequest;

            // authentication (bearerAuth) required
            // bearer authentication required
            if (!string.IsNullOrEmpty(this.Configuration.AccessToken) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
            }

            // make the HTTP request
            var localVarResponse = this.Client.Post<Object>("/v1/connect/{platform}", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("HandleOAuthCallback", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Complete OAuth token exchange manually (for server-side flows) 
        /// </summary>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="platform"></param>
        /// <param name="handleOAuthCallbackRequest"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of void</returns>
        public async System.Threading.Tasks.Task HandleOAuthCallbackAsync(string platform, HandleOAuthCallbackRequest handleOAuthCallbackRequest, System.Threading.CancellationToken cancellationToken = default)
        {
            await HandleOAuthCallbackWithHttpInfoAsync(platform, handleOAuthCallbackRequest, cancellationToken).ConfigureAwait(false);
        }

        /// <summary>
        /// Complete OAuth token exchange manually (for server-side flows) 
        /// </summary>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="platform"></param>
        /// <param name="handleOAuthCallbackRequest"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async System.Threading.Tasks.Task<Late.Client.ApiResponse<Object>> HandleOAuthCallbackWithHttpInfoAsync(string platform, HandleOAuthCallbackRequest handleOAuthCallbackRequest, System.Threading.CancellationToken cancellationToken = default)
        {
            // verify the required parameter 'platform' is set
            if (platform == null)
                throw new Late.Client.ApiException(400, "Missing required parameter 'platform' when calling ConnectApi->HandleOAuthCallback");

            // verify the required parameter 'handleOAuthCallbackRequest' is set
            if (handleOAuthCallbackRequest == null)
                throw new Late.Client.ApiException(400, "Missing required parameter 'handleOAuthCallbackRequest' when calling ConnectApi->HandleOAuthCallback");


            Late.Client.RequestOptions localVarRequestOptions = new Late.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };


            var localVarContentType = Late.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Late.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("platform", Late.Client.ClientUtils.ParameterToString(platform)); // path parameter
            localVarRequestOptions.Data = handleOAuthCallbackRequest;

            // authentication (bearerAuth) required
            // bearer authentication required
            if (!string.IsNullOrEmpty(this.Configuration.AccessToken) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
            }

            // make the HTTP request

            var localVarResponse = await this.AsynchronousClient.PostAsync<Object>("/v1/connect/{platform}", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("HandleOAuthCallback", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Direct Telegram connection (power users) Connect a Telegram channel/group directly using the chat ID.  This is an alternative to the access code flow for power users who know their Telegram chat ID. The bot must already be added as an administrator in the channel/group. 
        /// </summary>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="initiateTelegramConnectRequest"></param>
        /// <returns>InitiateTelegramConnect200Response</returns>
        public InitiateTelegramConnect200Response InitiateTelegramConnect(InitiateTelegramConnectRequest initiateTelegramConnectRequest)
        {
            Late.Client.ApiResponse<InitiateTelegramConnect200Response> localVarResponse = InitiateTelegramConnectWithHttpInfo(initiateTelegramConnectRequest);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Direct Telegram connection (power users) Connect a Telegram channel/group directly using the chat ID.  This is an alternative to the access code flow for power users who know their Telegram chat ID. The bot must already be added as an administrator in the channel/group. 
        /// </summary>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="initiateTelegramConnectRequest"></param>
        /// <returns>ApiResponse of InitiateTelegramConnect200Response</returns>
        public Late.Client.ApiResponse<InitiateTelegramConnect200Response> InitiateTelegramConnectWithHttpInfo(InitiateTelegramConnectRequest initiateTelegramConnectRequest)
        {
            // verify the required parameter 'initiateTelegramConnectRequest' is set
            if (initiateTelegramConnectRequest == null)
                throw new Late.Client.ApiException(400, "Missing required parameter 'initiateTelegramConnectRequest' when calling ConnectApi->InitiateTelegramConnect");

            Late.Client.RequestOptions localVarRequestOptions = new Late.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Late.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Late.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.Data = initiateTelegramConnectRequest;

            // authentication (bearerAuth) required
            // bearer authentication required
            if (!string.IsNullOrEmpty(this.Configuration.AccessToken) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
            }

            // make the HTTP request
            var localVarResponse = this.Client.Post<InitiateTelegramConnect200Response>("/v1/connect/telegram", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("InitiateTelegramConnect", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Direct Telegram connection (power users) Connect a Telegram channel/group directly using the chat ID.  This is an alternative to the access code flow for power users who know their Telegram chat ID. The bot must already be added as an administrator in the channel/group. 
        /// </summary>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="initiateTelegramConnectRequest"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of InitiateTelegramConnect200Response</returns>
        public async System.Threading.Tasks.Task<InitiateTelegramConnect200Response> InitiateTelegramConnectAsync(InitiateTelegramConnectRequest initiateTelegramConnectRequest, System.Threading.CancellationToken cancellationToken = default)
        {
            Late.Client.ApiResponse<InitiateTelegramConnect200Response> localVarResponse = await InitiateTelegramConnectWithHttpInfoAsync(initiateTelegramConnectRequest, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Direct Telegram connection (power users) Connect a Telegram channel/group directly using the chat ID.  This is an alternative to the access code flow for power users who know their Telegram chat ID. The bot must already be added as an administrator in the channel/group. 
        /// </summary>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="initiateTelegramConnectRequest"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (InitiateTelegramConnect200Response)</returns>
        public async System.Threading.Tasks.Task<Late.Client.ApiResponse<InitiateTelegramConnect200Response>> InitiateTelegramConnectWithHttpInfoAsync(InitiateTelegramConnectRequest initiateTelegramConnectRequest, System.Threading.CancellationToken cancellationToken = default)
        {
            // verify the required parameter 'initiateTelegramConnectRequest' is set
            if (initiateTelegramConnectRequest == null)
                throw new Late.Client.ApiException(400, "Missing required parameter 'initiateTelegramConnectRequest' when calling ConnectApi->InitiateTelegramConnect");


            Late.Client.RequestOptions localVarRequestOptions = new Late.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };


            var localVarContentType = Late.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Late.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.Data = initiateTelegramConnectRequest;

            // authentication (bearerAuth) required
            // bearer authentication required
            if (!string.IsNullOrEmpty(this.Configuration.AccessToken) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
            }

            // make the HTTP request

            var localVarResponse = await this.AsynchronousClient.PostAsync<InitiateTelegramConnect200Response>("/v1/connect/telegram", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("InitiateTelegramConnect", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// List Facebook Pages after OAuth (Headless Mode) **Headless Mode for Custom UI**  After initiating Facebook OAuth via &#x60;/v1/connect/facebook&#x60;, you&#39;ll be redirected to  &#x60;/connect/facebook/select-page&#x60; with query params including &#x60;tempToken&#x60; and &#x60;userProfile&#x60;.  For a **headless/whitelabeled flow**, extract these params from the URL and call this  endpoint to retrieve the list of Facebook Pages the user can manage. Then build your  own UI to let users select a page.  **Note:** Use the &#x60;X-Connect-Token&#x60; header if you initiated the connection via API key  (rather than a browser session). 
        /// </summary>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="profileId">Profile ID from your connection flow</param>
        /// <param name="tempToken">Temporary Facebook access token from the OAuth callback redirect</param>
        /// <returns>ListFacebookPages200Response</returns>
        public ListFacebookPages200Response ListFacebookPages(string profileId, string tempToken)
        {
            Late.Client.ApiResponse<ListFacebookPages200Response> localVarResponse = ListFacebookPagesWithHttpInfo(profileId, tempToken);
            return localVarResponse.Data;
        }

        /// <summary>
        /// List Facebook Pages after OAuth (Headless Mode) **Headless Mode for Custom UI**  After initiating Facebook OAuth via &#x60;/v1/connect/facebook&#x60;, you&#39;ll be redirected to  &#x60;/connect/facebook/select-page&#x60; with query params including &#x60;tempToken&#x60; and &#x60;userProfile&#x60;.  For a **headless/whitelabeled flow**, extract these params from the URL and call this  endpoint to retrieve the list of Facebook Pages the user can manage. Then build your  own UI to let users select a page.  **Note:** Use the &#x60;X-Connect-Token&#x60; header if you initiated the connection via API key  (rather than a browser session). 
        /// </summary>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="profileId">Profile ID from your connection flow</param>
        /// <param name="tempToken">Temporary Facebook access token from the OAuth callback redirect</param>
        /// <returns>ApiResponse of ListFacebookPages200Response</returns>
        public Late.Client.ApiResponse<ListFacebookPages200Response> ListFacebookPagesWithHttpInfo(string profileId, string tempToken)
        {
            // verify the required parameter 'profileId' is set
            if (profileId == null)
                throw new Late.Client.ApiException(400, "Missing required parameter 'profileId' when calling ConnectApi->ListFacebookPages");

            // verify the required parameter 'tempToken' is set
            if (tempToken == null)
                throw new Late.Client.ApiException(400, "Missing required parameter 'tempToken' when calling ConnectApi->ListFacebookPages");

            Late.Client.RequestOptions localVarRequestOptions = new Late.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Late.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Late.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.QueryParameters.Add(Late.Client.ClientUtils.ParameterToMultiMap("", "profileId", profileId));
            localVarRequestOptions.QueryParameters.Add(Late.Client.ClientUtils.ParameterToMultiMap("", "tempToken", tempToken));

            // authentication (connectToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("X-Connect-Token")))
            {
                localVarRequestOptions.HeaderParameters.Add("X-Connect-Token", this.Configuration.GetApiKeyWithPrefix("X-Connect-Token"));
            }
            // authentication (bearerAuth) required
            // bearer authentication required
            if (!string.IsNullOrEmpty(this.Configuration.AccessToken) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
            }

            // make the HTTP request
            var localVarResponse = this.Client.Get<ListFacebookPages200Response>("/v1/connect/facebook/select-page", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ListFacebookPages", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// List Facebook Pages after OAuth (Headless Mode) **Headless Mode for Custom UI**  After initiating Facebook OAuth via &#x60;/v1/connect/facebook&#x60;, you&#39;ll be redirected to  &#x60;/connect/facebook/select-page&#x60; with query params including &#x60;tempToken&#x60; and &#x60;userProfile&#x60;.  For a **headless/whitelabeled flow**, extract these params from the URL and call this  endpoint to retrieve the list of Facebook Pages the user can manage. Then build your  own UI to let users select a page.  **Note:** Use the &#x60;X-Connect-Token&#x60; header if you initiated the connection via API key  (rather than a browser session). 
        /// </summary>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="profileId">Profile ID from your connection flow</param>
        /// <param name="tempToken">Temporary Facebook access token from the OAuth callback redirect</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ListFacebookPages200Response</returns>
        public async System.Threading.Tasks.Task<ListFacebookPages200Response> ListFacebookPagesAsync(string profileId, string tempToken, System.Threading.CancellationToken cancellationToken = default)
        {
            Late.Client.ApiResponse<ListFacebookPages200Response> localVarResponse = await ListFacebookPagesWithHttpInfoAsync(profileId, tempToken, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// List Facebook Pages after OAuth (Headless Mode) **Headless Mode for Custom UI**  After initiating Facebook OAuth via &#x60;/v1/connect/facebook&#x60;, you&#39;ll be redirected to  &#x60;/connect/facebook/select-page&#x60; with query params including &#x60;tempToken&#x60; and &#x60;userProfile&#x60;.  For a **headless/whitelabeled flow**, extract these params from the URL and call this  endpoint to retrieve the list of Facebook Pages the user can manage. Then build your  own UI to let users select a page.  **Note:** Use the &#x60;X-Connect-Token&#x60; header if you initiated the connection via API key  (rather than a browser session). 
        /// </summary>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="profileId">Profile ID from your connection flow</param>
        /// <param name="tempToken">Temporary Facebook access token from the OAuth callback redirect</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (ListFacebookPages200Response)</returns>
        public async System.Threading.Tasks.Task<Late.Client.ApiResponse<ListFacebookPages200Response>> ListFacebookPagesWithHttpInfoAsync(string profileId, string tempToken, System.Threading.CancellationToken cancellationToken = default)
        {
            // verify the required parameter 'profileId' is set
            if (profileId == null)
                throw new Late.Client.ApiException(400, "Missing required parameter 'profileId' when calling ConnectApi->ListFacebookPages");

            // verify the required parameter 'tempToken' is set
            if (tempToken == null)
                throw new Late.Client.ApiException(400, "Missing required parameter 'tempToken' when calling ConnectApi->ListFacebookPages");


            Late.Client.RequestOptions localVarRequestOptions = new Late.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };


            var localVarContentType = Late.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Late.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.QueryParameters.Add(Late.Client.ClientUtils.ParameterToMultiMap("", "profileId", profileId));
            localVarRequestOptions.QueryParameters.Add(Late.Client.ClientUtils.ParameterToMultiMap("", "tempToken", tempToken));

            // authentication (connectToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("X-Connect-Token")))
            {
                localVarRequestOptions.HeaderParameters.Add("X-Connect-Token", this.Configuration.GetApiKeyWithPrefix("X-Connect-Token"));
            }
            // authentication (bearerAuth) required
            // bearer authentication required
            if (!string.IsNullOrEmpty(this.Configuration.AccessToken) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
            }

            // make the HTTP request

            var localVarResponse = await this.AsynchronousClient.GetAsync<ListFacebookPages200Response>("/v1/connect/facebook/select-page", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ListFacebookPages", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// List Google Business Locations after OAuth (Headless Mode) **Headless Mode for Custom UI**  After initiating Google Business OAuth via &#x60;/v1/connect/googlebusiness?headless&#x3D;true&#x60;, you&#39;ll be redirected  to your &#x60;redirect_url&#x60; with query params including &#x60;tempToken&#x60; and &#x60;userProfile&#x60;.  For a **headless/whitelabeled flow**, extract these params from the URL and call this  endpoint to retrieve the list of Google Business locations the user can manage. Then build your  own UI to let users select a location.  **Note:** Use the &#x60;X-Connect-Token&#x60; header if you initiated the connection via API key  (rather than a browser session). 
        /// </summary>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="profileId">Profile ID from your connection flow</param>
        /// <param name="tempToken">Temporary Google access token from the OAuth callback redirect</param>
        /// <returns>ListGoogleBusinessLocations200Response</returns>
        public ListGoogleBusinessLocations200Response ListGoogleBusinessLocations(string profileId, string tempToken)
        {
            Late.Client.ApiResponse<ListGoogleBusinessLocations200Response> localVarResponse = ListGoogleBusinessLocationsWithHttpInfo(profileId, tempToken);
            return localVarResponse.Data;
        }

        /// <summary>
        /// List Google Business Locations after OAuth (Headless Mode) **Headless Mode for Custom UI**  After initiating Google Business OAuth via &#x60;/v1/connect/googlebusiness?headless&#x3D;true&#x60;, you&#39;ll be redirected  to your &#x60;redirect_url&#x60; with query params including &#x60;tempToken&#x60; and &#x60;userProfile&#x60;.  For a **headless/whitelabeled flow**, extract these params from the URL and call this  endpoint to retrieve the list of Google Business locations the user can manage. Then build your  own UI to let users select a location.  **Note:** Use the &#x60;X-Connect-Token&#x60; header if you initiated the connection via API key  (rather than a browser session). 
        /// </summary>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="profileId">Profile ID from your connection flow</param>
        /// <param name="tempToken">Temporary Google access token from the OAuth callback redirect</param>
        /// <returns>ApiResponse of ListGoogleBusinessLocations200Response</returns>
        public Late.Client.ApiResponse<ListGoogleBusinessLocations200Response> ListGoogleBusinessLocationsWithHttpInfo(string profileId, string tempToken)
        {
            // verify the required parameter 'profileId' is set
            if (profileId == null)
                throw new Late.Client.ApiException(400, "Missing required parameter 'profileId' when calling ConnectApi->ListGoogleBusinessLocations");

            // verify the required parameter 'tempToken' is set
            if (tempToken == null)
                throw new Late.Client.ApiException(400, "Missing required parameter 'tempToken' when calling ConnectApi->ListGoogleBusinessLocations");

            Late.Client.RequestOptions localVarRequestOptions = new Late.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Late.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Late.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.QueryParameters.Add(Late.Client.ClientUtils.ParameterToMultiMap("", "profileId", profileId));
            localVarRequestOptions.QueryParameters.Add(Late.Client.ClientUtils.ParameterToMultiMap("", "tempToken", tempToken));

            // authentication (connectToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("X-Connect-Token")))
            {
                localVarRequestOptions.HeaderParameters.Add("X-Connect-Token", this.Configuration.GetApiKeyWithPrefix("X-Connect-Token"));
            }
            // authentication (bearerAuth) required
            // bearer authentication required
            if (!string.IsNullOrEmpty(this.Configuration.AccessToken) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
            }

            // make the HTTP request
            var localVarResponse = this.Client.Get<ListGoogleBusinessLocations200Response>("/v1/connect/googlebusiness/locations", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ListGoogleBusinessLocations", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// List Google Business Locations after OAuth (Headless Mode) **Headless Mode for Custom UI**  After initiating Google Business OAuth via &#x60;/v1/connect/googlebusiness?headless&#x3D;true&#x60;, you&#39;ll be redirected  to your &#x60;redirect_url&#x60; with query params including &#x60;tempToken&#x60; and &#x60;userProfile&#x60;.  For a **headless/whitelabeled flow**, extract these params from the URL and call this  endpoint to retrieve the list of Google Business locations the user can manage. Then build your  own UI to let users select a location.  **Note:** Use the &#x60;X-Connect-Token&#x60; header if you initiated the connection via API key  (rather than a browser session). 
        /// </summary>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="profileId">Profile ID from your connection flow</param>
        /// <param name="tempToken">Temporary Google access token from the OAuth callback redirect</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ListGoogleBusinessLocations200Response</returns>
        public async System.Threading.Tasks.Task<ListGoogleBusinessLocations200Response> ListGoogleBusinessLocationsAsync(string profileId, string tempToken, System.Threading.CancellationToken cancellationToken = default)
        {
            Late.Client.ApiResponse<ListGoogleBusinessLocations200Response> localVarResponse = await ListGoogleBusinessLocationsWithHttpInfoAsync(profileId, tempToken, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// List Google Business Locations after OAuth (Headless Mode) **Headless Mode for Custom UI**  After initiating Google Business OAuth via &#x60;/v1/connect/googlebusiness?headless&#x3D;true&#x60;, you&#39;ll be redirected  to your &#x60;redirect_url&#x60; with query params including &#x60;tempToken&#x60; and &#x60;userProfile&#x60;.  For a **headless/whitelabeled flow**, extract these params from the URL and call this  endpoint to retrieve the list of Google Business locations the user can manage. Then build your  own UI to let users select a location.  **Note:** Use the &#x60;X-Connect-Token&#x60; header if you initiated the connection via API key  (rather than a browser session). 
        /// </summary>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="profileId">Profile ID from your connection flow</param>
        /// <param name="tempToken">Temporary Google access token from the OAuth callback redirect</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (ListGoogleBusinessLocations200Response)</returns>
        public async System.Threading.Tasks.Task<Late.Client.ApiResponse<ListGoogleBusinessLocations200Response>> ListGoogleBusinessLocationsWithHttpInfoAsync(string profileId, string tempToken, System.Threading.CancellationToken cancellationToken = default)
        {
            // verify the required parameter 'profileId' is set
            if (profileId == null)
                throw new Late.Client.ApiException(400, "Missing required parameter 'profileId' when calling ConnectApi->ListGoogleBusinessLocations");

            // verify the required parameter 'tempToken' is set
            if (tempToken == null)
                throw new Late.Client.ApiException(400, "Missing required parameter 'tempToken' when calling ConnectApi->ListGoogleBusinessLocations");


            Late.Client.RequestOptions localVarRequestOptions = new Late.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };


            var localVarContentType = Late.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Late.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.QueryParameters.Add(Late.Client.ClientUtils.ParameterToMultiMap("", "profileId", profileId));
            localVarRequestOptions.QueryParameters.Add(Late.Client.ClientUtils.ParameterToMultiMap("", "tempToken", tempToken));

            // authentication (connectToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("X-Connect-Token")))
            {
                localVarRequestOptions.HeaderParameters.Add("X-Connect-Token", this.Configuration.GetApiKeyWithPrefix("X-Connect-Token"));
            }
            // authentication (bearerAuth) required
            // bearer authentication required
            if (!string.IsNullOrEmpty(this.Configuration.AccessToken) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
            }

            // make the HTTP request

            var localVarResponse = await this.AsynchronousClient.GetAsync<ListGoogleBusinessLocations200Response>("/v1/connect/googlebusiness/locations", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ListGoogleBusinessLocations", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Fetch full LinkedIn organization details (Headless Mode) **Fetch Full Organization Details for Custom UI**  After LinkedIn OAuth in headless mode, the redirect URL contains organization data with only &#x60;id&#x60;, &#x60;urn&#x60;, and &#x60;name&#x60; fields (additional details are excluded to prevent URL length issues with many organizations).  Use this endpoint to fetch full organization details including logos, vanity names, websites, and more if you want to display them in your custom selection UI.  **Note:** This endpoint requires no authentication - just the &#x60;tempToken&#x60; from the OAuth redirect. Details are fetched directly from LinkedIn&#39;s API in parallel for fast response times. 
        /// </summary>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="tempToken">The temporary LinkedIn access token from the OAuth redirect</param>
        /// <param name="orgIds">Comma-separated list of organization IDs to fetch details for (max 100)</param>
        /// <returns>ListLinkedInOrganizations200Response</returns>
        public ListLinkedInOrganizations200Response ListLinkedInOrganizations(string tempToken, string orgIds)
        {
            Late.Client.ApiResponse<ListLinkedInOrganizations200Response> localVarResponse = ListLinkedInOrganizationsWithHttpInfo(tempToken, orgIds);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Fetch full LinkedIn organization details (Headless Mode) **Fetch Full Organization Details for Custom UI**  After LinkedIn OAuth in headless mode, the redirect URL contains organization data with only &#x60;id&#x60;, &#x60;urn&#x60;, and &#x60;name&#x60; fields (additional details are excluded to prevent URL length issues with many organizations).  Use this endpoint to fetch full organization details including logos, vanity names, websites, and more if you want to display them in your custom selection UI.  **Note:** This endpoint requires no authentication - just the &#x60;tempToken&#x60; from the OAuth redirect. Details are fetched directly from LinkedIn&#39;s API in parallel for fast response times. 
        /// </summary>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="tempToken">The temporary LinkedIn access token from the OAuth redirect</param>
        /// <param name="orgIds">Comma-separated list of organization IDs to fetch details for (max 100)</param>
        /// <returns>ApiResponse of ListLinkedInOrganizations200Response</returns>
        public Late.Client.ApiResponse<ListLinkedInOrganizations200Response> ListLinkedInOrganizationsWithHttpInfo(string tempToken, string orgIds)
        {
            // verify the required parameter 'tempToken' is set
            if (tempToken == null)
                throw new Late.Client.ApiException(400, "Missing required parameter 'tempToken' when calling ConnectApi->ListLinkedInOrganizations");

            // verify the required parameter 'orgIds' is set
            if (orgIds == null)
                throw new Late.Client.ApiException(400, "Missing required parameter 'orgIds' when calling ConnectApi->ListLinkedInOrganizations");

            Late.Client.RequestOptions localVarRequestOptions = new Late.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Late.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Late.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.QueryParameters.Add(Late.Client.ClientUtils.ParameterToMultiMap("", "tempToken", tempToken));
            localVarRequestOptions.QueryParameters.Add(Late.Client.ClientUtils.ParameterToMultiMap("", "orgIds", orgIds));

            // authentication (bearerAuth) required
            // bearer authentication required
            if (!string.IsNullOrEmpty(this.Configuration.AccessToken) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
            }

            // make the HTTP request
            var localVarResponse = this.Client.Get<ListLinkedInOrganizations200Response>("/v1/connect/linkedin/organizations", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ListLinkedInOrganizations", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Fetch full LinkedIn organization details (Headless Mode) **Fetch Full Organization Details for Custom UI**  After LinkedIn OAuth in headless mode, the redirect URL contains organization data with only &#x60;id&#x60;, &#x60;urn&#x60;, and &#x60;name&#x60; fields (additional details are excluded to prevent URL length issues with many organizations).  Use this endpoint to fetch full organization details including logos, vanity names, websites, and more if you want to display them in your custom selection UI.  **Note:** This endpoint requires no authentication - just the &#x60;tempToken&#x60; from the OAuth redirect. Details are fetched directly from LinkedIn&#39;s API in parallel for fast response times. 
        /// </summary>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="tempToken">The temporary LinkedIn access token from the OAuth redirect</param>
        /// <param name="orgIds">Comma-separated list of organization IDs to fetch details for (max 100)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ListLinkedInOrganizations200Response</returns>
        public async System.Threading.Tasks.Task<ListLinkedInOrganizations200Response> ListLinkedInOrganizationsAsync(string tempToken, string orgIds, System.Threading.CancellationToken cancellationToken = default)
        {
            Late.Client.ApiResponse<ListLinkedInOrganizations200Response> localVarResponse = await ListLinkedInOrganizationsWithHttpInfoAsync(tempToken, orgIds, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Fetch full LinkedIn organization details (Headless Mode) **Fetch Full Organization Details for Custom UI**  After LinkedIn OAuth in headless mode, the redirect URL contains organization data with only &#x60;id&#x60;, &#x60;urn&#x60;, and &#x60;name&#x60; fields (additional details are excluded to prevent URL length issues with many organizations).  Use this endpoint to fetch full organization details including logos, vanity names, websites, and more if you want to display them in your custom selection UI.  **Note:** This endpoint requires no authentication - just the &#x60;tempToken&#x60; from the OAuth redirect. Details are fetched directly from LinkedIn&#39;s API in parallel for fast response times. 
        /// </summary>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="tempToken">The temporary LinkedIn access token from the OAuth redirect</param>
        /// <param name="orgIds">Comma-separated list of organization IDs to fetch details for (max 100)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (ListLinkedInOrganizations200Response)</returns>
        public async System.Threading.Tasks.Task<Late.Client.ApiResponse<ListLinkedInOrganizations200Response>> ListLinkedInOrganizationsWithHttpInfoAsync(string tempToken, string orgIds, System.Threading.CancellationToken cancellationToken = default)
        {
            // verify the required parameter 'tempToken' is set
            if (tempToken == null)
                throw new Late.Client.ApiException(400, "Missing required parameter 'tempToken' when calling ConnectApi->ListLinkedInOrganizations");

            // verify the required parameter 'orgIds' is set
            if (orgIds == null)
                throw new Late.Client.ApiException(400, "Missing required parameter 'orgIds' when calling ConnectApi->ListLinkedInOrganizations");


            Late.Client.RequestOptions localVarRequestOptions = new Late.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };


            var localVarContentType = Late.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Late.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.QueryParameters.Add(Late.Client.ClientUtils.ParameterToMultiMap("", "tempToken", tempToken));
            localVarRequestOptions.QueryParameters.Add(Late.Client.ClientUtils.ParameterToMultiMap("", "orgIds", orgIds));

            // authentication (bearerAuth) required
            // bearer authentication required
            if (!string.IsNullOrEmpty(this.Configuration.AccessToken) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
            }

            // make the HTTP request

            var localVarResponse = await this.AsynchronousClient.GetAsync<ListLinkedInOrganizations200Response>("/v1/connect/linkedin/organizations", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ListLinkedInOrganizations", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// List Pinterest Boards after OAuth (Headless Mode) **Retrieve Pinterest Boards for Selection UI**  After initiating Pinterest OAuth via &#x60;/v1/connect/pinterest&#x60; with &#x60;headless&#x3D;true&#x60;, you&#39;ll be redirected to your &#x60;redirect_url&#x60; with query params including &#x60;tempToken&#x60; and &#x60;userProfile&#x60;.  If you want to build your own fully-branded board selector (instead of Late&#39;s hosted UI), call this endpoint to retrieve the list of Pinterest Boards the user can post to. Then build your UI and call &#x60;POST /v1/connect/pinterest/select-board&#x60; to save the selection.  **Authentication:** Use &#x60;X-Connect-Token&#x60; header with the &#x60;connect_token&#x60; from the redirect URL. 
        /// </summary>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="xConnectToken">Short-lived connect token from the OAuth redirect</param>
        /// <param name="profileId">Your Late profile ID</param>
        /// <param name="tempToken">Temporary Pinterest access token from the OAuth callback redirect</param>
        /// <returns>ListPinterestBoardsForSelection200Response</returns>
        public ListPinterestBoardsForSelection200Response ListPinterestBoardsForSelection(string xConnectToken, string profileId, string tempToken)
        {
            Late.Client.ApiResponse<ListPinterestBoardsForSelection200Response> localVarResponse = ListPinterestBoardsForSelectionWithHttpInfo(xConnectToken, profileId, tempToken);
            return localVarResponse.Data;
        }

        /// <summary>
        /// List Pinterest Boards after OAuth (Headless Mode) **Retrieve Pinterest Boards for Selection UI**  After initiating Pinterest OAuth via &#x60;/v1/connect/pinterest&#x60; with &#x60;headless&#x3D;true&#x60;, you&#39;ll be redirected to your &#x60;redirect_url&#x60; with query params including &#x60;tempToken&#x60; and &#x60;userProfile&#x60;.  If you want to build your own fully-branded board selector (instead of Late&#39;s hosted UI), call this endpoint to retrieve the list of Pinterest Boards the user can post to. Then build your UI and call &#x60;POST /v1/connect/pinterest/select-board&#x60; to save the selection.  **Authentication:** Use &#x60;X-Connect-Token&#x60; header with the &#x60;connect_token&#x60; from the redirect URL. 
        /// </summary>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="xConnectToken">Short-lived connect token from the OAuth redirect</param>
        /// <param name="profileId">Your Late profile ID</param>
        /// <param name="tempToken">Temporary Pinterest access token from the OAuth callback redirect</param>
        /// <returns>ApiResponse of ListPinterestBoardsForSelection200Response</returns>
        public Late.Client.ApiResponse<ListPinterestBoardsForSelection200Response> ListPinterestBoardsForSelectionWithHttpInfo(string xConnectToken, string profileId, string tempToken)
        {
            // verify the required parameter 'xConnectToken' is set
            if (xConnectToken == null)
                throw new Late.Client.ApiException(400, "Missing required parameter 'xConnectToken' when calling ConnectApi->ListPinterestBoardsForSelection");

            // verify the required parameter 'profileId' is set
            if (profileId == null)
                throw new Late.Client.ApiException(400, "Missing required parameter 'profileId' when calling ConnectApi->ListPinterestBoardsForSelection");

            // verify the required parameter 'tempToken' is set
            if (tempToken == null)
                throw new Late.Client.ApiException(400, "Missing required parameter 'tempToken' when calling ConnectApi->ListPinterestBoardsForSelection");

            Late.Client.RequestOptions localVarRequestOptions = new Late.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Late.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Late.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.QueryParameters.Add(Late.Client.ClientUtils.ParameterToMultiMap("", "profileId", profileId));
            localVarRequestOptions.QueryParameters.Add(Late.Client.ClientUtils.ParameterToMultiMap("", "tempToken", tempToken));
            localVarRequestOptions.HeaderParameters.Add("X-Connect-Token", Late.Client.ClientUtils.ParameterToString(xConnectToken)); // header parameter

            // authentication (bearerAuth) required
            // bearer authentication required
            if (!string.IsNullOrEmpty(this.Configuration.AccessToken) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
            }

            // make the HTTP request
            var localVarResponse = this.Client.Get<ListPinterestBoardsForSelection200Response>("/v1/connect/pinterest/select-board", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ListPinterestBoardsForSelection", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// List Pinterest Boards after OAuth (Headless Mode) **Retrieve Pinterest Boards for Selection UI**  After initiating Pinterest OAuth via &#x60;/v1/connect/pinterest&#x60; with &#x60;headless&#x3D;true&#x60;, you&#39;ll be redirected to your &#x60;redirect_url&#x60; with query params including &#x60;tempToken&#x60; and &#x60;userProfile&#x60;.  If you want to build your own fully-branded board selector (instead of Late&#39;s hosted UI), call this endpoint to retrieve the list of Pinterest Boards the user can post to. Then build your UI and call &#x60;POST /v1/connect/pinterest/select-board&#x60; to save the selection.  **Authentication:** Use &#x60;X-Connect-Token&#x60; header with the &#x60;connect_token&#x60; from the redirect URL. 
        /// </summary>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="xConnectToken">Short-lived connect token from the OAuth redirect</param>
        /// <param name="profileId">Your Late profile ID</param>
        /// <param name="tempToken">Temporary Pinterest access token from the OAuth callback redirect</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ListPinterestBoardsForSelection200Response</returns>
        public async System.Threading.Tasks.Task<ListPinterestBoardsForSelection200Response> ListPinterestBoardsForSelectionAsync(string xConnectToken, string profileId, string tempToken, System.Threading.CancellationToken cancellationToken = default)
        {
            Late.Client.ApiResponse<ListPinterestBoardsForSelection200Response> localVarResponse = await ListPinterestBoardsForSelectionWithHttpInfoAsync(xConnectToken, profileId, tempToken, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// List Pinterest Boards after OAuth (Headless Mode) **Retrieve Pinterest Boards for Selection UI**  After initiating Pinterest OAuth via &#x60;/v1/connect/pinterest&#x60; with &#x60;headless&#x3D;true&#x60;, you&#39;ll be redirected to your &#x60;redirect_url&#x60; with query params including &#x60;tempToken&#x60; and &#x60;userProfile&#x60;.  If you want to build your own fully-branded board selector (instead of Late&#39;s hosted UI), call this endpoint to retrieve the list of Pinterest Boards the user can post to. Then build your UI and call &#x60;POST /v1/connect/pinterest/select-board&#x60; to save the selection.  **Authentication:** Use &#x60;X-Connect-Token&#x60; header with the &#x60;connect_token&#x60; from the redirect URL. 
        /// </summary>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="xConnectToken">Short-lived connect token from the OAuth redirect</param>
        /// <param name="profileId">Your Late profile ID</param>
        /// <param name="tempToken">Temporary Pinterest access token from the OAuth callback redirect</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (ListPinterestBoardsForSelection200Response)</returns>
        public async System.Threading.Tasks.Task<Late.Client.ApiResponse<ListPinterestBoardsForSelection200Response>> ListPinterestBoardsForSelectionWithHttpInfoAsync(string xConnectToken, string profileId, string tempToken, System.Threading.CancellationToken cancellationToken = default)
        {
            // verify the required parameter 'xConnectToken' is set
            if (xConnectToken == null)
                throw new Late.Client.ApiException(400, "Missing required parameter 'xConnectToken' when calling ConnectApi->ListPinterestBoardsForSelection");

            // verify the required parameter 'profileId' is set
            if (profileId == null)
                throw new Late.Client.ApiException(400, "Missing required parameter 'profileId' when calling ConnectApi->ListPinterestBoardsForSelection");

            // verify the required parameter 'tempToken' is set
            if (tempToken == null)
                throw new Late.Client.ApiException(400, "Missing required parameter 'tempToken' when calling ConnectApi->ListPinterestBoardsForSelection");


            Late.Client.RequestOptions localVarRequestOptions = new Late.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };


            var localVarContentType = Late.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Late.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.QueryParameters.Add(Late.Client.ClientUtils.ParameterToMultiMap("", "profileId", profileId));
            localVarRequestOptions.QueryParameters.Add(Late.Client.ClientUtils.ParameterToMultiMap("", "tempToken", tempToken));
            localVarRequestOptions.HeaderParameters.Add("X-Connect-Token", Late.Client.ClientUtils.ParameterToString(xConnectToken)); // header parameter

            // authentication (bearerAuth) required
            // bearer authentication required
            if (!string.IsNullOrEmpty(this.Configuration.AccessToken) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
            }

            // make the HTTP request

            var localVarResponse = await this.AsynchronousClient.GetAsync<ListPinterestBoardsForSelection200Response>("/v1/connect/pinterest/select-board", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ListPinterestBoardsForSelection", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// List Snapchat Public Profiles after OAuth (Headless Mode) **Headless Mode for Custom UI**  After initiating Snapchat OAuth via &#x60;/v1/connect/snapchat?headless&#x3D;true&#x60;, you&#39;ll be redirected to your &#x60;redirect_url&#x60; with query params including &#x60;tempToken&#x60;, &#x60;userProfile&#x60;, and &#x60;publicProfiles&#x60;.  If you want to build your own fully-branded profile selector (instead of Late&#39;s hosted UI), call this endpoint to retrieve the list of Snapchat Public Profiles the user can post to. Then build your UI and call &#x60;POST /v1/connect/snapchat/select-profile&#x60; to save the selection.  **Authentication:** Use &#x60;X-Connect-Token&#x60; header with the &#x60;connect_token&#x60; from the redirect URL. 
        /// </summary>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="xConnectToken">Short-lived connect token from the OAuth redirect</param>
        /// <param name="profileId">Your Late profile ID</param>
        /// <param name="tempToken">Temporary Snapchat access token from the OAuth callback redirect</param>
        /// <returns>ListSnapchatProfiles200Response</returns>
        public ListSnapchatProfiles200Response ListSnapchatProfiles(string xConnectToken, string profileId, string tempToken)
        {
            Late.Client.ApiResponse<ListSnapchatProfiles200Response> localVarResponse = ListSnapchatProfilesWithHttpInfo(xConnectToken, profileId, tempToken);
            return localVarResponse.Data;
        }

        /// <summary>
        /// List Snapchat Public Profiles after OAuth (Headless Mode) **Headless Mode for Custom UI**  After initiating Snapchat OAuth via &#x60;/v1/connect/snapchat?headless&#x3D;true&#x60;, you&#39;ll be redirected to your &#x60;redirect_url&#x60; with query params including &#x60;tempToken&#x60;, &#x60;userProfile&#x60;, and &#x60;publicProfiles&#x60;.  If you want to build your own fully-branded profile selector (instead of Late&#39;s hosted UI), call this endpoint to retrieve the list of Snapchat Public Profiles the user can post to. Then build your UI and call &#x60;POST /v1/connect/snapchat/select-profile&#x60; to save the selection.  **Authentication:** Use &#x60;X-Connect-Token&#x60; header with the &#x60;connect_token&#x60; from the redirect URL. 
        /// </summary>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="xConnectToken">Short-lived connect token from the OAuth redirect</param>
        /// <param name="profileId">Your Late profile ID</param>
        /// <param name="tempToken">Temporary Snapchat access token from the OAuth callback redirect</param>
        /// <returns>ApiResponse of ListSnapchatProfiles200Response</returns>
        public Late.Client.ApiResponse<ListSnapchatProfiles200Response> ListSnapchatProfilesWithHttpInfo(string xConnectToken, string profileId, string tempToken)
        {
            // verify the required parameter 'xConnectToken' is set
            if (xConnectToken == null)
                throw new Late.Client.ApiException(400, "Missing required parameter 'xConnectToken' when calling ConnectApi->ListSnapchatProfiles");

            // verify the required parameter 'profileId' is set
            if (profileId == null)
                throw new Late.Client.ApiException(400, "Missing required parameter 'profileId' when calling ConnectApi->ListSnapchatProfiles");

            // verify the required parameter 'tempToken' is set
            if (tempToken == null)
                throw new Late.Client.ApiException(400, "Missing required parameter 'tempToken' when calling ConnectApi->ListSnapchatProfiles");

            Late.Client.RequestOptions localVarRequestOptions = new Late.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Late.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Late.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.QueryParameters.Add(Late.Client.ClientUtils.ParameterToMultiMap("", "profileId", profileId));
            localVarRequestOptions.QueryParameters.Add(Late.Client.ClientUtils.ParameterToMultiMap("", "tempToken", tempToken));
            localVarRequestOptions.HeaderParameters.Add("X-Connect-Token", Late.Client.ClientUtils.ParameterToString(xConnectToken)); // header parameter

            // authentication (bearerAuth) required
            // bearer authentication required
            if (!string.IsNullOrEmpty(this.Configuration.AccessToken) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
            }

            // make the HTTP request
            var localVarResponse = this.Client.Get<ListSnapchatProfiles200Response>("/v1/connect/snapchat/select-profile", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ListSnapchatProfiles", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// List Snapchat Public Profiles after OAuth (Headless Mode) **Headless Mode for Custom UI**  After initiating Snapchat OAuth via &#x60;/v1/connect/snapchat?headless&#x3D;true&#x60;, you&#39;ll be redirected to your &#x60;redirect_url&#x60; with query params including &#x60;tempToken&#x60;, &#x60;userProfile&#x60;, and &#x60;publicProfiles&#x60;.  If you want to build your own fully-branded profile selector (instead of Late&#39;s hosted UI), call this endpoint to retrieve the list of Snapchat Public Profiles the user can post to. Then build your UI and call &#x60;POST /v1/connect/snapchat/select-profile&#x60; to save the selection.  **Authentication:** Use &#x60;X-Connect-Token&#x60; header with the &#x60;connect_token&#x60; from the redirect URL. 
        /// </summary>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="xConnectToken">Short-lived connect token from the OAuth redirect</param>
        /// <param name="profileId">Your Late profile ID</param>
        /// <param name="tempToken">Temporary Snapchat access token from the OAuth callback redirect</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ListSnapchatProfiles200Response</returns>
        public async System.Threading.Tasks.Task<ListSnapchatProfiles200Response> ListSnapchatProfilesAsync(string xConnectToken, string profileId, string tempToken, System.Threading.CancellationToken cancellationToken = default)
        {
            Late.Client.ApiResponse<ListSnapchatProfiles200Response> localVarResponse = await ListSnapchatProfilesWithHttpInfoAsync(xConnectToken, profileId, tempToken, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// List Snapchat Public Profiles after OAuth (Headless Mode) **Headless Mode for Custom UI**  After initiating Snapchat OAuth via &#x60;/v1/connect/snapchat?headless&#x3D;true&#x60;, you&#39;ll be redirected to your &#x60;redirect_url&#x60; with query params including &#x60;tempToken&#x60;, &#x60;userProfile&#x60;, and &#x60;publicProfiles&#x60;.  If you want to build your own fully-branded profile selector (instead of Late&#39;s hosted UI), call this endpoint to retrieve the list of Snapchat Public Profiles the user can post to. Then build your UI and call &#x60;POST /v1/connect/snapchat/select-profile&#x60; to save the selection.  **Authentication:** Use &#x60;X-Connect-Token&#x60; header with the &#x60;connect_token&#x60; from the redirect URL. 
        /// </summary>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="xConnectToken">Short-lived connect token from the OAuth redirect</param>
        /// <param name="profileId">Your Late profile ID</param>
        /// <param name="tempToken">Temporary Snapchat access token from the OAuth callback redirect</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (ListSnapchatProfiles200Response)</returns>
        public async System.Threading.Tasks.Task<Late.Client.ApiResponse<ListSnapchatProfiles200Response>> ListSnapchatProfilesWithHttpInfoAsync(string xConnectToken, string profileId, string tempToken, System.Threading.CancellationToken cancellationToken = default)
        {
            // verify the required parameter 'xConnectToken' is set
            if (xConnectToken == null)
                throw new Late.Client.ApiException(400, "Missing required parameter 'xConnectToken' when calling ConnectApi->ListSnapchatProfiles");

            // verify the required parameter 'profileId' is set
            if (profileId == null)
                throw new Late.Client.ApiException(400, "Missing required parameter 'profileId' when calling ConnectApi->ListSnapchatProfiles");

            // verify the required parameter 'tempToken' is set
            if (tempToken == null)
                throw new Late.Client.ApiException(400, "Missing required parameter 'tempToken' when calling ConnectApi->ListSnapchatProfiles");


            Late.Client.RequestOptions localVarRequestOptions = new Late.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };


            var localVarContentType = Late.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Late.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.QueryParameters.Add(Late.Client.ClientUtils.ParameterToMultiMap("", "profileId", profileId));
            localVarRequestOptions.QueryParameters.Add(Late.Client.ClientUtils.ParameterToMultiMap("", "tempToken", tempToken));
            localVarRequestOptions.HeaderParameters.Add("X-Connect-Token", Late.Client.ClientUtils.ParameterToString(xConnectToken)); // header parameter

            // authentication (bearerAuth) required
            // bearer authentication required
            if (!string.IsNullOrEmpty(this.Configuration.AccessToken) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
            }

            // make the HTTP request

            var localVarResponse = await this.AsynchronousClient.GetAsync<ListSnapchatProfiles200Response>("/v1/connect/snapchat/select-profile", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ListSnapchatProfiles", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Select a Facebook Page to complete the connection (Headless Mode) **Complete the Headless Flow**  After displaying your custom UI with the list of pages from the GET endpoint, call this  endpoint to finalize the connection with the user&#39;s selected page.  The &#x60;userProfile&#x60; should be the decoded JSON object from the &#x60;userProfile&#x60; query param  in the OAuth callback redirect URL.  **Note:** Use the &#x60;X-Connect-Token&#x60; header if you initiated the connection via API key. 
        /// </summary>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="selectFacebookPageRequest"></param>
        /// <returns>SelectFacebookPage200Response</returns>
        public SelectFacebookPage200Response SelectFacebookPage(SelectFacebookPageRequest selectFacebookPageRequest)
        {
            Late.Client.ApiResponse<SelectFacebookPage200Response> localVarResponse = SelectFacebookPageWithHttpInfo(selectFacebookPageRequest);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Select a Facebook Page to complete the connection (Headless Mode) **Complete the Headless Flow**  After displaying your custom UI with the list of pages from the GET endpoint, call this  endpoint to finalize the connection with the user&#39;s selected page.  The &#x60;userProfile&#x60; should be the decoded JSON object from the &#x60;userProfile&#x60; query param  in the OAuth callback redirect URL.  **Note:** Use the &#x60;X-Connect-Token&#x60; header if you initiated the connection via API key. 
        /// </summary>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="selectFacebookPageRequest"></param>
        /// <returns>ApiResponse of SelectFacebookPage200Response</returns>
        public Late.Client.ApiResponse<SelectFacebookPage200Response> SelectFacebookPageWithHttpInfo(SelectFacebookPageRequest selectFacebookPageRequest)
        {
            // verify the required parameter 'selectFacebookPageRequest' is set
            if (selectFacebookPageRequest == null)
                throw new Late.Client.ApiException(400, "Missing required parameter 'selectFacebookPageRequest' when calling ConnectApi->SelectFacebookPage");

            Late.Client.RequestOptions localVarRequestOptions = new Late.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Late.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Late.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.Data = selectFacebookPageRequest;

            // authentication (connectToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("X-Connect-Token")))
            {
                localVarRequestOptions.HeaderParameters.Add("X-Connect-Token", this.Configuration.GetApiKeyWithPrefix("X-Connect-Token"));
            }
            // authentication (bearerAuth) required
            // bearer authentication required
            if (!string.IsNullOrEmpty(this.Configuration.AccessToken) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
            }

            // make the HTTP request
            var localVarResponse = this.Client.Post<SelectFacebookPage200Response>("/v1/connect/facebook/select-page", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("SelectFacebookPage", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Select a Facebook Page to complete the connection (Headless Mode) **Complete the Headless Flow**  After displaying your custom UI with the list of pages from the GET endpoint, call this  endpoint to finalize the connection with the user&#39;s selected page.  The &#x60;userProfile&#x60; should be the decoded JSON object from the &#x60;userProfile&#x60; query param  in the OAuth callback redirect URL.  **Note:** Use the &#x60;X-Connect-Token&#x60; header if you initiated the connection via API key. 
        /// </summary>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="selectFacebookPageRequest"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of SelectFacebookPage200Response</returns>
        public async System.Threading.Tasks.Task<SelectFacebookPage200Response> SelectFacebookPageAsync(SelectFacebookPageRequest selectFacebookPageRequest, System.Threading.CancellationToken cancellationToken = default)
        {
            Late.Client.ApiResponse<SelectFacebookPage200Response> localVarResponse = await SelectFacebookPageWithHttpInfoAsync(selectFacebookPageRequest, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Select a Facebook Page to complete the connection (Headless Mode) **Complete the Headless Flow**  After displaying your custom UI with the list of pages from the GET endpoint, call this  endpoint to finalize the connection with the user&#39;s selected page.  The &#x60;userProfile&#x60; should be the decoded JSON object from the &#x60;userProfile&#x60; query param  in the OAuth callback redirect URL.  **Note:** Use the &#x60;X-Connect-Token&#x60; header if you initiated the connection via API key. 
        /// </summary>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="selectFacebookPageRequest"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (SelectFacebookPage200Response)</returns>
        public async System.Threading.Tasks.Task<Late.Client.ApiResponse<SelectFacebookPage200Response>> SelectFacebookPageWithHttpInfoAsync(SelectFacebookPageRequest selectFacebookPageRequest, System.Threading.CancellationToken cancellationToken = default)
        {
            // verify the required parameter 'selectFacebookPageRequest' is set
            if (selectFacebookPageRequest == null)
                throw new Late.Client.ApiException(400, "Missing required parameter 'selectFacebookPageRequest' when calling ConnectApi->SelectFacebookPage");


            Late.Client.RequestOptions localVarRequestOptions = new Late.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };


            var localVarContentType = Late.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Late.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.Data = selectFacebookPageRequest;

            // authentication (connectToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("X-Connect-Token")))
            {
                localVarRequestOptions.HeaderParameters.Add("X-Connect-Token", this.Configuration.GetApiKeyWithPrefix("X-Connect-Token"));
            }
            // authentication (bearerAuth) required
            // bearer authentication required
            if (!string.IsNullOrEmpty(this.Configuration.AccessToken) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
            }

            // make the HTTP request

            var localVarResponse = await this.AsynchronousClient.PostAsync<SelectFacebookPage200Response>("/v1/connect/facebook/select-page", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("SelectFacebookPage", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Select a Google Business location to complete the connection (Headless Mode) **Complete the Headless Flow**  After displaying your custom UI with the list of locations from the GET &#x60;/v1/connect/googlebusiness/locations&#x60;  endpoint, call this endpoint to finalize the connection with the user&#39;s selected location.  The &#x60;userProfile&#x60; should be the decoded JSON object from the &#x60;userProfile&#x60; query param  in the OAuth callback redirect URL. It contains important token information (including refresh token).  **Note:** Use the &#x60;X-Connect-Token&#x60; header if you initiated the connection via API key. 
        /// </summary>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="selectGoogleBusinessLocationRequest"></param>
        /// <returns>SelectGoogleBusinessLocation200Response</returns>
        public SelectGoogleBusinessLocation200Response SelectGoogleBusinessLocation(SelectGoogleBusinessLocationRequest selectGoogleBusinessLocationRequest)
        {
            Late.Client.ApiResponse<SelectGoogleBusinessLocation200Response> localVarResponse = SelectGoogleBusinessLocationWithHttpInfo(selectGoogleBusinessLocationRequest);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Select a Google Business location to complete the connection (Headless Mode) **Complete the Headless Flow**  After displaying your custom UI with the list of locations from the GET &#x60;/v1/connect/googlebusiness/locations&#x60;  endpoint, call this endpoint to finalize the connection with the user&#39;s selected location.  The &#x60;userProfile&#x60; should be the decoded JSON object from the &#x60;userProfile&#x60; query param  in the OAuth callback redirect URL. It contains important token information (including refresh token).  **Note:** Use the &#x60;X-Connect-Token&#x60; header if you initiated the connection via API key. 
        /// </summary>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="selectGoogleBusinessLocationRequest"></param>
        /// <returns>ApiResponse of SelectGoogleBusinessLocation200Response</returns>
        public Late.Client.ApiResponse<SelectGoogleBusinessLocation200Response> SelectGoogleBusinessLocationWithHttpInfo(SelectGoogleBusinessLocationRequest selectGoogleBusinessLocationRequest)
        {
            // verify the required parameter 'selectGoogleBusinessLocationRequest' is set
            if (selectGoogleBusinessLocationRequest == null)
                throw new Late.Client.ApiException(400, "Missing required parameter 'selectGoogleBusinessLocationRequest' when calling ConnectApi->SelectGoogleBusinessLocation");

            Late.Client.RequestOptions localVarRequestOptions = new Late.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Late.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Late.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.Data = selectGoogleBusinessLocationRequest;

            // authentication (connectToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("X-Connect-Token")))
            {
                localVarRequestOptions.HeaderParameters.Add("X-Connect-Token", this.Configuration.GetApiKeyWithPrefix("X-Connect-Token"));
            }
            // authentication (bearerAuth) required
            // bearer authentication required
            if (!string.IsNullOrEmpty(this.Configuration.AccessToken) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
            }

            // make the HTTP request
            var localVarResponse = this.Client.Post<SelectGoogleBusinessLocation200Response>("/v1/connect/googlebusiness/select-location", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("SelectGoogleBusinessLocation", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Select a Google Business location to complete the connection (Headless Mode) **Complete the Headless Flow**  After displaying your custom UI with the list of locations from the GET &#x60;/v1/connect/googlebusiness/locations&#x60;  endpoint, call this endpoint to finalize the connection with the user&#39;s selected location.  The &#x60;userProfile&#x60; should be the decoded JSON object from the &#x60;userProfile&#x60; query param  in the OAuth callback redirect URL. It contains important token information (including refresh token).  **Note:** Use the &#x60;X-Connect-Token&#x60; header if you initiated the connection via API key. 
        /// </summary>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="selectGoogleBusinessLocationRequest"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of SelectGoogleBusinessLocation200Response</returns>
        public async System.Threading.Tasks.Task<SelectGoogleBusinessLocation200Response> SelectGoogleBusinessLocationAsync(SelectGoogleBusinessLocationRequest selectGoogleBusinessLocationRequest, System.Threading.CancellationToken cancellationToken = default)
        {
            Late.Client.ApiResponse<SelectGoogleBusinessLocation200Response> localVarResponse = await SelectGoogleBusinessLocationWithHttpInfoAsync(selectGoogleBusinessLocationRequest, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Select a Google Business location to complete the connection (Headless Mode) **Complete the Headless Flow**  After displaying your custom UI with the list of locations from the GET &#x60;/v1/connect/googlebusiness/locations&#x60;  endpoint, call this endpoint to finalize the connection with the user&#39;s selected location.  The &#x60;userProfile&#x60; should be the decoded JSON object from the &#x60;userProfile&#x60; query param  in the OAuth callback redirect URL. It contains important token information (including refresh token).  **Note:** Use the &#x60;X-Connect-Token&#x60; header if you initiated the connection via API key. 
        /// </summary>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="selectGoogleBusinessLocationRequest"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (SelectGoogleBusinessLocation200Response)</returns>
        public async System.Threading.Tasks.Task<Late.Client.ApiResponse<SelectGoogleBusinessLocation200Response>> SelectGoogleBusinessLocationWithHttpInfoAsync(SelectGoogleBusinessLocationRequest selectGoogleBusinessLocationRequest, System.Threading.CancellationToken cancellationToken = default)
        {
            // verify the required parameter 'selectGoogleBusinessLocationRequest' is set
            if (selectGoogleBusinessLocationRequest == null)
                throw new Late.Client.ApiException(400, "Missing required parameter 'selectGoogleBusinessLocationRequest' when calling ConnectApi->SelectGoogleBusinessLocation");


            Late.Client.RequestOptions localVarRequestOptions = new Late.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };


            var localVarContentType = Late.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Late.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.Data = selectGoogleBusinessLocationRequest;

            // authentication (connectToken) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("X-Connect-Token")))
            {
                localVarRequestOptions.HeaderParameters.Add("X-Connect-Token", this.Configuration.GetApiKeyWithPrefix("X-Connect-Token"));
            }
            // authentication (bearerAuth) required
            // bearer authentication required
            if (!string.IsNullOrEmpty(this.Configuration.AccessToken) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
            }

            // make the HTTP request

            var localVarResponse = await this.AsynchronousClient.PostAsync<SelectGoogleBusinessLocation200Response>("/v1/connect/googlebusiness/select-location", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("SelectGoogleBusinessLocation", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Select LinkedIn organization or personal account after OAuth **Complete the LinkedIn Connection Flow**  After OAuth, the user is redirected with &#x60;organizations&#x60; in the URL params (if they have org admin access). The organizations array contains &#x60;id&#x60;, &#x60;urn&#x60;, and &#x60;name&#x60; fields. Use this data to build your UI,  then call this endpoint to save the selection.  Set &#x60;accountType&#x60; to &#x60;personal&#x60; to connect as the user&#39;s personal LinkedIn profile, or &#x60;organization&#x60; to connect as a company page (requires &#x60;selectedOrganization&#x60; object).  **Personal Profile:** To connect a personal LinkedIn account, set &#x60;accountType&#x60; to &#x60;\&quot;personal\&quot;&#x60; and **omit** the &#x60;selectedOrganization&#x60; field entirely. This is the simplest flow.  **Headless Mode:** Use the &#x60;X-Connect-Token&#x60; header if you initiated the connection via API key. 
        /// </summary>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="selectLinkedInOrganizationRequest"></param>
        /// <returns>SelectLinkedInOrganization200Response</returns>
        public SelectLinkedInOrganization200Response SelectLinkedInOrganization(SelectLinkedInOrganizationRequest selectLinkedInOrganizationRequest)
        {
            Late.Client.ApiResponse<SelectLinkedInOrganization200Response> localVarResponse = SelectLinkedInOrganizationWithHttpInfo(selectLinkedInOrganizationRequest);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Select LinkedIn organization or personal account after OAuth **Complete the LinkedIn Connection Flow**  After OAuth, the user is redirected with &#x60;organizations&#x60; in the URL params (if they have org admin access). The organizations array contains &#x60;id&#x60;, &#x60;urn&#x60;, and &#x60;name&#x60; fields. Use this data to build your UI,  then call this endpoint to save the selection.  Set &#x60;accountType&#x60; to &#x60;personal&#x60; to connect as the user&#39;s personal LinkedIn profile, or &#x60;organization&#x60; to connect as a company page (requires &#x60;selectedOrganization&#x60; object).  **Personal Profile:** To connect a personal LinkedIn account, set &#x60;accountType&#x60; to &#x60;\&quot;personal\&quot;&#x60; and **omit** the &#x60;selectedOrganization&#x60; field entirely. This is the simplest flow.  **Headless Mode:** Use the &#x60;X-Connect-Token&#x60; header if you initiated the connection via API key. 
        /// </summary>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="selectLinkedInOrganizationRequest"></param>
        /// <returns>ApiResponse of SelectLinkedInOrganization200Response</returns>
        public Late.Client.ApiResponse<SelectLinkedInOrganization200Response> SelectLinkedInOrganizationWithHttpInfo(SelectLinkedInOrganizationRequest selectLinkedInOrganizationRequest)
        {
            // verify the required parameter 'selectLinkedInOrganizationRequest' is set
            if (selectLinkedInOrganizationRequest == null)
                throw new Late.Client.ApiException(400, "Missing required parameter 'selectLinkedInOrganizationRequest' when calling ConnectApi->SelectLinkedInOrganization");

            Late.Client.RequestOptions localVarRequestOptions = new Late.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Late.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Late.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.Data = selectLinkedInOrganizationRequest;

            // authentication (bearerAuth) required
            // bearer authentication required
            if (!string.IsNullOrEmpty(this.Configuration.AccessToken) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
            }

            // make the HTTP request
            var localVarResponse = this.Client.Post<SelectLinkedInOrganization200Response>("/v1/connect/linkedin/select-organization", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("SelectLinkedInOrganization", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Select LinkedIn organization or personal account after OAuth **Complete the LinkedIn Connection Flow**  After OAuth, the user is redirected with &#x60;organizations&#x60; in the URL params (if they have org admin access). The organizations array contains &#x60;id&#x60;, &#x60;urn&#x60;, and &#x60;name&#x60; fields. Use this data to build your UI,  then call this endpoint to save the selection.  Set &#x60;accountType&#x60; to &#x60;personal&#x60; to connect as the user&#39;s personal LinkedIn profile, or &#x60;organization&#x60; to connect as a company page (requires &#x60;selectedOrganization&#x60; object).  **Personal Profile:** To connect a personal LinkedIn account, set &#x60;accountType&#x60; to &#x60;\&quot;personal\&quot;&#x60; and **omit** the &#x60;selectedOrganization&#x60; field entirely. This is the simplest flow.  **Headless Mode:** Use the &#x60;X-Connect-Token&#x60; header if you initiated the connection via API key. 
        /// </summary>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="selectLinkedInOrganizationRequest"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of SelectLinkedInOrganization200Response</returns>
        public async System.Threading.Tasks.Task<SelectLinkedInOrganization200Response> SelectLinkedInOrganizationAsync(SelectLinkedInOrganizationRequest selectLinkedInOrganizationRequest, System.Threading.CancellationToken cancellationToken = default)
        {
            Late.Client.ApiResponse<SelectLinkedInOrganization200Response> localVarResponse = await SelectLinkedInOrganizationWithHttpInfoAsync(selectLinkedInOrganizationRequest, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Select LinkedIn organization or personal account after OAuth **Complete the LinkedIn Connection Flow**  After OAuth, the user is redirected with &#x60;organizations&#x60; in the URL params (if they have org admin access). The organizations array contains &#x60;id&#x60;, &#x60;urn&#x60;, and &#x60;name&#x60; fields. Use this data to build your UI,  then call this endpoint to save the selection.  Set &#x60;accountType&#x60; to &#x60;personal&#x60; to connect as the user&#39;s personal LinkedIn profile, or &#x60;organization&#x60; to connect as a company page (requires &#x60;selectedOrganization&#x60; object).  **Personal Profile:** To connect a personal LinkedIn account, set &#x60;accountType&#x60; to &#x60;\&quot;personal\&quot;&#x60; and **omit** the &#x60;selectedOrganization&#x60; field entirely. This is the simplest flow.  **Headless Mode:** Use the &#x60;X-Connect-Token&#x60; header if you initiated the connection via API key. 
        /// </summary>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="selectLinkedInOrganizationRequest"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (SelectLinkedInOrganization200Response)</returns>
        public async System.Threading.Tasks.Task<Late.Client.ApiResponse<SelectLinkedInOrganization200Response>> SelectLinkedInOrganizationWithHttpInfoAsync(SelectLinkedInOrganizationRequest selectLinkedInOrganizationRequest, System.Threading.CancellationToken cancellationToken = default)
        {
            // verify the required parameter 'selectLinkedInOrganizationRequest' is set
            if (selectLinkedInOrganizationRequest == null)
                throw new Late.Client.ApiException(400, "Missing required parameter 'selectLinkedInOrganizationRequest' when calling ConnectApi->SelectLinkedInOrganization");


            Late.Client.RequestOptions localVarRequestOptions = new Late.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };


            var localVarContentType = Late.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Late.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.Data = selectLinkedInOrganizationRequest;

            // authentication (bearerAuth) required
            // bearer authentication required
            if (!string.IsNullOrEmpty(this.Configuration.AccessToken) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
            }

            // make the HTTP request

            var localVarResponse = await this.AsynchronousClient.PostAsync<SelectLinkedInOrganization200Response>("/v1/connect/linkedin/select-organization", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("SelectLinkedInOrganization", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Select a Pinterest Board to complete the connection (Headless Mode) **Complete the Pinterest Connection Flow**  After OAuth, use this endpoint to save the selected board and complete the Pinterest account connection.  **Headless Mode:** Use the &#x60;X-Connect-Token&#x60; header if you initiated the connection via API key. 
        /// </summary>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="selectPinterestBoardRequest"></param>
        /// <returns>SelectPinterestBoard200Response</returns>
        public SelectPinterestBoard200Response SelectPinterestBoard(SelectPinterestBoardRequest selectPinterestBoardRequest)
        {
            Late.Client.ApiResponse<SelectPinterestBoard200Response> localVarResponse = SelectPinterestBoardWithHttpInfo(selectPinterestBoardRequest);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Select a Pinterest Board to complete the connection (Headless Mode) **Complete the Pinterest Connection Flow**  After OAuth, use this endpoint to save the selected board and complete the Pinterest account connection.  **Headless Mode:** Use the &#x60;X-Connect-Token&#x60; header if you initiated the connection via API key. 
        /// </summary>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="selectPinterestBoardRequest"></param>
        /// <returns>ApiResponse of SelectPinterestBoard200Response</returns>
        public Late.Client.ApiResponse<SelectPinterestBoard200Response> SelectPinterestBoardWithHttpInfo(SelectPinterestBoardRequest selectPinterestBoardRequest)
        {
            // verify the required parameter 'selectPinterestBoardRequest' is set
            if (selectPinterestBoardRequest == null)
                throw new Late.Client.ApiException(400, "Missing required parameter 'selectPinterestBoardRequest' when calling ConnectApi->SelectPinterestBoard");

            Late.Client.RequestOptions localVarRequestOptions = new Late.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Late.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Late.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.Data = selectPinterestBoardRequest;

            // authentication (bearerAuth) required
            // bearer authentication required
            if (!string.IsNullOrEmpty(this.Configuration.AccessToken) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
            }

            // make the HTTP request
            var localVarResponse = this.Client.Post<SelectPinterestBoard200Response>("/v1/connect/pinterest/select-board", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("SelectPinterestBoard", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Select a Pinterest Board to complete the connection (Headless Mode) **Complete the Pinterest Connection Flow**  After OAuth, use this endpoint to save the selected board and complete the Pinterest account connection.  **Headless Mode:** Use the &#x60;X-Connect-Token&#x60; header if you initiated the connection via API key. 
        /// </summary>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="selectPinterestBoardRequest"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of SelectPinterestBoard200Response</returns>
        public async System.Threading.Tasks.Task<SelectPinterestBoard200Response> SelectPinterestBoardAsync(SelectPinterestBoardRequest selectPinterestBoardRequest, System.Threading.CancellationToken cancellationToken = default)
        {
            Late.Client.ApiResponse<SelectPinterestBoard200Response> localVarResponse = await SelectPinterestBoardWithHttpInfoAsync(selectPinterestBoardRequest, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Select a Pinterest Board to complete the connection (Headless Mode) **Complete the Pinterest Connection Flow**  After OAuth, use this endpoint to save the selected board and complete the Pinterest account connection.  **Headless Mode:** Use the &#x60;X-Connect-Token&#x60; header if you initiated the connection via API key. 
        /// </summary>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="selectPinterestBoardRequest"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (SelectPinterestBoard200Response)</returns>
        public async System.Threading.Tasks.Task<Late.Client.ApiResponse<SelectPinterestBoard200Response>> SelectPinterestBoardWithHttpInfoAsync(SelectPinterestBoardRequest selectPinterestBoardRequest, System.Threading.CancellationToken cancellationToken = default)
        {
            // verify the required parameter 'selectPinterestBoardRequest' is set
            if (selectPinterestBoardRequest == null)
                throw new Late.Client.ApiException(400, "Missing required parameter 'selectPinterestBoardRequest' when calling ConnectApi->SelectPinterestBoard");


            Late.Client.RequestOptions localVarRequestOptions = new Late.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };


            var localVarContentType = Late.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Late.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.Data = selectPinterestBoardRequest;

            // authentication (bearerAuth) required
            // bearer authentication required
            if (!string.IsNullOrEmpty(this.Configuration.AccessToken) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
            }

            // make the HTTP request

            var localVarResponse = await this.AsynchronousClient.PostAsync<SelectPinterestBoard200Response>("/v1/connect/pinterest/select-board", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("SelectPinterestBoard", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Select a Snapchat Public Profile to complete the connection (Headless Mode) **Complete the Snapchat Connection Flow**  After OAuth, use this endpoint to save the selected Public Profile and complete the Snapchat account connection. Snapchat requires a Public Profile to publish Stories, Saved Stories, and Spotlight content.  **Headless Mode:** Use the &#x60;X-Connect-Token&#x60; header if you initiated the connection via API key.  After initiating Snapchat OAuth via &#x60;/v1/connect/snapchat?headless&#x3D;true&#x60;, you&#39;ll be redirected to your &#x60;redirect_url&#x60; with query params including: - &#x60;tempToken&#x60; - Temporary access token - &#x60;userProfile&#x60; - URL-encoded JSON with user info - &#x60;publicProfiles&#x60; - URL-encoded JSON array of available public profiles - &#x60;connect_token&#x60; - Short-lived token for API authentication - &#x60;platform&#x3D;snapchat&#x60; - &#x60;step&#x3D;select_public_profile&#x60;  Parse &#x60;publicProfiles&#x60; to build your custom selector UI, then call this endpoint with the selected profile. 
        /// </summary>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="selectSnapchatProfileRequest"></param>
        /// <param name="xConnectToken">Short-lived connect token from the OAuth redirect (for API users) (optional)</param>
        /// <returns>SelectSnapchatProfile200Response</returns>
        public SelectSnapchatProfile200Response SelectSnapchatProfile(SelectSnapchatProfileRequest selectSnapchatProfileRequest, string? xConnectToken = default)
        {
            Late.Client.ApiResponse<SelectSnapchatProfile200Response> localVarResponse = SelectSnapchatProfileWithHttpInfo(selectSnapchatProfileRequest, xConnectToken);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Select a Snapchat Public Profile to complete the connection (Headless Mode) **Complete the Snapchat Connection Flow**  After OAuth, use this endpoint to save the selected Public Profile and complete the Snapchat account connection. Snapchat requires a Public Profile to publish Stories, Saved Stories, and Spotlight content.  **Headless Mode:** Use the &#x60;X-Connect-Token&#x60; header if you initiated the connection via API key.  After initiating Snapchat OAuth via &#x60;/v1/connect/snapchat?headless&#x3D;true&#x60;, you&#39;ll be redirected to your &#x60;redirect_url&#x60; with query params including: - &#x60;tempToken&#x60; - Temporary access token - &#x60;userProfile&#x60; - URL-encoded JSON with user info - &#x60;publicProfiles&#x60; - URL-encoded JSON array of available public profiles - &#x60;connect_token&#x60; - Short-lived token for API authentication - &#x60;platform&#x3D;snapchat&#x60; - &#x60;step&#x3D;select_public_profile&#x60;  Parse &#x60;publicProfiles&#x60; to build your custom selector UI, then call this endpoint with the selected profile. 
        /// </summary>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="selectSnapchatProfileRequest"></param>
        /// <param name="xConnectToken">Short-lived connect token from the OAuth redirect (for API users) (optional)</param>
        /// <returns>ApiResponse of SelectSnapchatProfile200Response</returns>
        public Late.Client.ApiResponse<SelectSnapchatProfile200Response> SelectSnapchatProfileWithHttpInfo(SelectSnapchatProfileRequest selectSnapchatProfileRequest, string? xConnectToken = default)
        {
            // verify the required parameter 'selectSnapchatProfileRequest' is set
            if (selectSnapchatProfileRequest == null)
                throw new Late.Client.ApiException(400, "Missing required parameter 'selectSnapchatProfileRequest' when calling ConnectApi->SelectSnapchatProfile");

            Late.Client.RequestOptions localVarRequestOptions = new Late.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Late.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Late.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            if (xConnectToken != null)
            {
                localVarRequestOptions.HeaderParameters.Add("X-Connect-Token", Late.Client.ClientUtils.ParameterToString(xConnectToken)); // header parameter
            }
            localVarRequestOptions.Data = selectSnapchatProfileRequest;

            // authentication (bearerAuth) required
            // bearer authentication required
            if (!string.IsNullOrEmpty(this.Configuration.AccessToken) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
            }

            // make the HTTP request
            var localVarResponse = this.Client.Post<SelectSnapchatProfile200Response>("/v1/connect/snapchat/select-profile", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("SelectSnapchatProfile", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Select a Snapchat Public Profile to complete the connection (Headless Mode) **Complete the Snapchat Connection Flow**  After OAuth, use this endpoint to save the selected Public Profile and complete the Snapchat account connection. Snapchat requires a Public Profile to publish Stories, Saved Stories, and Spotlight content.  **Headless Mode:** Use the &#x60;X-Connect-Token&#x60; header if you initiated the connection via API key.  After initiating Snapchat OAuth via &#x60;/v1/connect/snapchat?headless&#x3D;true&#x60;, you&#39;ll be redirected to your &#x60;redirect_url&#x60; with query params including: - &#x60;tempToken&#x60; - Temporary access token - &#x60;userProfile&#x60; - URL-encoded JSON with user info - &#x60;publicProfiles&#x60; - URL-encoded JSON array of available public profiles - &#x60;connect_token&#x60; - Short-lived token for API authentication - &#x60;platform&#x3D;snapchat&#x60; - &#x60;step&#x3D;select_public_profile&#x60;  Parse &#x60;publicProfiles&#x60; to build your custom selector UI, then call this endpoint with the selected profile. 
        /// </summary>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="selectSnapchatProfileRequest"></param>
        /// <param name="xConnectToken">Short-lived connect token from the OAuth redirect (for API users) (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of SelectSnapchatProfile200Response</returns>
        public async System.Threading.Tasks.Task<SelectSnapchatProfile200Response> SelectSnapchatProfileAsync(SelectSnapchatProfileRequest selectSnapchatProfileRequest, string? xConnectToken = default, System.Threading.CancellationToken cancellationToken = default)
        {
            Late.Client.ApiResponse<SelectSnapchatProfile200Response> localVarResponse = await SelectSnapchatProfileWithHttpInfoAsync(selectSnapchatProfileRequest, xConnectToken, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Select a Snapchat Public Profile to complete the connection (Headless Mode) **Complete the Snapchat Connection Flow**  After OAuth, use this endpoint to save the selected Public Profile and complete the Snapchat account connection. Snapchat requires a Public Profile to publish Stories, Saved Stories, and Spotlight content.  **Headless Mode:** Use the &#x60;X-Connect-Token&#x60; header if you initiated the connection via API key.  After initiating Snapchat OAuth via &#x60;/v1/connect/snapchat?headless&#x3D;true&#x60;, you&#39;ll be redirected to your &#x60;redirect_url&#x60; with query params including: - &#x60;tempToken&#x60; - Temporary access token - &#x60;userProfile&#x60; - URL-encoded JSON with user info - &#x60;publicProfiles&#x60; - URL-encoded JSON array of available public profiles - &#x60;connect_token&#x60; - Short-lived token for API authentication - &#x60;platform&#x3D;snapchat&#x60; - &#x60;step&#x3D;select_public_profile&#x60;  Parse &#x60;publicProfiles&#x60; to build your custom selector UI, then call this endpoint with the selected profile. 
        /// </summary>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="selectSnapchatProfileRequest"></param>
        /// <param name="xConnectToken">Short-lived connect token from the OAuth redirect (for API users) (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (SelectSnapchatProfile200Response)</returns>
        public async System.Threading.Tasks.Task<Late.Client.ApiResponse<SelectSnapchatProfile200Response>> SelectSnapchatProfileWithHttpInfoAsync(SelectSnapchatProfileRequest selectSnapchatProfileRequest, string? xConnectToken = default, System.Threading.CancellationToken cancellationToken = default)
        {
            // verify the required parameter 'selectSnapchatProfileRequest' is set
            if (selectSnapchatProfileRequest == null)
                throw new Late.Client.ApiException(400, "Missing required parameter 'selectSnapchatProfileRequest' when calling ConnectApi->SelectSnapchatProfile");


            Late.Client.RequestOptions localVarRequestOptions = new Late.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };


            var localVarContentType = Late.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Late.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            if (xConnectToken != null)
            {
                localVarRequestOptions.HeaderParameters.Add("X-Connect-Token", Late.Client.ClientUtils.ParameterToString(xConnectToken)); // header parameter
            }
            localVarRequestOptions.Data = selectSnapchatProfileRequest;

            // authentication (bearerAuth) required
            // bearer authentication required
            if (!string.IsNullOrEmpty(this.Configuration.AccessToken) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
            }

            // make the HTTP request

            var localVarResponse = await this.AsynchronousClient.PostAsync<SelectSnapchatProfile200Response>("/v1/connect/snapchat/select-profile", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("SelectSnapchatProfile", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Update selected Facebook page for a connected account 
        /// </summary>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="accountId"></param>
        /// <param name="updateFacebookPageRequest"></param>
        /// <returns>UpdateFacebookPage200Response</returns>
        public UpdateFacebookPage200Response UpdateFacebookPage(string accountId, UpdateFacebookPageRequest updateFacebookPageRequest)
        {
            Late.Client.ApiResponse<UpdateFacebookPage200Response> localVarResponse = UpdateFacebookPageWithHttpInfo(accountId, updateFacebookPageRequest);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Update selected Facebook page for a connected account 
        /// </summary>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="accountId"></param>
        /// <param name="updateFacebookPageRequest"></param>
        /// <returns>ApiResponse of UpdateFacebookPage200Response</returns>
        public Late.Client.ApiResponse<UpdateFacebookPage200Response> UpdateFacebookPageWithHttpInfo(string accountId, UpdateFacebookPageRequest updateFacebookPageRequest)
        {
            // verify the required parameter 'accountId' is set
            if (accountId == null)
                throw new Late.Client.ApiException(400, "Missing required parameter 'accountId' when calling ConnectApi->UpdateFacebookPage");

            // verify the required parameter 'updateFacebookPageRequest' is set
            if (updateFacebookPageRequest == null)
                throw new Late.Client.ApiException(400, "Missing required parameter 'updateFacebookPageRequest' when calling ConnectApi->UpdateFacebookPage");

            Late.Client.RequestOptions localVarRequestOptions = new Late.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Late.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Late.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("accountId", Late.Client.ClientUtils.ParameterToString(accountId)); // path parameter
            localVarRequestOptions.Data = updateFacebookPageRequest;

            // authentication (bearerAuth) required
            // bearer authentication required
            if (!string.IsNullOrEmpty(this.Configuration.AccessToken) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
            }

            // make the HTTP request
            var localVarResponse = this.Client.Put<UpdateFacebookPage200Response>("/v1/accounts/{accountId}/facebook-page", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateFacebookPage", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Update selected Facebook page for a connected account 
        /// </summary>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="accountId"></param>
        /// <param name="updateFacebookPageRequest"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of UpdateFacebookPage200Response</returns>
        public async System.Threading.Tasks.Task<UpdateFacebookPage200Response> UpdateFacebookPageAsync(string accountId, UpdateFacebookPageRequest updateFacebookPageRequest, System.Threading.CancellationToken cancellationToken = default)
        {
            Late.Client.ApiResponse<UpdateFacebookPage200Response> localVarResponse = await UpdateFacebookPageWithHttpInfoAsync(accountId, updateFacebookPageRequest, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Update selected Facebook page for a connected account 
        /// </summary>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="accountId"></param>
        /// <param name="updateFacebookPageRequest"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (UpdateFacebookPage200Response)</returns>
        public async System.Threading.Tasks.Task<Late.Client.ApiResponse<UpdateFacebookPage200Response>> UpdateFacebookPageWithHttpInfoAsync(string accountId, UpdateFacebookPageRequest updateFacebookPageRequest, System.Threading.CancellationToken cancellationToken = default)
        {
            // verify the required parameter 'accountId' is set
            if (accountId == null)
                throw new Late.Client.ApiException(400, "Missing required parameter 'accountId' when calling ConnectApi->UpdateFacebookPage");

            // verify the required parameter 'updateFacebookPageRequest' is set
            if (updateFacebookPageRequest == null)
                throw new Late.Client.ApiException(400, "Missing required parameter 'updateFacebookPageRequest' when calling ConnectApi->UpdateFacebookPage");


            Late.Client.RequestOptions localVarRequestOptions = new Late.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };


            var localVarContentType = Late.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Late.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("accountId", Late.Client.ClientUtils.ParameterToString(accountId)); // path parameter
            localVarRequestOptions.Data = updateFacebookPageRequest;

            // authentication (bearerAuth) required
            // bearer authentication required
            if (!string.IsNullOrEmpty(this.Configuration.AccessToken) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
            }

            // make the HTTP request

            var localVarResponse = await this.AsynchronousClient.PutAsync<UpdateFacebookPage200Response>("/v1/accounts/{accountId}/facebook-page", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateFacebookPage", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Update selected Google Business Profile location for a connected account 
        /// </summary>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="accountId"></param>
        /// <param name="updateGmbLocationRequest"></param>
        /// <returns>UpdateGmbLocation200Response</returns>
        public UpdateGmbLocation200Response UpdateGmbLocation(string accountId, UpdateGmbLocationRequest updateGmbLocationRequest)
        {
            Late.Client.ApiResponse<UpdateGmbLocation200Response> localVarResponse = UpdateGmbLocationWithHttpInfo(accountId, updateGmbLocationRequest);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Update selected Google Business Profile location for a connected account 
        /// </summary>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="accountId"></param>
        /// <param name="updateGmbLocationRequest"></param>
        /// <returns>ApiResponse of UpdateGmbLocation200Response</returns>
        public Late.Client.ApiResponse<UpdateGmbLocation200Response> UpdateGmbLocationWithHttpInfo(string accountId, UpdateGmbLocationRequest updateGmbLocationRequest)
        {
            // verify the required parameter 'accountId' is set
            if (accountId == null)
                throw new Late.Client.ApiException(400, "Missing required parameter 'accountId' when calling ConnectApi->UpdateGmbLocation");

            // verify the required parameter 'updateGmbLocationRequest' is set
            if (updateGmbLocationRequest == null)
                throw new Late.Client.ApiException(400, "Missing required parameter 'updateGmbLocationRequest' when calling ConnectApi->UpdateGmbLocation");

            Late.Client.RequestOptions localVarRequestOptions = new Late.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Late.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Late.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("accountId", Late.Client.ClientUtils.ParameterToString(accountId)); // path parameter
            localVarRequestOptions.Data = updateGmbLocationRequest;

            // authentication (bearerAuth) required
            // bearer authentication required
            if (!string.IsNullOrEmpty(this.Configuration.AccessToken) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
            }

            // make the HTTP request
            var localVarResponse = this.Client.Put<UpdateGmbLocation200Response>("/v1/accounts/{accountId}/gmb-locations", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateGmbLocation", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Update selected Google Business Profile location for a connected account 
        /// </summary>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="accountId"></param>
        /// <param name="updateGmbLocationRequest"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of UpdateGmbLocation200Response</returns>
        public async System.Threading.Tasks.Task<UpdateGmbLocation200Response> UpdateGmbLocationAsync(string accountId, UpdateGmbLocationRequest updateGmbLocationRequest, System.Threading.CancellationToken cancellationToken = default)
        {
            Late.Client.ApiResponse<UpdateGmbLocation200Response> localVarResponse = await UpdateGmbLocationWithHttpInfoAsync(accountId, updateGmbLocationRequest, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Update selected Google Business Profile location for a connected account 
        /// </summary>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="accountId"></param>
        /// <param name="updateGmbLocationRequest"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (UpdateGmbLocation200Response)</returns>
        public async System.Threading.Tasks.Task<Late.Client.ApiResponse<UpdateGmbLocation200Response>> UpdateGmbLocationWithHttpInfoAsync(string accountId, UpdateGmbLocationRequest updateGmbLocationRequest, System.Threading.CancellationToken cancellationToken = default)
        {
            // verify the required parameter 'accountId' is set
            if (accountId == null)
                throw new Late.Client.ApiException(400, "Missing required parameter 'accountId' when calling ConnectApi->UpdateGmbLocation");

            // verify the required parameter 'updateGmbLocationRequest' is set
            if (updateGmbLocationRequest == null)
                throw new Late.Client.ApiException(400, "Missing required parameter 'updateGmbLocationRequest' when calling ConnectApi->UpdateGmbLocation");


            Late.Client.RequestOptions localVarRequestOptions = new Late.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };


            var localVarContentType = Late.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Late.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("accountId", Late.Client.ClientUtils.ParameterToString(accountId)); // path parameter
            localVarRequestOptions.Data = updateGmbLocationRequest;

            // authentication (bearerAuth) required
            // bearer authentication required
            if (!string.IsNullOrEmpty(this.Configuration.AccessToken) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
            }

            // make the HTTP request

            var localVarResponse = await this.AsynchronousClient.PutAsync<UpdateGmbLocation200Response>("/v1/accounts/{accountId}/gmb-locations", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateGmbLocation", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Switch LinkedIn account type (personal/organization) 
        /// </summary>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="accountId"></param>
        /// <param name="updateLinkedInOrganizationRequest"></param>
        /// <returns>ConnectBlueskyCredentials200Response</returns>
        public ConnectBlueskyCredentials200Response UpdateLinkedInOrganization(string accountId, UpdateLinkedInOrganizationRequest updateLinkedInOrganizationRequest)
        {
            Late.Client.ApiResponse<ConnectBlueskyCredentials200Response> localVarResponse = UpdateLinkedInOrganizationWithHttpInfo(accountId, updateLinkedInOrganizationRequest);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Switch LinkedIn account type (personal/organization) 
        /// </summary>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="accountId"></param>
        /// <param name="updateLinkedInOrganizationRequest"></param>
        /// <returns>ApiResponse of ConnectBlueskyCredentials200Response</returns>
        public Late.Client.ApiResponse<ConnectBlueskyCredentials200Response> UpdateLinkedInOrganizationWithHttpInfo(string accountId, UpdateLinkedInOrganizationRequest updateLinkedInOrganizationRequest)
        {
            // verify the required parameter 'accountId' is set
            if (accountId == null)
                throw new Late.Client.ApiException(400, "Missing required parameter 'accountId' when calling ConnectApi->UpdateLinkedInOrganization");

            // verify the required parameter 'updateLinkedInOrganizationRequest' is set
            if (updateLinkedInOrganizationRequest == null)
                throw new Late.Client.ApiException(400, "Missing required parameter 'updateLinkedInOrganizationRequest' when calling ConnectApi->UpdateLinkedInOrganization");

            Late.Client.RequestOptions localVarRequestOptions = new Late.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Late.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Late.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("accountId", Late.Client.ClientUtils.ParameterToString(accountId)); // path parameter
            localVarRequestOptions.Data = updateLinkedInOrganizationRequest;

            // authentication (bearerAuth) required
            // bearer authentication required
            if (!string.IsNullOrEmpty(this.Configuration.AccessToken) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
            }

            // make the HTTP request
            var localVarResponse = this.Client.Put<ConnectBlueskyCredentials200Response>("/v1/accounts/{accountId}/linkedin-organization", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateLinkedInOrganization", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Switch LinkedIn account type (personal/organization) 
        /// </summary>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="accountId"></param>
        /// <param name="updateLinkedInOrganizationRequest"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ConnectBlueskyCredentials200Response</returns>
        public async System.Threading.Tasks.Task<ConnectBlueskyCredentials200Response> UpdateLinkedInOrganizationAsync(string accountId, UpdateLinkedInOrganizationRequest updateLinkedInOrganizationRequest, System.Threading.CancellationToken cancellationToken = default)
        {
            Late.Client.ApiResponse<ConnectBlueskyCredentials200Response> localVarResponse = await UpdateLinkedInOrganizationWithHttpInfoAsync(accountId, updateLinkedInOrganizationRequest, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Switch LinkedIn account type (personal/organization) 
        /// </summary>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="accountId"></param>
        /// <param name="updateLinkedInOrganizationRequest"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (ConnectBlueskyCredentials200Response)</returns>
        public async System.Threading.Tasks.Task<Late.Client.ApiResponse<ConnectBlueskyCredentials200Response>> UpdateLinkedInOrganizationWithHttpInfoAsync(string accountId, UpdateLinkedInOrganizationRequest updateLinkedInOrganizationRequest, System.Threading.CancellationToken cancellationToken = default)
        {
            // verify the required parameter 'accountId' is set
            if (accountId == null)
                throw new Late.Client.ApiException(400, "Missing required parameter 'accountId' when calling ConnectApi->UpdateLinkedInOrganization");

            // verify the required parameter 'updateLinkedInOrganizationRequest' is set
            if (updateLinkedInOrganizationRequest == null)
                throw new Late.Client.ApiException(400, "Missing required parameter 'updateLinkedInOrganizationRequest' when calling ConnectApi->UpdateLinkedInOrganization");


            Late.Client.RequestOptions localVarRequestOptions = new Late.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };


            var localVarContentType = Late.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Late.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("accountId", Late.Client.ClientUtils.ParameterToString(accountId)); // path parameter
            localVarRequestOptions.Data = updateLinkedInOrganizationRequest;

            // authentication (bearerAuth) required
            // bearer authentication required
            if (!string.IsNullOrEmpty(this.Configuration.AccessToken) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
            }

            // make the HTTP request

            var localVarResponse = await this.AsynchronousClient.PutAsync<ConnectBlueskyCredentials200Response>("/v1/accounts/{accountId}/linkedin-organization", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateLinkedInOrganization", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Set default Pinterest board on the connection 
        /// </summary>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="accountId"></param>
        /// <param name="updatePinterestBoardsRequest"></param>
        /// <returns>ConnectBlueskyCredentials200Response</returns>
        public ConnectBlueskyCredentials200Response UpdatePinterestBoards(string accountId, UpdatePinterestBoardsRequest updatePinterestBoardsRequest)
        {
            Late.Client.ApiResponse<ConnectBlueskyCredentials200Response> localVarResponse = UpdatePinterestBoardsWithHttpInfo(accountId, updatePinterestBoardsRequest);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Set default Pinterest board on the connection 
        /// </summary>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="accountId"></param>
        /// <param name="updatePinterestBoardsRequest"></param>
        /// <returns>ApiResponse of ConnectBlueskyCredentials200Response</returns>
        public Late.Client.ApiResponse<ConnectBlueskyCredentials200Response> UpdatePinterestBoardsWithHttpInfo(string accountId, UpdatePinterestBoardsRequest updatePinterestBoardsRequest)
        {
            // verify the required parameter 'accountId' is set
            if (accountId == null)
                throw new Late.Client.ApiException(400, "Missing required parameter 'accountId' when calling ConnectApi->UpdatePinterestBoards");

            // verify the required parameter 'updatePinterestBoardsRequest' is set
            if (updatePinterestBoardsRequest == null)
                throw new Late.Client.ApiException(400, "Missing required parameter 'updatePinterestBoardsRequest' when calling ConnectApi->UpdatePinterestBoards");

            Late.Client.RequestOptions localVarRequestOptions = new Late.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Late.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Late.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("accountId", Late.Client.ClientUtils.ParameterToString(accountId)); // path parameter
            localVarRequestOptions.Data = updatePinterestBoardsRequest;

            // authentication (bearerAuth) required
            // bearer authentication required
            if (!string.IsNullOrEmpty(this.Configuration.AccessToken) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
            }

            // make the HTTP request
            var localVarResponse = this.Client.Put<ConnectBlueskyCredentials200Response>("/v1/accounts/{accountId}/pinterest-boards", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdatePinterestBoards", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Set default Pinterest board on the connection 
        /// </summary>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="accountId"></param>
        /// <param name="updatePinterestBoardsRequest"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ConnectBlueskyCredentials200Response</returns>
        public async System.Threading.Tasks.Task<ConnectBlueskyCredentials200Response> UpdatePinterestBoardsAsync(string accountId, UpdatePinterestBoardsRequest updatePinterestBoardsRequest, System.Threading.CancellationToken cancellationToken = default)
        {
            Late.Client.ApiResponse<ConnectBlueskyCredentials200Response> localVarResponse = await UpdatePinterestBoardsWithHttpInfoAsync(accountId, updatePinterestBoardsRequest, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Set default Pinterest board on the connection 
        /// </summary>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="accountId"></param>
        /// <param name="updatePinterestBoardsRequest"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (ConnectBlueskyCredentials200Response)</returns>
        public async System.Threading.Tasks.Task<Late.Client.ApiResponse<ConnectBlueskyCredentials200Response>> UpdatePinterestBoardsWithHttpInfoAsync(string accountId, UpdatePinterestBoardsRequest updatePinterestBoardsRequest, System.Threading.CancellationToken cancellationToken = default)
        {
            // verify the required parameter 'accountId' is set
            if (accountId == null)
                throw new Late.Client.ApiException(400, "Missing required parameter 'accountId' when calling ConnectApi->UpdatePinterestBoards");

            // verify the required parameter 'updatePinterestBoardsRequest' is set
            if (updatePinterestBoardsRequest == null)
                throw new Late.Client.ApiException(400, "Missing required parameter 'updatePinterestBoardsRequest' when calling ConnectApi->UpdatePinterestBoards");


            Late.Client.RequestOptions localVarRequestOptions = new Late.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };


            var localVarContentType = Late.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Late.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("accountId", Late.Client.ClientUtils.ParameterToString(accountId)); // path parameter
            localVarRequestOptions.Data = updatePinterestBoardsRequest;

            // authentication (bearerAuth) required
            // bearer authentication required
            if (!string.IsNullOrEmpty(this.Configuration.AccessToken) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
            }

            // make the HTTP request

            var localVarResponse = await this.AsynchronousClient.PutAsync<ConnectBlueskyCredentials200Response>("/v1/accounts/{accountId}/pinterest-boards", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdatePinterestBoards", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Set default subreddit on the connection 
        /// </summary>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="accountId"></param>
        /// <param name="updateRedditSubredditsRequest"></param>
        /// <returns>UpdateRedditSubreddits200Response</returns>
        public UpdateRedditSubreddits200Response UpdateRedditSubreddits(string accountId, UpdateRedditSubredditsRequest updateRedditSubredditsRequest)
        {
            Late.Client.ApiResponse<UpdateRedditSubreddits200Response> localVarResponse = UpdateRedditSubredditsWithHttpInfo(accountId, updateRedditSubredditsRequest);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Set default subreddit on the connection 
        /// </summary>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="accountId"></param>
        /// <param name="updateRedditSubredditsRequest"></param>
        /// <returns>ApiResponse of UpdateRedditSubreddits200Response</returns>
        public Late.Client.ApiResponse<UpdateRedditSubreddits200Response> UpdateRedditSubredditsWithHttpInfo(string accountId, UpdateRedditSubredditsRequest updateRedditSubredditsRequest)
        {
            // verify the required parameter 'accountId' is set
            if (accountId == null)
                throw new Late.Client.ApiException(400, "Missing required parameter 'accountId' when calling ConnectApi->UpdateRedditSubreddits");

            // verify the required parameter 'updateRedditSubredditsRequest' is set
            if (updateRedditSubredditsRequest == null)
                throw new Late.Client.ApiException(400, "Missing required parameter 'updateRedditSubredditsRequest' when calling ConnectApi->UpdateRedditSubreddits");

            Late.Client.RequestOptions localVarRequestOptions = new Late.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Late.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Late.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("accountId", Late.Client.ClientUtils.ParameterToString(accountId)); // path parameter
            localVarRequestOptions.Data = updateRedditSubredditsRequest;

            // authentication (bearerAuth) required
            // bearer authentication required
            if (!string.IsNullOrEmpty(this.Configuration.AccessToken) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
            }

            // make the HTTP request
            var localVarResponse = this.Client.Put<UpdateRedditSubreddits200Response>("/v1/accounts/{accountId}/reddit-subreddits", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateRedditSubreddits", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Set default subreddit on the connection 
        /// </summary>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="accountId"></param>
        /// <param name="updateRedditSubredditsRequest"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of UpdateRedditSubreddits200Response</returns>
        public async System.Threading.Tasks.Task<UpdateRedditSubreddits200Response> UpdateRedditSubredditsAsync(string accountId, UpdateRedditSubredditsRequest updateRedditSubredditsRequest, System.Threading.CancellationToken cancellationToken = default)
        {
            Late.Client.ApiResponse<UpdateRedditSubreddits200Response> localVarResponse = await UpdateRedditSubredditsWithHttpInfoAsync(accountId, updateRedditSubredditsRequest, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Set default subreddit on the connection 
        /// </summary>
        /// <exception cref="Late.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="accountId"></param>
        /// <param name="updateRedditSubredditsRequest"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (UpdateRedditSubreddits200Response)</returns>
        public async System.Threading.Tasks.Task<Late.Client.ApiResponse<UpdateRedditSubreddits200Response>> UpdateRedditSubredditsWithHttpInfoAsync(string accountId, UpdateRedditSubredditsRequest updateRedditSubredditsRequest, System.Threading.CancellationToken cancellationToken = default)
        {
            // verify the required parameter 'accountId' is set
            if (accountId == null)
                throw new Late.Client.ApiException(400, "Missing required parameter 'accountId' when calling ConnectApi->UpdateRedditSubreddits");

            // verify the required parameter 'updateRedditSubredditsRequest' is set
            if (updateRedditSubredditsRequest == null)
                throw new Late.Client.ApiException(400, "Missing required parameter 'updateRedditSubredditsRequest' when calling ConnectApi->UpdateRedditSubreddits");


            Late.Client.RequestOptions localVarRequestOptions = new Late.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };


            var localVarContentType = Late.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Late.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("accountId", Late.Client.ClientUtils.ParameterToString(accountId)); // path parameter
            localVarRequestOptions.Data = updateRedditSubredditsRequest;

            // authentication (bearerAuth) required
            // bearer authentication required
            if (!string.IsNullOrEmpty(this.Configuration.AccessToken) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
            }

            // make the HTTP request

            var localVarResponse = await this.AsynchronousClient.PutAsync<UpdateRedditSubreddits200Response>("/v1/accounts/{accountId}/reddit-subreddits", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateRedditSubreddits", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

    }
}
